<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dash&#39;s Blog</title>
    <link>https://yuukidach.github.io/post/</link>
    <description>Recent content in Posts on Dash&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Dec 2020 17:32:31 +0800</lastBuildDate><atom:link href="https://yuukidach.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从HEXO迁移到HUGO</title>
      <link>https://yuukidach.github.io/p/migratetohugo/</link>
      <pubDate>Wed, 30 Dec 2020 17:32:31 +0800</pubDate>
      
      <guid>https://yuukidach.github.io/p/migratetohugo/</guid>
      <description>为什么要进行迁移 对我来说HEXO实在是过于麻烦。
最早接触这个东西，是看到别人的博客，发现很有趣，因此自己也想写一点东西上去。那个时候普遍采用 GitHub Page + HEXO 的做法，我自然也使用了同样的方法。
然而随着时间线的拉长，在不同的环境下进行博客的恢复、管理，让我开始想尝试HEXO以外的方式。HEXO对我来说，不好的有以下几个方面：
  包管理复杂。HEXO不像HUGO这样已经编译好，而使用npm进行各种包的管理，对于一个这方面的小白来说，我完全没法自己处理好各种 warning 和 error。GitHub也常常提示我有安全漏洞，但是我都不知道如何去修复比较好
  图片插入麻烦。最开始我选择将图片上传到7牛进行托管，但是几年后我发现链接早就已经失效了。还是放在本地比较保险。而HEXO的本地插入实在是不敢恭维。
  公式编辑。在我最开始使用到HEXO的时候，我并没有关心公式编辑这个问题。但是随着专业学习的深入，我逐渐开始依赖起这个功能来。承接第一点，让 HEXO 支持公式编辑费了我不少时间，让我对 HEXO 的易用程度进一步失去信心。我不想再未来当我需要新功能的时候，发现已经办法再去添加了。
  不过不再使用HEXO也有一点小小的遗憾，那就是自己当初花了大把大把的时间去魔改我所有的主题模板，现在一下就舍弃掉，还是有那么点心疼，自己的心血终究还是被推倒了。
 老界面1 
 老界面2 
 老界面3 
不管怎么说，以后还是用HUGO吧，尽管它的主题比HEXO少了很多。但是对于不喜欢频繁更换主题的我来说，这点并不算能够阻挡我使用 HUGO 的原因。
不强求博客更新多么高质量和频繁，以后能想起来就更新一点点吧。</description>
    </item>
    
    <item>
      <title>Decision Tree and k-Nearest Neighbors Learning</title>
      <link>https://yuukidach.github.io/p/ml/decision-tree-and-knn-learning/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/ml/decision-tree-and-knn-learning/</guid>
      <description>Entropy 1. Shannon information
\[ I = -\log_2{p} \]
 $ p $ is the probability of the event Event with smaller probability contains more information. Logrithm base is 2 beacause in information technology 1 bit represents &amp;quot;0&amp;quot; or &amp;quot;1&amp;quot;.  It can also be regarded as how many bits we need to represent a random variable
\[ \#bits = \log_2{1\over{p}} \]
For example, when one variable has 8 possibilities. Each of them has a probability of 1/8.</description>
    </item>
    
    <item>
      <title>Transaction and Concurrency Control</title>
      <link>https://yuukidach.github.io/p/transaction-and-concurrency-control/</link>
      <pubDate>Fri, 13 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/transaction-and-concurrency-control/</guid>
      <description>Transaction Definition Transaction: A sequence of multiple actions to be executed as an atomic unit.
Transaction in SQL view:
 Begin transaction Sequence of SQL statements End transaction  Transaction Manager controls excution of transactions. Program logic is invisible to DBMS. For example:
1. start transaction 2. read(R) 3. R = R - 100 ------&amp;gt; Invisible 4. write(R) 5. read(S) 6. S = S + 100 ------&amp;gt; Invisible 7. write(S) 8.</description>
    </item>
    
    <item>
      <title>My Manjaro i3 Configurations</title>
      <link>https://yuukidach.github.io/p/my-manjaro-i3-configurations/</link>
      <pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/my-manjaro-i3-configurations/</guid>
      <description>Manjaro edition: Manjaro-i3
This post is about how I configure my Manjaro i3
Softwares to Install  fcitx5 (no need to install sogou pinyin for linux anymore) deepin-wine-wechat deepin-wine-tim wps-office (together with ttf-wps-fonts) ttf-menlo-powerline-git (font for terminal) mpv (vedio player) netease-cloud-music Insync (sync a certain folder with google driver) variety (wallpaper software) picom albert (a fast launcher) vim (with vimplus) flameshot (screen capture tool) nerd-fonts-jetbrains-mono (font for vscode) ncdu (Simple ncurses disk usage analyzer)  Multiple Monitors When we plug a HDMI/VGA cable into the computer, Manjaro i3 will not automatically display content in the external monitor.</description>
    </item>
    
    <item>
      <title>Use Oracle on Docker for Windows</title>
      <link>https://yuukidach.github.io/p/use-oracle-on-docker-for-windows/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/use-oracle-on-docker-for-windows/</guid>
      <description>Environment version     WSL 2   Docker Engine v19.03.13   Oracle Database Enterprise 12.2.0.1    Install WLS2 Check detailed and official document here.
Problems I encountered 1. Use any commands related to WSL2 will cause error： “The attempted operation is not supported for the type of object referenced.”
This is beacause the proxy software conflicts with the sock port of WSL2.</description>
    </item>
    
    <item>
      <title>第一次辞职</title>
      <link>https://yuukidach.github.io/p/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BE%9E%E8%81%8C/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BE%9E%E8%81%8C/</guid>
      <description>距离本周一提出离职已经过去4天。在同CEO以及CTO都经过交流之后，终于思考清楚，也能好好地把事情做个记录。
给人力的离职信全文
本次离职的直接原因是生病发烧，带来心态上的变化，根本原因还是对工作内容的不喜欢。在和两位老板交流时，他们都表达了挽留的意思。但是挽留的说法却不尽相同。
我是在周一晚上向CEO提出离职的，随后便进行了一次长达51分钟的电话聊天。聊天内容基本上是在问我对工作不满意的地方，以及我希望怎么样调整工作的方向。我个人对于CEO的印象还是非常不错的。年轻，没有架子，思辨性很强，对员工也极为友善，愿意培养新人。当初也是他直接省去了后续的面试，在两轮面试后，直接将我招进公司。在和他聊了这么多之后，我不由得感觉到一阵内疚加失落，这种感觉一直持续到周二结束。
一方面我个人觉得这样的老板之后确实是很难遇到了，另一方面，虽然我的离职想法早就确定了，但是在目前公司缺人的情况下突然提出来，还是有点惭愧。
为此我特意和我同样在工作的同学进行了短暂的意见交流，在得到他的支持意见后，我也逐渐安下心来。离职的想法也愈加坚定。
到了周五，即今天，和CTO交流时，老实说还是有些许紧张。浑身上下会不自觉的发抖。站在阳台的阳光中之后，这才停了下来。CTO的挽留相对于CEO来说，更为理性一些。首先是肯定了我做的一些贡献，表达了对我的欣赏，后续又说了一些未来工作的迁移方向，以及自己当初工作的一点经历。
必须得承认的是，我确实是被CTO的话语所打动。作为技术负责人，他对于我们所在做的事情，以及方向有很好的把握。对比CEO能描述出一个更为具体的发展计划、前景展望。在这一点上，是更让我心动的。
但是还是需要继续保持坚定的离职的态度。写这篇post，其实也是方便我对此进行梳理：
 虽然离职是周一提出来的，但是离职的想法是一直在的，最终还是要离开的。 读书已然势在必行。虽然我会担心疫情的影响，但是总体看法是乐观的。 公司的发展我认为前景无限，但是我对我自己未来的发展也抱有相对较高的期望。 公司的职位让我感觉到成长瓶颈。 其他人离职之后的发展也是不错的。  具体时间线上，准备下周去公司交接，下下周回家，之后通过网络完成工作的收尾。
此次一别，想必是以后无法碰到现在的老板和同事了。大家都加油吧。</description>
    </item>
    
    <item>
      <title>发烧带来的心态变化</title>
      <link>https://yuukidach.github.io/p/%E5%8F%91%E7%83%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BF%83%E6%80%81%E5%8F%98%E5%8C%96/</link>
      <pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E5%8F%91%E7%83%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BF%83%E6%80%81%E5%8F%98%E5%8C%96/</guid>
      <description>大概是在1月初的时候，我从隔壁工位的同事听说武汉出现了「不明原因的肺炎」。当时还不以为意，直到1月20日晚，准备回家过年的前一天，新闻上报道有肺炎扩散的趋势，自己这才开始重视起来。于是一向不喜欢戴口罩的我，在21日带着双层口罩出了门，乘地铁至火车站，后乘高铁回家。期间，在地铁上遇到的人，偶有一两个是佩戴了口罩的，其余人似乎都没受到肺炎相关新闻的影响。及至高铁，佩戴口罩的人稍多，但是大部分在列车发动一段时间后都摘了口罩，我自己亦是如此。只有邻座隔壁两人是除了吃午饭之外，始终保持佩戴的。见他们如此，我在午饭后也还是把口罩又重新戴了起来。
之后的事情就和网上大部分人的情况一样了。在1月22日，也就是法定节假日开始的这天，大部分年轻人已经意识到肺炎的严重性，口罩已经成为大家出门必备的物品了，而上年纪的人往往却并不太在意。我在家也不断提醒父母做好防护，并囤积好足够的口粮，建议他们不去参加大型的集会。陪他们去菜市场的时候，整个市场我所发现的佩戴口罩的人，也仅仅只有我一个。
在24日除夕过去之后，随着各项大型集会被取消，父母的防护意识开始被竖立起来，甚至一度比我更为紧张。
2月2日，在经过了一段时间的假期延长后，我按照公司要求回到北京。
在北京的头三周（大概），我一直在居家办公，偶尔会去公司拿点东西。每次出去都是心惊胆战，回来以后把出门的衣服全部脱下、清洗。
2月末3月初，一直到现在，我们变成了现场办公，上班时间11AM - 4PM 。这段时间也是国内疫情开始缓和期间。这段时间我通常都是10点多抵达公司，尔后4-5点下班。但是公司的同事都去得特别早，还是和之前一样9点到，让我有些许的尴尬和不解。尴尬在于，每次我去的时候大家基本都到了，不解在于，大家在早高峰上班，难道已经不担心肺炎的事情了吗。关于这段时间北京的交通，就我自己的经历，车流和人流都是逐渐增加的，最开始一辆公交车可能载0-3人，现在已经有人没有座位了，若是按照正常时间上下班，还会堵车。交通密集程度大致有平常的百分之九十。
在上述这段期间，国外的疫情开始显现出来。先是韩国和日本，日本的数据不太正常。暂且不论，韩国在不断加强检测力度后，逐渐被控制住。随后是伊朗，接着再是欧洲诸国，从意大利开始，疫情变得不可收拾，感染人数不断上升。现如今，美国报道出来的感染人数已经30万有余，实在是令人担忧。也正是如此，国内的疫情防控已经转变为防控境外输入了。北京作为首都，重要的交通枢纽，面临巨大的防控压力。这段时间看新闻，丝毫没有结束的迹象，倒是小城市已经没有什么危险了。有些人已经不戴口罩了。
说起来，现场办公的这段时间，我对疫情的紧张程度是慢慢降低的。昨天和室友以及一个跳槽的同事聊天，他们的公司都准备在这周都准备调整回正常现场办公（我们现场办公时间比较早，是因为我们公司规模小）。正当我觉得一切都要回归正常的时候，4月5日，也就是昨天，我在下午发烧了，38.2℃。我第一时间通知了我准备回来住的室友，之后联系了医院的大夫，并把发烧的事情告诉给家里人。随后在医生的建议和室友的压力下，我在晚上8点多前往发热门诊做了核酸检测，排除了新冠肺炎感染的可能性。
在发热门诊的检测，护士会先让你测体温和血压，随后才分诊到对应的部门。测量体温期间，三个穿着防护服的医护人员推着一辆病床进来。病床上是一个老头，旁边还陪着一老太太。我第一反应害怕，立马走到角落里，担心老头有肺炎疑似症状。之后护士见状首先处理了这个病号，同样需要先挂号检测。要说如果是快速的走完这个流程，我倒是不会那么害怕。可那老太太口齿不清，还不断干扰正常流程，不愿意挂号检测。尽管一个医护人员看不下去，愿意自掏腰包出钱，老太太还是不愿意检测，坚持认为医院已经或是准备坑她的钱。在他们僵持期间，我还是完成了挂号和检测的流程。再去照CT的路上，偶然从老太太口中听到老头是「北大教数学的教授」。这让我大为震惊。联系之前她说没有就医卡，能不能拿北大的卡替代的情况，我觉得这应该是实话。但是堂堂北大教授的老伴为什么会有这种表现呢？
4月5号晚上九点多，我回到家中，和家里人开了个视频会议，提出了准备今天辞职，然后回家的想法，得到了家里人的赞同。在疫情发生之前，我是准备5月份离开北京的，后续觉得里我重回学校还有这么久，不如晚点回家，一方面多赚点钱也不亏，另一方面还能把药给打完，因此又改成了7月份回家。可是因为昨晚发烧这件事情，原本对工作内容长期积压的不满一时间涌现出来，让我觉得有借口和亲人及老板说我回家的事情了。我对家里人的说法是我担心北京的防疫，实际上让我真正不想继续干下去的根本原因，还是工作本身。而且我之前因为得去医院，已经请假一周，这次发烧我也不可能直接去公司，也还得请假一到两周，在家工作，与其如此，不如直接离职。
在写这篇杂谈的时候，已经下午6点了，我还是没能下定决心和老板或者人事提出辞职。准备晚上八点之前做完最终的决定。大概率还是离开了。最让我纠结的，除开打药本身的影响外，还有就是公司的工作，虽然我不喜欢，但是目前人手不够，没人能承接我的工作。我的离开，等于公司对应项目的暂时搁浅。
不行，还是不纠结了。和人事提出离职吧。</description>
    </item>
    
    <item>
      <title>Convert Image to ASCII Art</title>
      <link>https://yuukidach.github.io/p/convert-image-to-ascii-art/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/convert-image-to-ascii-art/</guid>
      <description>Background Image Processing Library To process a image, the easiest way is using a open source library.
Since this project is written for others. They are not familiar with the image processing and it&amp;rsquo;s to hard for them to install OpenCV in their computer. So, I tried to find a light-weight image processing processing library called CImg.
To use this repo, we just need to put the header file CImg.h into our own project folder and include it in the program.</description>
    </item>
    
    <item>
      <title>对于未来的困惑</title>
      <link>https://yuukidach.github.io/p/%E5%AF%B9%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%9B%B0%E6%83%91/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E5%AF%B9%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%9B%B0%E6%83%91/</guid>
      <description>新冠病毒的爆发，让大家都闲在了家里，我也有时间好好整理一下最近的东西，顺带更新一下尘封已久的博客了。
开始之前 「我为什么要搭建这个博客呢？」
仔细想想，我好像还从来没说起过这个原因。不过那也已经是很久以前的事情了。
最直接的原因是在搜索一道UVa OJ题解的时候，翻到了一位名叫Morris的博主的博客。在浏览他博客的过程中，由于自己本身也有希望给自己的成长做个记录的想法，「不如我也自己写一个博客吧！」这样的声音也不断在我脑海中浮现。于是乎，我照着这位博主的方式，也将这个博客搭建了起来。整体风格还是模仿他来的。但是由于自己水平有限，网站的整体技术上还是存在不小的差距。
刚开始的时候，会频繁的更新这个博客。但随着时间的流逝，凡事三分钟热度的我，还是逐渐断更了，没再打理这个网站。中间偶然捡起来过几次，但最后终归是没再管过了。
毕业 现在这个时代背景下，大家都在拼了命地读书，本科生遍地走，研究生往往成为了一个工作的起点。作为本科时代学习还不错我的，自然也是抱着「最少也得读个研」的想法了。因为自己的动手能力比较强，做项目、参加比赛往往能得到不错的成绩，加上GPA高，因此我身边的人无一不觉得我是可以保研成功的，我自己也是抱有这种想法的人之一。可是当我得知我恰在保研名单后两位的时候，不想再学习、考试的感觉不断地喷薄而出，我便也没参加考研，直接找了份工作就职了。
找工作的那段时间，也算是我印象比较清晰的煎熬的时间段了。但是这份难受并不是找工作带来的，而是看着比我菜的人排名在我前面，顺顺利利地保研带来的。「我劝天公重抖擞，不拘一格降人才」这句话虽然说的夸张了，但是这大抵就是我内心最真实的想法了。
记得大四上的时候，保研已经结束了，学院开始做课程设计，我和两位已经保研的同学一块。其中一人经常问我，另外一人真是什么都不会，上课听不懂，下课代码和报告都得找我要。
 你在耍我是吗？在耍我是吧 – 徒然喜欢你 
我当时真的很像抓住他们一顿乱锤，然后提到院长面前说他看看保研的都是什么人。但是这又有什么用呢，根据学院的评判标准，综合量化低的我，还是无力改变。既然如此，那就工作吧，工作吧！工作了也就自由了！
工作 「工作了也就自由了」这是我内心的想法。我也顺利的拿了一个保底年薪300k，965的offer，这在本科生里边还是不错的。后续又因为表现突出，入职三个月后老板便给涨了一波工资。
尽管这在大部分人看来，已经安稳了，但是我内心还是充满了痛苦。
自身学历过低。公司里的同事，除了个别一两个学历一般意外，其余都是学校优于我，或者学历高于我的人。同学聚会的时候，大家也都纷纷出国深造。这让我显得十分难堪。尽管大家会说「你这个已经很好了」，但是以后呢？他们毕业之后是什么样呢？这个大环境下，本科生后续成长是很艰难的吧？
发展方向无感。我就职的公司，老板喜欢往让我们凡事都研究透彻一点。这一点我是很赞赏的，但是当你研究的事情是你不喜欢的事情时，技术上的深挖反而成为了你生活中最痛苦的一件事。到公司实习的那段时期，因为怎么都解决不掉工作中发现的一个问题，往下挖也无迹可寻，生活一下子就压抑了起来，害怕去公司，害怕面对公司里的同事。以前总觉得电视里，主人公说自己被事情整的头晕头疼，是一件夸大的修辞方式，但是亲身经历过之后，才知道，艺术确实是源于生活。曾一度以为自己要抑郁，吓得父母轮番给我打电话谈心，以至于最后不得不到北京来看望我。现在想起来，那个时候也就已经担心起未来了吧。
个人成长受限。自己来公司一段时间了，但是提升并不明显。想起来找工作面试的时候，自己关心更多的是待遇问题。犹记的有两段面试，都是在确定给offer之后，一位面试官对我说「第一份工作一定要自己喜欢，这才是最重要的」，另一位则是觉得「你应该去读研的」。但是当时的我都不以为意，现在想想，也需是他们也经历了这样一个时期，才会好意提醒我吧。
 我这个人笨，说不清楚 – 徒然喜欢你 
有些道理，或许没有经历过，就怎么也弄不懂，总觉得自己和别人不一样，等真正经历了，才会对当初的所作所为追悔莫及。
申请 有了前面的经历，自己总算是决定重返校园，申请学校。因为身体上的因素，只申请了HK和新加坡的学校。
说来也不知道我是幸运还是不幸。若是大三就开始申请，我现在大抵已经在HK读书了。但是19年的动荡，加上现在20年初的新冠病毒，让在HK的内陆学子，基本上都是在上网课了，收效甚微。而我尽管浪费了一年，倒也没有经历19年这一遭。
目前HK申请的都拿到了offer，新加坡的倒是还没出结果。如果可以的话，最后大概率还是去后者吧。
担忧 今年1月份的时候，我重新翻看了Morris的博客，发现他也许久未更新了，6号更新的一篇文章，大抵是和我相似的想法。也不知道他现在如何，工作是否顺心？有没有下定决心回去读书呢？希望他也能顺利吧。
至于自己，刚开始申请的时候，一直在犹豫申请硕士还是博士，但终究还是无法下定决心直接申请博士。最近浏览网站，看到大家谈论自己博士毕业后的生活，联系起自己的身体，突然又冒出读博的想法了。这样犹豫不觉得我，也不知道改如何是好。想到之前找老师要推荐信的时候，他建议我先读研再决定，我觉得我还是该听取一下别人的意见吧，现在先努力地不去想这件事情。
另外就是身体因素了，选择离家近的地方，也就是因为这个。目前还不知道去新加坡能否保证自己身体不出问题，还是比较烦的。
「自己究竟想去做什么呢？自己想成为一个什么样的人呢？」
这听起来像是给小朋友的问题，但是往往大人也无法搞清楚这个问题的答案啊。我们又有什么资格去问别人呢？
 我已经等得够久了，你也该告诉我了吧 – 徒然喜欢你 
自己的将来还会继续后悔下去吗？
我希望是不会的吧。</description>
    </item>
    
    <item>
      <title>Shuffling Bits</title>
      <link>https://yuukidach.github.io/p/shuffling-bits/</link>
      <pubDate>Mon, 12 Aug 2019 09:44:44 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/shuffling-bits/</guid>
      <description>Background NOTE: This article is from chapter 7.2 in Hackers&#39; Delight. I write this post because:
 To have a better understanding of the algorithm Need to apply it in a similar situation  Resources sometimes can be scarce in MCU. We may tend to use as little resources as possible and do calculations as fast as we could when the performance of MCU just barely meets our demands.
Besides when talking about calculations in MCU, many people would think about bit operation.</description>
    </item>
    
    <item>
      <title>Makefile for Projects with Subdirectories</title>
      <link>https://yuukidach.github.io/p/makefile-for-projects-with-subdirectories/</link>
      <pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/makefile-for-projects-with-subdirectories/</guid>
      <description>Abstract In order to manage our project easily, we may tend to make for help. Usually, our projects will contians many subdirectories. So writing a makefile which can always compile our projects successfully when our project add, delete or modify some sub-dirs is quite important.
Background Take my private projects kmusb for example.
It file structure is like:
. ├── README.md ├── arg_parser │ ├── arg_parser.c │ └── arg_parser.h ├── bin ├── data ├── kmusb.</description>
    </item>
    
    <item>
      <title>LPC55S69 USB 高速模式测试（一）</title>
      <link>https://yuukidach.github.io/p/lpc55s69-usb-%E9%AB%98%E9%80%9F%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E4%B8%80/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/lpc55s69-usb-%E9%AB%98%E9%80%9F%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E4%B8%80/</guid>
      <description>测试目标 配置LPC55S69 EVK所带的高速USB作为功能设备，测试其最快速率能达到多少，用于验证后续的开发。
LPC55S69配置 LPC55S69是一款基于ARM内核的双核MCU， 由两个Cortex-M33构成。其最高运行频率为100MHz。
 LPC55S69 EVK 
整个工程的准备工作如下：
 选用CPU0作为默认的控制核心 配置MAIN_CLK为96MHz（为了使用高速USB口，CPU时钟频率不得低于60MHz） 给USB HS PHY上电 USB功能设备配置  配置功能设备，需要先使能host controller的时钟，以便进行USB配置 DEV_ENABLE置1，让一个端口表现为USB设备 清除USB1_HOST位，关闭host controller，降低能耗   USB时钟配置  USB PHY配置48MHz时钟 USB PHY以及对应SRAM时钟使能    传输测试 连接方式：LPC55S69 EVK &amp;lt;&amp;mdash;&amp;mdash;-USB 2.0 HS &amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; MacBook
Corex-M33 freq: 100MHz
使用官方提供的SKD（v2.5.1），利用块传输（bulk transfer）。循环发送
while (1) { USB_DeviceCdcAcmSend(s_cdcVcom.cdcAcmHandle, USB_CDC_VCOM_BULK_IN_ENDPOINT, tmp_buf, buf_len); } tmp_buf为buffer地址，buf_len是需要传送的数据长度
使用上述方式发送数据，buf_len越长，发送USB发送速率越快，最快能到8MB/s左右，无传输错误发生。
8MB/s的速率对于HS USB来说是明显偏低的。通过调整整个工程的优化等级，可以提高速率。将优化等级调整至-O1或者以上，USB的速率可以达到21MB/s，无传输错误发生。
 测试结果 
此外，如果MCU的时钟频率降低，USB的传输速率也会相应降低，通过USB分析仪观察后，可以发现是NAK的数量变多。
结果分析 虽然最后通过增长buf_len，以及调整优化等级，可以使得高速USB口的速率在21MB/s左右。但是对于最高速率480Mbps的Hi-Speed USB来说，速率上还是有所欠缺。
采用USB分析仪进行抓包分析  抓包分析</description>
    </item>
    
    <item>
      <title>Ucount 完结之后</title>
      <link>https://yuukidach.github.io/p/ucount-%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/ucount-%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/</guid>
      <description>很久没更新博客了。从最开始饶有兴致地搭建，到现在，愈发地发现自己能说的东西变得少了，以至于都将近荒废了这个地方。
不是说自己变得慵懒，而是近来常常有种感觉，觉得自身的知识储备太匮乏了。与其用无意义地更新博客来达到一种自我满足的状态，倒不如静下心来好好的提升自我，做点有意义的事情。
写一个自己的记账软件Ucount是出于对现有记账软件各种冗余功能和广告的不满。本来寒假的时候，就应该完成记编写。但是由于自己的资料准备问题，一直到了开学都已经过去一段时间了，才真正开始着手。
最基本的功能编写了两三天的样子，后来花了十多天一直优化到现在，已经将所有的基础功能都更新完毕，也算是把自己定下的诺言给实现了。
接下来也就不会再去深究安卓了，毕竟这不是自己想要坚持的方向。要赶紧回到正轨才行，OJ的练习，Linux的学习还是要继续下去的。
稍微写了一点文字，虽然条理十分还乱，但也算是对自己完成一个目标之后的记录吧。</description>
    </item>
    
    <item>
      <title>字幕文件批量重命名脚本（二） —— Linux</title>
      <link>https://yuukidach.github.io/p/%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E8%84%9A%E6%9C%AC%E4%BA%8C-linux/</link>
      <pubDate>Sun, 12 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E8%84%9A%E6%9C%AC%E4%BA%8C-linux/</guid>
      <description>还是老样子，先上GitHub：Yuuki_Dach&amp;rsquo;s GitHub
上次自己写了一个字幕批量重命名的脚本，结果发现在处理字幕文件的时候还是存在bug（毕竟是自己一边看番，一边测试+改进，没有特意的去找测试样本）
首先是关于视频文件的查找，原来的查找方式十分简单，也没有使用正则表达式，只是粗略的查找了一下，这里利用find的功能，使得查找更加精确。
在处理字幕文件的时候，也有问题。for循环在利用find查找的时候，会把空格视为一个间断。因此，这里利用IFS，把find指令找到的文件名当作一整块来处理就行了。
另外，字幕文件的后缀名有多种，而且利用正则表达式来匹配的方式也有很多，这里就留到下次再来处理。
#! /bin/bash echo &amp;quot;Before the opration stars, please make sure you have been in the right folder!&amp;quot; while true; do read -p &amp;quot;Do you want to continue? y/n &amp;quot; yn case ${yn} in [Yy]* ) break;; [Nn]* ) exit;; * ) echo &amp;quot;Please answer yes or no.&amp;quot;;; esac done echo &amp;quot;What is the videos&#39; extension name?&amp;quot; read video_extension_name echo &amp;quot;How many episodes does it have?</description>
    </item>
    
    <item>
      <title>字幕文件批量重命名脚本 —— Linux</title>
      <link>https://yuukidach.github.io/p/%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E8%84%9A%E6%9C%AC-linux/</link>
      <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E8%84%9A%E6%9C%AC-linux/</guid>
      <description>现在更新博客的速度大大降低了，主要还是认为把自己做的题目传上来对别人和自己的帮助都不是很大。行，废话少说，我们切入正题吧。
刚刚闲来无事，想到之前看番的时候，有些另外下载的字幕会和视频名字不匹配，给观看带来不必要的麻烦，所以动手写了一个比较粗糙的字幕文件批量重命名的脚本。
代码已经上传到Yuuki_Dach&amp;rsquo;s GitHub，后续还会慢慢添加别的脚本。
其实代码并不复杂，就是先确定文件路径，然后手动输入视频文件后缀名和集数，然后开始运行就行了，这里还是把代码也贴一下，方便大家吧
#! /bin/bash  echo &amp;#34;Before the opration stars, please make sure you have been in the right folder!&amp;#34; while true; do read -p &amp;#34;Do you want to continue? y/n&amp;#34; yn case ${yn} in [Yy]* ) break;; [Nn]* ) exit;; * ) echo &amp;#34;Please answer yes or no.&amp;#34;;; esac done echo &amp;#34;What is the videos&amp;#39; extension name?&amp;#34; read video_extension_name echo &amp;#34;How many episodes does it have?&amp;#34; read total_video_episode_num echo &amp;#34;These files were renamed successfully:&amp;#34; for target_episode in `seq -w 1 ${total_video_episode_num}` do target_video=(*[^0-9]${target_episode}[^0-9]*${video_extension_name}) target_video=${target_video%${video_extension_name}} for target_srt in `find -regex &amp;#34;.</description>
    </item>
    
    <item>
      <title>驭远路上——STM32比赛作品的记录</title>
      <link>https://yuukidach.github.io/p/%E9%A9%AD%E8%BF%9C%E8%B7%AF%E4%B8%8Astm32%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E9%A9%AD%E8%BF%9C%E8%B7%AF%E4%B8%8Astm32%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E8%AE%B0%E5%BD%95/</guid>
      <description>从开始准备学校“驭远杯”比赛，到现在比赛结束，自己和自己的队伍以初赛和决赛都是第一名的成绩成功夺冠，不知不觉已经过去一段时间了。这段时间里，没有和往常一样定期的刷OJ，也少了一定的闲暇时光。基本每天都是在白天上课和写作业，晚上准备比赛这样的节奏中度过。物理实验什么的都停了好久，差点选不够了_(:зゝ∠)_
虽然忙碌，但是最后的结果还是很不错的，也证明了我们这么多天的辛苦没有白费吧。这里还是简单记录一下自己的参赛过程。
先附上自己的代码: Controller of Mars exploration
以及视频链接： Youtobe、Bilibili
比赛整体分为三个阶段，第一个阶段是对燃料块（方块）和仪器（圆球）的抓取，至少要抓取一个燃料块，抓取两个会有时间的附加分，这一阶段为手动控制。第二阶段开始为自动控制，要求小车能够对亮起的灯塔进行搜寻并触发相应的开关以关闭灯塔。触碰完四个灯塔后方可进入到下一阶段。第三阶段就是上高台了，小车需要自己调整好角度，成功登上高台，并且把仪器（球）放下。
整个驭远比赛的赛制则分为初赛、晋级赛和决赛。初赛选取4组队伍直接进入决赛，5-12名则进入晋级赛，并从中再挑选四组。
我们组在最初确定车身形状时想要让小车能够灵活的转弯，便试用了两轮驱动的圆形底盘。而后，在实际使用中，发现由于电机的不稳定性以及两轮驱动自身的缺陷，车在直线行进时会发生较大漂移。遂采用四轮驱动的方形底盘。
在团队分工时，由于队伍中有三人都可独立完成任务，直接把项目按照比赛流程划分为三个部分，以时间充裕性直接分配任务。对于重合模块，直接由前一部分提供API，如电机驱动，二三阶段的底盘驱动直接调用一阶段提供的API。
第1阶段主要问题为，机械臂的安装与控制。我们最初的方案中，机械臂的运动较为复杂，稳定性差。后在调试的过程中，受其他组的启发，将机械由4自由度简化为2自由度，使机械臂的运动更为简单稳定。
第2阶段中，我们在小车的前后各安装了一个红外复眼，以此实现了在第二场地中的任意位置对开启状态灯塔的定位。以红外复眼为判据，到达合适的位置后，分析红外复眼接受强度的数据，引导小车撞向灯塔。在实际调试过程中，发现踩灯后小车的回位稳定性较差。为解决这一问题，为小车上增加了电子陀螺仪模块，实现了较为准确的姿态控制。但只依靠红外复眼无法找到较为合适的转弯触灯位置，于是又在小车的左右各装了一个红外接收灯（连接到寻迹模块），用于转弯的判定。
当靠近2区域进出口的灯塔亮起时，小车会因过于靠近进出口而卡住，或回位时无法检测到黑线（黑线长度限制）。便在前后加装灰度传感器，用以避免小车转弯时过于靠近进出口。至此，2阶段完美完成。
第3阶段相对来说是比较简单的，在使用电子陀螺仪之前，我们在小车的正前方对称安装了3个不同朝向的超声波测距模块，以超声测距为主要依据，最终以非网格路径登上高台。然而，这样做的话，依靠超声测距调整小车时会消耗过多的时间，而且稳定性也欠佳。使用电子陀螺仪后，第3阶段的方案也随之改变。路径由不规则的，变为每次只转90度的网格路径，用陀螺仪来精确控制转角，3个超声测距也精简为1个用于辅助。这样虽然看似路径变长了，基本不需要复杂的调整，更加的稳定简洁。
比赛过程中也看到了很多新奇的创意，比如直接用空心杯来吸取泡沫，利用胶带直接粘（这个看起来很低端但是确实高效啊！只是物快放置的时候容易GG）等等。同时也见识了一些奇妙的状况，包括灯塔被“巨型”车体怼坏（想想都可怕= =）、成功冲上对方高地之类的。
嘛，就这么多吧。毕竟还在考期…… </description>
    </item>
    
    <item>
      <title>Ubuntu r8168模块编译错误的解决办法</title>
      <link>https://yuukidach.github.io/p/ubuntu-r8168%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Sat, 15 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/ubuntu-r8168%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>更新了Ubuntu 16.10之后，发现有线连接模块消失了，于是又和以前一样对r8168进行编译安装。具体的方法请参考我的另一篇文章: Ubuntu以太网已断开的解决办法
结果发现在 &amp;lsquo;make clean modules&amp;rsquo; 这一步居然出错了。错误信息如下：
/home/user/download/r8168-8.042.00/src/r8168_n.c: In function ‘rtl8168_init_one’: /home/user/download/r8168-8.042.00/src/r8168_n.c:22799:28: error: ‘struct net_device’ has no member named ‘gso_min_segs’; did you mean ‘gso_max_segs’? dev-&amp;gt;gso_min_segs = NIC_MIN_PHYS_BUF_COUNT; ^~ /home/yuukidach/下载/r8168-8.042.00/src/r8168_n.c:22807:28: error: ‘struct net_device’ has no member named ‘gso_min_segs’; did you mean ‘gso_max_segs’? dev-&amp;gt;gso_min_segs = NIC_MIN_PHYS_BUF_COUNT; ^~ /home/user/download/r8168-8.042.00/src/r8168_n.c: In function ‘rtl8168_start_xmit’: /home/user/download/r8168-8.042.00/src/r8168_n.c:24969:12: error: ‘struct net_device’ has no member named ‘trans_start’; did you mean ‘mem_start’? dev-&amp;gt;trans_start = jiffies; 其实这个错误是因为r8168的版本和Ubuntu版本不配对导致的，只要去官网下载新的r8168的版本就行了。</description>
    </item>
    
    <item>
      <title>UVa OJ 1220 - Party at Hali-Bula</title>
      <link>https://yuukidach.github.io/p/uva-oj-1220-party-at-hali-bula/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1220-party-at-hali-bula/</guid>
      <description>Problem Here is the: problem link
Solution 这道题目一开始没有用f[][]来标记是否重复，导致WA了一次，后来就加上去了。另外，在处理人名时，虽然实例输入里，上司和下属名字出现是有先后的，但是提交之后，系统的测试数据貌似不一定是这样，所以要先判断是否出现，没出现就用cnt加1再赋值
递归的思路还是不难的，选了上司，那么直属员工就不选，用d[][0]表示不选;没选的话就可以选直属员工，也可以不选，分别是d[][1]和d[][0]
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; #define G sons[b][i] const int maxn = 205; int n, res, yn, d[maxn][2], f[maxn][2]; char c1[maxn], c2[maxn]; map&amp;lt;string, int&amp;gt; p; vector&amp;lt;int&amp;gt; sons[maxn]; int dp(int b,int y) { int&amp;amp; ans = d[b][y]; if (ans != -1) return ans; int k = sons[b].size(); if(!k) {f[b][y] = 1; return ans = y;} int mark = 1; if(y) { for(int i = 0; i &amp;lt; k; ++i) { ans += dp(G,0); if(!</description>
    </item>
    
    <item>
      <title>UVa OJ 12186 - Another Crisis</title>
      <link>https://yuukidach.github.io/p/uva-oj-12186-another-crisis/</link>
      <pubDate>Thu, 29 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12186-another-crisis/</guid>
      <description>Problem A couple of years ago, a new world wide crisis started, leaving many people with economical problems. Some workers of a particular company are trying to ask for an increase in their salaries.
The company has a strict hierarchy, in which each employee has exactly one direct boss, with the exception of the owner of the company that has no boss. Employees that are not bosses of any other employee are called workers.</description>
    </item>
    
    <item>
      <title>UVa OJ 1331 - Minimax Triangulation</title>
      <link>https://yuukidach.github.io/p/uva-oj-1331-minimax-triangulation/</link>
      <pubDate>Thu, 29 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1331-minimax-triangulation/</guid>
      <description>Problem Here is the: problem link
Solution 这道题目一开始用递归做，但是时间比较长，于是花了比较长的时间去想应该怎么才能转化成递推
这道题目用d[i][j]来表示从i点切割到j点中所含的面积最大的三角形中，最小的那个
这里用了三个循环，第一层是确定分割时跨越的点数，第二层是起点，第三层就是起点和终点中任意取一点分割。同时还要注意分割时会不会有点卡在中间导致实际上不能被分割的情况
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;iomanip&amp;gt;using namespace std; const int maxn = 55; int n, cas; double x[maxn], y[maxn], d[maxn][maxn]; double cntArea(int a, int b, int c) { return fabs((x[b]-x[a])*(y[c]-y[a])-(y[b]-y[a])*(x[c]-x[a]))/2; } bool isOK(int x,int y, int z) { double s = cntArea(x, y, z); for (int i = 0; i &amp;lt; n; ++i) { if (i == x || i == y || i ==z) continue; double tmp = cntArea(x,y,i)+cntArea(x,z,i)+cntArea(y,z,i); if (fabs(s-tmp) &amp;lt; 1e-6) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>UVa OJ 10003 - Cutting Sticks</title>
      <link>https://yuukidach.github.io/p/uva-oj-10003-cutting-sticks/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-10003-cutting-sticks/</guid>
      <description>Problem You have to cut a wood stick into pieces. The most affordable company, The Analog Cutting Machinery, Inc. (ACM), charges money according to the length of the stick being cut. Their procedure of work requires that they only make one cut at a time.
It is easy to notice that different selections in the order of cutting can led to different prices. For example, consider a stick of length 10 meters that has to be cut at 2, 4 and 7 meters from one end.</description>
    </item>
    
    <item>
      <title>UVa OJ 1625 - Color Length</title>
      <link>https://yuukidach.github.io/p/uva-oj-1625-color-length/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1625-color-length/</guid>
      <description>Problem Here is the prolem link
Solution 这道题目要先处理好每个颜色的起止位置，不然会很不方便。用数组d[i][j]表示已经插入了第一个字符串的i个，第二个字符串的j个字母。递推的时候，只要发现还有字母没有用完，就加1
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; const int maxn = 5002; char n[maxn], m[maxn]; int cas, l1, l2; int begs[2][26], endz[2][26], d[maxn][maxn]; void findLetter(char a[], int l, int o) { for (int i = 1; i &amp;lt;= l; ++i) { if (!endz[o][a[i]-&amp;#39;A&amp;#39;]) begs[o][a[i]-&amp;#39;A&amp;#39;] = i; endz[o][a[i]-&amp;#39;A&amp;#39;] = i; } } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; cas; while(cas--) { cin &amp;gt;&amp;gt; n+1 &amp;gt;&amp;gt; m+1; n[0] = m[0] = 0; memset(begs, 0x3f, sizeof(begs)); memset(endz, 0, sizeof(endz)); l1 = strlen(n+1); l2 = strlen(m+1); findLetter(n, l1, 0); findLetter(m, l2, 1); for (int i = 0; i &amp;lt;= l1; ++i) { for (int j = 0; j &amp;lt;= l2; ++j) { int num = 0, ans = 0x3f3f3f3f; for (int k = 0; k &amp;lt; 26; ++k) if ((i &amp;gt;= begs[0][k] || j &amp;gt;= begs[1][k]) &amp;amp;&amp;amp; (i &amp;lt; endz[0][k] || j &amp;lt; endz[1][k])) ++num; if (i) ans = min(d[i-1][j], ans); if (j) ans = min(ans, d[i][j-1]); d[i][j] = (ans==0x3f3f3f3f?</description>
    </item>
    
    <item>
      <title>UVa OJ 11400 - Lighting System Design</title>
      <link>https://yuukidach.github.io/p/uva-oj-11400-lighting-system-design/</link>
      <pubDate>Sun, 25 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11400-lighting-system-design/</guid>
      <description>Problem You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current.</description>
    </item>
    
    <item>
      <title>UVa OJ 11584 - Partitioning by Palindromes</title>
      <link>https://yuukidach.github.io/p/uva-oj-11584-partitioning-by-palindromes/</link>
      <pubDate>Sun, 25 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11584-partitioning-by-palindromes/</guid>
      <description>Problem Here is the: link
Solution 先对字符串进行预处理，把回文字符串的长度全部记录下来，然后用DP对回文字符串的个数进行处理。最小个数=min(之前已经处理过的长度所含回文字符串的最小值+未处理的长度所含回文字符数的最小值)
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; const int maxn = 1005; char s[maxn]; int d[maxn], idx[maxn][maxn], cas; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; cas; while(cas--) { cin &amp;gt;&amp;gt; s+1; int n = strlen(s+1); memset(d, 0x3f, sizeof(d)); d[0] = 0; for (int i = 1; i &amp;lt;= n; ++i) { idx[i][i] = 1; for (int j = i+1; j &amp;lt;= n; ++j) { bool isOK = false; for (int k = 0; k &amp;lt; (j-i+1&amp;gt;&amp;gt;1); ++k) if (s[i+k] !</description>
    </item>
    
    <item>
      <title>UVa OJ 116 - Unidirectional TSP</title>
      <link>https://yuukidach.github.io/p/uva-oj-116-unidirectional-tsp/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-116-unidirectional-tsp/</guid>
      <description>Problem Here is the: problem link
Solutions 这道题目不难，但是要注意一下输出的格式，我因为输出格式的问题反复提交了好几次
我们用dp[i][j]来表示(i,j)距离最后一列的距离。为了节省时间，用了一个Next[]数组来保存向右走的路径，避免反复取余造成的时间上的浪费。
还有，记得不要用next和end，是关键字 =_=
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;using namespace std; int r, c, start, End; int Next[12]; int block[12][102], idx[12][102]; long dp[12][102]; int main(){ ios::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  while(cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c) { memset(idx, 0, sizeof(idx)); memset(dp, 0, sizeof(dp)); for (int i = 1; i &amp;lt;= r; ++i) Next[i] = i; Next[r+1] = 1; Next[0] = r; for (int i = 1; i &amp;lt;= r; ++i) for (int j = 1; j &amp;lt;= c; ++j) cin &amp;gt;&amp;gt; block[i][j]; for (int j = c; j &amp;gt; 0; --j) { for (int i = 1; i &amp;lt;= r; ++i) { long tmp = 0x3f3f3f3f3f3f; for (int k = -1; k &amp;lt; 2; ++k) { long a = dp[Next[i+k]][j+1]+block[i][j]; if (a &amp;lt; tmp) { tmp = dp[i][j] = a; idx[i][j] = Next[i+k]; } else if (a == tmp) idx[i][j] = min(idx[i][j], Next[i+k]); } } } start = 1; long tmp, minh = dp[1][1]; for (int i = 2; i &amp;lt;= r; ++i) { tmp = dp[i][1]; if (tmp &amp;lt; minh) { start = i; minh = tmp; } } End = start; for(int j = 1; j &amp;lt; c; ++j) { cout &amp;lt;&amp;lt; End &amp;lt;&amp;lt; &amp;#39; &amp;#39;; End = idx[End][j]; } cout &amp;lt;&amp;lt; End &amp;lt;&amp;lt; &amp;#39;\n&amp;#39; &amp;lt;&amp;lt; dp[start][1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } </description>
    </item>
    
    <item>
      <title>UVa OJ 12563 - Jin Ge Jin Qu hao</title>
      <link>https://yuukidach.github.io/p/uva-oj-12563-jin-ge-jin-qu-hao/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12563-jin-ge-jin-qu-hao/</guid>
      <description>Problem Here is the: link
Solution 这道题目一开始用时间作为一个大循环去进行递推，但是发现并不是很好判断歌曲是否有唱过，所以后来还是采用歌曲作为大循环，再以时间为小循环。不过记得要留出1s来给《劲歌金曲》
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; int T, n, t, cas, ans; int song[51], dp[9001]; long long lis[9001]; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; T; while(T--) { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; t; memset(dp, 0x8f, sizeof(dp)); dp[0] = 0; ans = t-1; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; song[i]; for (int i = 0; i &amp;lt; n; ++i) for (int j = t-1; j &amp;gt;= song[i]; --j) dp[j] = max(dp[j], dp[j-song[i]]+1); for (int i = t-1; i &amp;gt;=0; --i) ans = dp[i]&amp;gt;dp[ans] ?</description>
    </item>
    
    <item>
      <title>UVa OJ 1347 - Tour</title>
      <link>https://yuukidach.github.io/p/uva-oj-1347-tour/</link>
      <pubDate>Fri, 23 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1347-tour/</guid>
      <description>Problem John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi = &amp;lt; xi, yi &amp;gt; . John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point.</description>
    </item>
    
    <item>
      <title>std::ios_base::sync_with_stdio()</title>
      <link>https://yuukidach.github.io/p/stdios_basesync_with_stdio/</link>
      <pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/stdios_basesync_with_stdio/</guid>
      <description>std::ios_base::sync_with_stdio() 今天在做OJ的时候意外地发现printf和cout的输出顺序和代码顺序不一样，如下
printf(&amp;#34;Case Number %d: &amp;#34;, ++cas); if(takeTime[0][1] &amp;gt;= 0x3f3f3f3f) cout &amp;lt;&amp;lt; &amp;#34;impossible\n&amp;#34;; else cout &amp;lt;&amp;lt; takeTime[0][1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 得到的输出却是
impossible impossible impossible Case Number 1: Case Number 2: Case Number 3: 后来仔细地看了看，才发现问题是出在ios_base::sync_with_stdio()这个函数上。
这个函数当我们填入false的值时，相当于把C和C++的输入输出流解绑了，那么cout就能够拥有自己的缓冲区。如果我们去掉解绑的话，那么我们就会看到结果变得和我们预想的是一样了。
Case Number 1: impossible Case Number 2: impossible Case Number 3: impossible 所以将C++和C的输入输出流同步，是一种比较安全的方式，不要滥用ios_base::sync_with_stdio()
cin.tie() 还有一个值得一提的就是cin.tie().
和sync_with_sdtio类似，cin.tie()也是为了让输入输出变得比较安全的方式。当我们填入NULL或者0解绑之后，对于
cout &amp;lt;&amp;lt; &amp;#34;Enter name:&amp;#34;; cin &amp;gt;&amp;gt; name; 就会发现，是先输入，再输出&amp;rsquo;Enter name:&#39;
这是因为解绑了输入输出之后cout需要在缓冲区写入之后才能执行
参考  Significance of ios_base::sync_with_stdio(false); cin.tie(NULL)  </description>
    </item>
    
    <item>
      <title>UVa OJ 437 - The Tower of Babylon</title>
      <link>https://yuukidach.github.io/p/uva-oj-437-the-tower-of-babylon/</link>
      <pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-437-the-tower-of-babylon/</guid>
      <description>Problem The babylonians had n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.
They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block.</description>
    </item>
    
    <item>
      <title>UVa OJ 714 - Copying Books</title>
      <link>https://yuukidach.github.io/p/uva-oj-714-copying-books/</link>
      <pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-714-copying-books/</guid>
      <description>Problem Here is the Problem Link
Solution 在车站有三种选择：1.等；2.向右走 3.向左走
我们从约定的地点和约定的时间倒回来考虑，如果能够在0（初始时刻）回到车站1,就表示能够完成。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;using namespace std; int n, T, m1, m2, cas;; int t[55], d[255], e[255]; int fromRight[205][55], fromLeft[205][55], takeTime[205][55]; void init() { memset(fromLeft, 0, sizeof(fromLeft )); memset(fromRight, 0, sizeof(fromRight)); cin &amp;gt;&amp;gt; T; for (int i = 1; i &amp;lt; n ; ++i) cin &amp;gt;&amp;gt; t[i]; cin &amp;gt;&amp;gt; m1; for (int i = 1; i &amp;lt;= m1; ++i) { cin &amp;gt;&amp;gt; d[i]; int tmp = d[i]; fromLeft[tmp][1] = 1; for (int j = 1; j &amp;lt; n; ++j) { tmp += t[j]; if (tmp &amp;lt;= T) fromLeft[tmp][j+1] = 1; else break; } } cin &amp;gt;&amp;gt; m2; for (int i = 1; i &amp;lt;= m2; ++i) { cin &amp;gt;&amp;gt; e[i]; int tmp = e[i]; fromRight[tmp][n] = 1; for (int j = n-1; j &amp;gt; 1; --j) { tmp += t[j]; if (tmp &amp;lt;= T) fromRight[tmp][j] = 1; else break; } } memset(takeTime, 0x3f, sizeof(takeTime)); takeTime[T][n] = 0; } int main() { ios_base::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>UVa OJ 12265 - Selling Land</title>
      <link>https://yuukidach.github.io/p/uva-oj-12265-selling-land/</link>
      <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12265-selling-land/</guid>
      <description>Problem 输入一个n*m(1≤n,m≤1000)矩阵,每个格子可能是空地,也可能是沼泽。对于每个空地格子,求出以它为右下角的空矩形的最大周长,然后统计每个周长出现了多少次。
Input On the first line a positive integer: the number of test cases, at most 100. After that per test case:
 One line with two integers n and m (1 ≤ n, m ≤ 1000): the dimensions of Per’s parcel. n lines, each with m characters. Each character is either ‘#’ or ‘.’. The j-th character on the i-th line is a ‘#’ if position (i, j) is a swamp, and ‘.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-11 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-11-solution/</link>
      <pubDate>Tue, 20 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-11-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这个题目感觉就很玄乎了，就只给我们一张图片，网页源码里空空如也
这里实际上是把一张图片拆分成两张来看。
我尝试了不同的奇偶拆分方式，最终还是选定了X轴和Y轴相加的方式来判断奇偶
from io import BytesIO from PIL import Image __author__ = &amp;#39;Yuuki_Dach&amp;#39; img = Image.open(&amp;#39;cave.jpg&amp;#39;) width, height = img.size even = Image.new(&amp;#39;RGB&amp;#39;, (width &amp;gt;&amp;gt; 1, height &amp;gt;&amp;gt; 1)) odd = Image.new(&amp;#39;RGB&amp;#39;, (width &amp;gt;&amp;gt; 1, height &amp;gt;&amp;gt; 1)) for i in range(width): for j in range(height): imgPixel = img.getpixel((i, j)) if (i + j) &amp;amp; 1 == 1: odd.putpixel((i &amp;gt;&amp;gt; 1, j &amp;gt;&amp;gt; 1), imgPixel) else: even.</description>
    </item>
    
    <item>
      <title>UVa OJ 1442 - Cav</title>
      <link>https://yuukidach.github.io/p/uva-oj-1442-cav/</link>
      <pubDate>Tue, 20 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1442-cav/</guid>
      <description>Problem Link: 1442 - Cav
Solution Use greedy algorithm to deal with this problem.
Adjust the height of ceiling to fit the requirements.
Here is the code:
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;using namespace std; const int maxn = 1e6+5; int cas, n, cnt; int ceiling[maxn], floor[maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; cas; while(cas--) { cnt = 0; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; floor[i]; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; ceiling[i]; int tmp = maxn; for (int i = 0; i &amp;lt; n; ++i) { tmp = min(tmp, ceiling[i]); tmp = max(tmp, floor[i]); ceiling[i] = tmp; } tmp = maxn; for (int i = n-1; i &amp;gt; -1; --i) { tmp = min(tmp, ceiling[i]); tmp = max(tmp, floor[i]); ceiling[i] = tmp; cnt += ceiling[i] - floor[i]; } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } </description>
    </item>
    
    <item>
      <title>The Python Challenge Level 9-10 Solutions</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-9-10-solutions/</link>
      <pubDate>Mon, 19 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-9-10-solutions/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
Level 9 第九关树的图片其实是一个提示，就是要我把点一个个的连起来，而这个点是由网页源代码里注释的first和second部分给出的，我直接把两个部分的坐标提取到一起，能够得到一个牛的图片
import requests import re from PIL import Image, ImageDraw webUrl = &amp;#39;http://www.pythonchallenge.com/pc/return/good.html&amp;#39; webContent = requests.get(webUrl, auth=(&amp;#39;huge&amp;#39;,&amp;#39;file&amp;#39;)).text print(webContent) pattern = re.compile(r&amp;#34;(\d{2,3})&amp;#34;) nums = re.findall(pattern, webContent) nums = list(map(int,nums)) nums.remove(nums[0]) nums.remove(nums[0]) print(nums) img = Image.new(&amp;#39;RGB&amp;#39;, (800,800)) draw = ImageDraw.Draw(img) draw.polygon(nums, &amp;#39;white&amp;#39;) img.show() 这里最先发应的是&amp;rsquo;cow&amp;rsquo;这个单词，输入后提示我们是公的。于是再输入&amp;rsquo;ox&#39;，结果还是不对。输入&amp;rsquo;bull&amp;rsquo;就对了
Level 10 这一关简单明了，就是找规律（然而渣渣的我还是找了很久）
可以发现，后一个数实际上是前一个数的读法，比如
a[0] = 1 a[1] = 1个1 # 11 a[2] = 2个1 # 21 # 以此类推 a, sub = &amp;#39;1&amp;#39;, &amp;#39;&amp;#39; for i in range(30): j = k = 0 while j &amp;lt; len(a): while k &amp;lt; len(a) and a[k] == a[j]: k += 1 sub += str(k-j) + a[j] j = k a, sub = sub, &amp;#39;&amp;#39; print(len(a)) 最后结果是5808</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-7 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-7-solution/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-7-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这道题目网页源代码里没有什么别的提示，而图片中有个条形码类似物，那么就需要我们对图片进行处理了。先想办法把条形码读出来,并且转换成可读的文字
#! /usr/bin/env python3 # -*- coding: utf-8 -*- from PIL import Image from io import BytesIO import requests imgUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/oxygen.png&amp;#39; img = Image.open(BytesIO(requests.get(imgUrl).content)) for i in range(img.width): midPixel = img.getpixel((i,img.height&amp;gt;&amp;gt;1)) print(midPixel) 得到结果以后我们可以发现，条形码中没一条的宽度是7个像素，所以我们可以再处理一下，把相同的条形码rgb值取一个即可。另外还要注意的是，条形码没有覆盖全部的图片，最后无序的rgb值需要删掉，所以改进一下代码
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from PIL import Image from io import BytesIO import requests imgUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/oxygen.png&amp;#39; img = Image.open(BytesIO(requests.get(imgUrl).content)) midPixel = [img.getpixel((i,img.height&amp;gt;&amp;gt;1)) for i in range(0,img.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-8 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-8-solution/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-8-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这道题目消耗了我相当长的一段时间，让我对str和byte也有了一个新的认识。
首先还是老样子，进入网页源代码，看看里面有什么
首先引入眼帘的是一大串坐标代码，加上第七题的做法，很容易让人产生误会。我也试着去把他门转换了一下，发现并没有什么用处，然后就把目光集中在了里面的链接上，点了一下，需要用户名和密码，随便输入了123,并没有什么效果
再看看源代码底部有&amp;rsquo;un&amp;rsquo;和&amp;rsquo;pw&#39;，刚好两个，而且和&amp;rsquo;user name&#39; &amp;lsquo;password&amp;rsquo;相对应。 但是这两串字符又有什么意义呢？
我查了一下，发现这实际上是经bz2压缩后的信息，于是开始编写程序解码
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &#39;Yuuki_Dach&#39; import bz2 un = b&amp;quot;BZh91AY&amp;amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&amp;lt;]\xc9\x14\xe1BA\x06\xbe\x084&amp;quot; pw = b&amp;quot;BZh91AY&amp;amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&amp;lt;]\xc9\x14\xe1BBP\x91\xf08&amp;quot; print(bz2.decompress(un)) print(bz2.decompress(pw)) 得到用户名和密码就能进入下一关了</description>
    </item>
    
    <item>
      <title>The Python Challenge Level 0-1 Solutions</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-0-1-solutions/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-0-1-solutions/</guid>
      <description>前两天听说了有The Python Chanllenge这么一个游戏，于是自己也想来尝试一下。感觉还是一个挺有意思的。
附上我在Github上存放的代码仓库: The Python Challenge
Challenge 0 第0关只是一个让你大概清楚怎么玩的一个关卡，只要按照图片上的意思，计算2的38次方即可。这个就无所谓是用Python还是别的什么方式来计算了，能够得到结果就行，所以代码就不贴出来了。
算出结果之后，将结果复制到网页的url栏,将.html前面的单词替换掉就好
Challenge 1 根据图片给的提示我们可以发现，从K到M，O到Q，以及E到G，都是把单词给推后了两个。所以，我们只需要把他底下给我们的一大串字符串给统一推后两个字母就行了。另外要注意y要对应a,z则对应b。下面是我的初版代码:
#! /usr/bin/env python3 # -*- coding: utf-8 -*- code = (&amp;#34;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dm&amp;#34; &amp;#34;p. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&amp;#39;q ufw rfgq rcvr gq &amp;#34; &amp;#34;qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc&amp;#34; &amp;#34; spj.&amp;#34;) addr = &amp;#34;&amp;#34; for alpha in code: if alpha!</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-2 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-2-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-2-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
The Python Challenge第二关给了我们一张书的图片，但是十分模糊的，什么都看不清，这个时候，我们看看它给我们的文字提示是
 MAYBE they are in the page source.
 这个时候我们点击鼠标右键，查看网页的源代码，会发现，果然有一大长条乱七八糟的符号。不难猜到，我们所需要的下一关的url就藏在这堆符号里。于是我们用简单的爬虫爬取网页代码，然后利用正则表达式来捕捉我们需要的字母。
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from urllib import request import re pyUrl = &amp;#34;http://www.pythonchallenge.com/pc/def/ocr.html&amp;#34; req = request.Request(pyUrl) resq = request.urlopen(req) content = resq.read() book = re.compile(b&amp;#34;&amp;lt;!--(.*?)--&amp;gt;&amp;#34;, re.S) bookContents = re.findall(book, content) wordsCmpl = re.compile(b&amp;#34;([ a-zA-Z])&amp;#34;, re.S) for bookContent in bookContents: words = re.findall(wordsCmpl, bookContent) code = &amp;#34;&amp;#34; for word in words: code += word.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-3 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-3-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-3-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这里按照题目意思，利用正则匹配，找到恰好分别被三个大写字母包在左右的小写字母就好
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from urllib import request import re pyUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/equality.html&amp;#39; req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() pattern = re.compile(b&amp;#39;[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]&amp;#39;, re.S) contents = re.findall(pattern, urlContent) code = &amp;#39;&amp;#39; for content in contents: code += content.decode(&amp;#34;ascii&amp;#34;) print(code) 得到linkedlist，输入到url中，得到提示
linkedlist.php 把&#39;.html&amp;rsquo;的后缀改成&#39;.php&amp;rsquo;就通关了</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-4 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-4-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-4-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
依然是先查看网页源代码。发现有个链接&#39;&amp;hellip;nothing=12345&#39;
点进去之后发现又给我们一个数字，引导我们去下一个链接，于是可以知道，只要链接爬到了终点，那么就会出现别的提示信息
果然，爬到终点之后，提示我们除以二，继续爬，所以只要把代码改个数字就好，我的代码如下：
#!/usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &#39;Yuuki_Dach&#39; from urllib import request import re mainUrl = &#39;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=&#39; subUrl = &#39;8022&#39; # first try is &#39;12345&#39; subUrl2 = &#39;&#39; i = 400 while subUrl != subUrl2: subUrl2 = subUrl pyUrl = mainUrl + subUrl req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() pattern = re.compile(b&#39;\d+&#39;, re.S) contents = re.findall(pattern, urlContent) for content in contents: subUrl = content.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-5 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-5-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-5-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
先看提示:
pronounce it 再看看网页源码，&amp;lsquo;peak hell&amp;rsquo;能代表什么？
我一开始以为是&amp;rsquo;pick&amp;rsquo;什么东西，点开&amp;rsquo;banner.p&amp;rsquo;之后没发现什么规律，于是先google了一下&amp;rsquo;peak hell&amp;rsquo;，发现了Python有pickle这么一个模块，那么就必然和这个有关系了。
pickle这个模块是python用来保存数据的，主要是loads和dumps方法的运用（这两个是对内存进行操作，如果要对硬盘进行操作，形成文件等形式，就是用load和dump），一个是读，一个是写，这里因为是直接从网页中获取数据，所以只要读就行了。
读完能发现这实际上是一个list组，再仔细点观察的话，就会注意到每一个[]中，把&#39; &amp;lsquo;和&amp;rsquo;#&amp;lsquo;后跟着的数字加起来，恰好是95。于是可以估计，这应该是利用点阵的方式来进行显示，而点阵的一行，有95个字符。这样就有了如下代码：
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from urllib import request import pickle pyUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/banner.p&amp;#39; req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() code = [] pic = pickle.loads(urlContent) for line in pic: for letter, num in line: code.append(num*letter) code.append(&amp;#39;\n&amp;#39;) print(&amp;#34;&amp;#34;.join(code)) 运行之后得到的点阵图是
 ##### ##### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ### #### ### ### ##### ### ##### ### ### #### ### ## #### ####### ## ### #### ####### #### ####### ### ### #### ### ### ##### #### ### #### ##### #### ##### #### ### ### #### ### #### #### ### ### #### #### #### #### ### #### #### ### #### #### ### #### #### #### #### ### ### #### #### #### #### ## ### #### #### #### #### #### ### #### #### #### #### ########## #### #### #### #### ############## #### #### #### #### ### #### #### #### #### #### #### #### #### #### #### #### ### #### #### #### #### #### #### ### #### #### #### ### #### #### #### #### ### #### ### ## #### #### ### #### #### #### #### #### ### ## #### ### ## #### #### ########### #### #### #### #### ### ## #### ### ###### ##### ## #### ###### ########### ##### ### ###### 大家请把终端的宽度拉大一点，不然会和我一开始一样，读不出什么东西来，并且怀疑是不是程序写错了 =_=</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-6 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-6-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-6-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这道题目开始让人很迷茫了（至少我是这样），先点开网页源码，没发现什么有价值等东西，然后又看看图片，发现右上角有个箭头，指着几个数字3，于是照着填进去了，发现没有链接，于是又跑去看源码，终于在开头发现了这个：
&amp;lt;!-- &amp;lt;-- zip --&amp;gt; 于是将&#39;.html&amp;rsquo;替换成&#39;.zip&#39;，居然下载下来了一个压缩包，点开之后会发现有一个readme.txt，再继续点开，内容如下：
welcome to my zipped list. hint1: start from 90052 hint2: answer is inside the zip 很明显，和前几题一样，就是按照90052这个数字找下去了，不过这次找的不是网页，而是文件。这里我们用zipfile这个模块来完成我们的需求
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; import zipfile import re zipFileName= &amp;#39;channel.zip&amp;#39; zipBag = zipfile.ZipFile(zipFileName) num = &amp;#39;90052&amp;#39; while True: zipContent = zipBag.read(num+&amp;#34;.txt&amp;#34;).decode(&amp;#34;utf-8&amp;#34;) print(zipContent) content = re.search(&amp;#34;(\d+)&amp;#34;, zipContent) if content == None: break num = content.group() 运行代码，会发现有以下信息：
Collect the comments.</description>
    </item>
    
    <item>
      <title>UVa OJ 1609 - Foul Play</title>
      <link>https://yuukidach.github.io/p/uva-oj-1609-foul-play/</link>
      <pubDate>Thu, 15 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1609-foul-play/</guid>
      <description>Problem n支队伍(2≤n≤1024,且n是2的整数幂)打淘汰赛,每轮都是两两配对,胜者进入下一轮。每支队伍的实力固定,并且已知每两支队伍之间的一场比赛结果。你喜欢1号队。虽然它不一定是最强的,但是它可以直接打败其他队伍中的至少一半,并且对于每支1号队不能直接打败的队伍t,总是存在一支1号队能直接打败的队伍t&amp;rsquo;使得t&amp;rsquo;能直接打败t。问:是否存在一种比赛安排,使得1号队夺冠?
Input For each test case, the input is as follows:
  One line containing the number of teams n, where n is a power of two and 2 ≤ n ≤ 1024. Teams are numbered from 1 to n, where team 1 is your favourite team.
  n lines, each containing a string of n binary digits. The k-th digit on the j-th line is ‘1’ if team j would certainly win from team k, otherwise it is ‘0’.</description>
    </item>
    
    <item>
      <title>Ubuntu下使用Python3</title>
      <link>https://yuukidach.github.io/p/ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8python3/</link>
      <pubDate>Wed, 14 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8python3/</guid>
      <description>这篇文章算是给初次在Ubuntu上使用Python编程的人一个提醒吧。
使用方法 首先我们要知道Ubuntu自带的是Python2，然而有很多人(比如我)在学习Python的时候希望使用Python3
我们先使用
sudo apt install python3 老版本Ubuntu请将 &amp;lsquo;apt&amp;rsquo; 改为 &amp;lsquo;apt-get&amp;rsquo;
安装好了Python3之后，我们想在终端中直接使用Python3，可是当我们输入 &amp;lsquo;python&amp;rsquo;之后，却发现还是Python2。这个时候其实很简单，只要在 &amp;lsquo;python&amp;rsquo;后面加个 &amp;lsquo;3&amp;rsquo; 就好，具体如下:
python3 cmd cmd 是你自己的指令。这个时候我们就是使用Python3了
Warning！！！ 不过我要说的不只是这些，而是这篇文章：在Ubuntu中安装Python3
不推荐大家采用文章里的方式
这篇文章开头写的很好，告诉我们Ubuntu很多底层采用的是Python2，当时后面居然让我们把link文件改掉。这样会导致Ubuntu的系统出现一些错误，比如安装软件失败。所以大家还是直接使用 &amp;lsquo;python3&amp;rsquo; 这个命令就好，不要自找麻烦。</description>
    </item>
    
    <item>
      <title>Ubuntu以太网已断开的解决办法</title>
      <link>https://yuukidach.github.io/p/ubuntu%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B7%B2%E6%96%AD%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/ubuntu%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B7%B2%E6%96%AD%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>有部分人在使用Ubuntu的时候可能会遇到和我一样的问题，就是以太网显示已断开，这面原因有很多，但是大多都是驱动问题。网上也有教程，亲测以后发现有些地方并不适用，这里我们就来谈谈这个问题。
我的Ubuntu版本是16.04 LTS， 有线网卡是Realtek的
装完系统以后以太网显示已断开，但是如果编辑连接的话，可以发现，其实是一直在使用的。真正原因，是网卡驱动不兼容的问题。Ubuntu自带的是r8169，而我需要的是r8168。因此，我们只需要安装上r8168就好了。
但是网上虽然有比较好的教程，但是有一些瑕疵，不通用，有人会说自己找不到r8169.ko这个文件并删除。实际上，我们应该用find指令去找我们所需要的文件的位置，而不是完全照搬那些解决方法。
下面开始谈谈解决方式：
  下载驱动并解压好
去Realtek官网下载好r8168的驱动: 下载连接
  获取root权限
  sudo su 删除r8169模块  rmmod r8169 mv /&#39;-yourFile&#39;/r8169.ko ~/r8169.ko.backup 将&#39;-yourFile&#39;替换成具体的文件路径，也就是存放了r8169.ko这个文件的路径  比如我的是
&amp;gt;/lib/modules/`4.4.0-36-generic`/kernel/drivers/net/enthernet/realtek 具体还是利用find指令自己去找   安装r8168
切换到解压完的目录执行以下指令
  make clean modules make install  添加驱动模块到内核中
先让系统知道我们的模块，然后添加到内核中
  depmod -a insmod ./src/r8168.ko 让模块在启动的时候生效  mv /initrd.img ~/initrd.img.backup mkinitramfs -o /boot/initrd.img-`uname -r` `uname -r` echo &amp;quot;r8168&amp;quot; &amp;gt;&amp;gt; /etc/modules &amp;lsquo;uname -r&amp;rsquo;是内核版本代号，就是4.4.0-36-generic这类，具体还是看自己的文件。之前在找r8169.ko的时候就会看到
最后可以用lspci -v这个指令来看看自己用的是什么驱动</description>
    </item>
    
    <item>
      <title>UVa OJ 1608 - Non-boring sequences</title>
      <link>https://yuukidach.github.io/p/uva-oj-1608-non-boring-sequences/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1608-non-boring-sequences/</guid>
      <description>Problem A sequence is called non-boring if its every connected subsequence contains a unique element, i.e. an element such that no other element of that subsequence has the same value.
Given a sequence of integers, decide whether it is non-boring.
Input The first line of the input contains the number of test cases T. The descriptions of the test cases follow:
Each test case starts with an integer n (1 ≤ n ≤ 200000) denoting the length of the sequence.</description>
    </item>
    
    <item>
      <title>UVa OJ 12174 - Shuffle</title>
      <link>https://yuukidach.github.io/p/uva-oj-12174-shuffle/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12174-shuffle/</guid>
      <description>Problem You are listening to your music collection using the shuffle function to keep the music surprising. You assume that the shuffle algorithm of your music player makes a random permutation of the songs in the playlist and plays the songs in that order until all songs have been played. Then it reshuffles and starts playing the list again.
You have a history of the songs that have been played. However, your record of the history of played songs is not complete, as you started recording songs at a certain point in time and a number of songs might already have been played.</description>
    </item>
    
    <item>
      <title>UVa OJ 1607 - Gates</title>
      <link>https://yuukidach.github.io/p/uva-oj-1607-gates/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1607-gates/</guid>
      <description>Problem 描述起来很麻烦，大家还是直接去OJ站看吧。我之后也会解释一下题目的意思
题目链接： 1607 - Gates
Input The first line of the input contains exactly one positive integer d equal to the number of data sets, 1 ≤ d ≤ 20. The data sets follow.
Each data set consists of two consecutive lines. The rst of those lines contains exactly two positive integers n and m separated by single space, 1 ≤ n ≤ 100.000, 1 ≤ m ≤ 200.000. Integer n is the number of the net inputs and integer m is the number of the gates in the net.</description>
    </item>
    
    <item>
      <title>UVa OJ 11093 - Just Finish it up</title>
      <link>https://yuukidach.github.io/p/uva-oj-11093-just-finish-it-up/</link>
      <pubDate>Mon, 05 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11093-just-finish-it-up/</guid>
      <description>Problem Along a circular track, there are N gas stations, which are numbered clockwise from 1 up to N. At station i, there are pi gallons of petrol available. To race from station i to its clockwise neighbor one need qi gallons of petrol. Consider a race where a car will start the race with an empty fuel tank. Your task is to find whether the car can complete the race from any of the stations or not.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;函数对象，Lambda，function，bind相关知识</title>
      <link>https://yuukidach.github.io/p/c-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambdafunctionbind%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/c-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambdafunctionbind%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</guid>
      <description>昨天做题时无意间得知了&amp;lt;functional&amp;gt;这个头文件，之后自己也稍微地了解了一下相关的一些知识。
内容比较多，叙述方面可能不是很详尽，大家如果看完还有不是很理解的地方，建议进文末的链接看看。
&amp;lt;functional&amp;gt;头文件 关于这个头文件，在cppreference.com中是这样定义的:
 This header is part of the function objects library and provides the standard hash function.
 这个头文件定义了许多函数对象类型和支持函数对象的功能。
函数对象 关于函数对象这里就来比较详细的讲一下，也为后面的内容做一个铺垫。
先来看看cplusplus.com中关于函数对象（Function object）的定义：
 Function objects are objects specifically designed to be used with a syntax similar to that of functions. In C++, this is achieved by defining member function operator() in their class.
 简单的说，函数对象是通过重载operator()这个操作符，利用和函数相类似的句法，实现了函数的功能。来看一个例子：
class myFunctionClass{ public: int operator()(int x){ return x; } }test; int a = test(6); 这个程序中，如果我们输出a，就会发现，a的值是6，十分简单易懂。</description>
    </item>
    
    <item>
      <title>UVa OJ 12627 - Erratic Expansion</title>
      <link>https://yuukidach.github.io/p/uva-oj-12627-erratic-expansion/</link>
      <pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12627-erratic-expansion/</guid>
      <description>Problem 这个问题要带图才能方便理解题意，这里为了节省时间，大家自己去网站看题目就好。我真是太懒了 :p
Input The first line of input is an integer T (T &amp;lt; 1000) that indicates the number of test cases. Each case contains 3 integers K, A and B. The meanings of these variables are mentioned above. K will be in the range [0, 30] and 1 ≤ A ≤ B ≤ 2K.
Output For each case, output the case number followed by the total number of red balloons in rows [A, B] after K-th hour.</description>
    </item>
    
    <item>
      <title>UVa OJ 10954 - Add All</title>
      <link>https://yuukidach.github.io/p/uva-oj-10954-add-all/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-10954-add-all/</guid>
      <description>Problem 有n（n≤5000）个数的集合S，每次可以从S中删除两个数，然后把它们的和放回集合， 直到剩下一个数。每次操作的开销等于删除的两个数之和，求最小总开销。所有数均小于 105。
Input Each test case will start with a positive number, N (2 ≤ N ≤ 5000) followed by N positive integers (all are less than 100000). Input is terminated by a case where the value of N is zero. This case should not be processed.
Output For each case print the minimum total cost of addition in a single line.
Sample Input 3 1 2 3 4 1 2 3 4 0 Sample Output 9 19 Solution 题目很简单，就是最小的两个数相加，用优先队列只要几行代码就能完成。但是我为什么还要发一篇文章呢？因为通过这道题目，我知道了一个新的头文件 &amp;lt;functional&amp;gt; .</description>
    </item>
    
    <item>
      <title>UVa OJ 714 - Copying Books</title>
      <link>https://yuukidach.github.io/p/uva-oj-714-copying-books/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-714-copying-books/</guid>
      <description>Problem 把一个包含m个正整数的序列划分成k个（1≤k≤m≤500）非空的连续子序列，使得每个正 整数恰好属于一个序列。设第i个序列的各数之和为S(i)，你的任务是让所有S(i)的最大值尽 量小。例如，序列1 2 3 2 5 4划分成3个序列的最优方案为1 2 3 | 2 5 | 4，其中S(1)、S(2)、S(3) 分别为6、7、4，最大值为7；如果划分成1 2 | 3 2 | 5 4，则最大值为9，不如刚才的好。每个 整数不超过107。如果有多解，S(1)应尽量小。如果仍然有多解，S(2)应尽量小，依此类推
Input The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers m and k, 1 ≤ k ≤ m ≤ 500.</description>
    </item>
    
    <item>
      <title>UVa OJ 1451 - Average</title>
      <link>https://yuukidach.github.io/p/uva-oj-1451-average/</link>
      <pubDate>Mon, 29 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1451-average/</guid>
      <description>Problem 给定一个长度为n的01串，选一个长度至少为L的连续子串，使得子串中数字的平均值最 大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号 为1～n，因此[1,n]就是完整的字符串。1≤n≤100000，1≤L≤1000。
例如，对于如下长度为17的序列00101011011011010，如果L=7，最大平均值为6/8（子 序列为[7,14]，其长度为8）；如果L=5，子序列[7,11]的平均值最大，为4/5。
Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers n (1 ≤ n ≤ 100, 000) and L (1 ≤ L ≤ 1, 000) which are the length of a binary sequence and a length lower bound, respectively.</description>
    </item>
    
    <item>
      <title>UVa OJ 1471 - Defense Lines</title>
      <link>https://yuukidach.github.io/p/uva-oj-1471-defense-lines/</link>
      <pubDate>Fri, 26 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1471-defense-lines/</guid>
      <description>Problem After the last war devastated your country, you - as the king of the land of Ardenia - decided it was high time to improve the defense of your capital city. A part of your fortification is a line of mage towers, starting near the city and continuing to the northern woods. Your advisors determined that the quality of the defense depended only on one factor: the length of a longest contiguous tower sequence of increasing heights.</description>
    </item>
    
    <item>
      <title>UVa OJ 11572 - Unique Snowflakes</title>
      <link>https://yuukidach.github.io/p/uva-oj-11572-unique-snowflakes/</link>
      <pubDate>Thu, 25 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11572-unique-snowflakes/</guid>
      <description>Problem 输入一个长度为n（n≤106）的序列A，找到一个尽量长的连续子序列AL～AR，使得该序 列中没有相同的元素。
Input The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing an integer n, the number of snowflakes processed by the machine. The following n lines each contain an integer (in the range 0 to 109, inclusive) uniquely identifying a snowflake. Two snowflakes are identified by the same integer if and only if they are identical.</description>
    </item>
    
    <item>
      <title>关于博客Read More按钮的改进</title>
      <link>https://yuukidach.github.io/p/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2read-more%E6%8C%89%E9%92%AE%E7%9A%84%E6%94%B9%E8%BF%9B/</link>
      <pubDate>Wed, 24 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2read-more%E6%8C%89%E9%92%AE%E7%9A%84%E6%94%B9%E8%BF%9B/</guid>
      <description>先说一点题外话
最近一段时间临近开学，要处理的事情很多，更新博客的速度也慢了下来，开学以后也大概就是这个速度了吧。
关于这个博客的建立过程，我还是想稍微再提一下。从一开始的landscape到icarus主题，再回到默认的landscape，中间还是发生了许多事情。主要的一个原因还是landscape给我们展示文章的空间更大一些，方便阅读。而且自己修改起来也比较方便。
至于主色调。因为自己经常长时间看着屏幕，所以希望能看到比较缓和一点的颜色，没有那么刺眼。因此选中了黑色。在自己改变了几处地方之后，意外的发现和 Morris&amp;rsquo;s Blog 很相似。鉴于自己在网页设计这方面基础近乎为0，后来的一些更新，或多或少都有借鉴他的一些东西，包括这里要提到的文章栏里Read More这个按钮。
 下面还是快点进入正题吧。
这个按钮是我学习jQuery的一个开端，或者说，是起因。
那么什么是jQuery呢？
 jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript.
 简单的说，jQuery就是一个JavaScript的库，和我们C++中使用&amp;quot;Algorithm&amp;quot;这个头文件是差不多的意思，是方便我们进行开发用的。利用它，我们可以用很短的代码，写出需要的结果。
我这里的Read More按钮，在写它的js文件之前，先对CSS进行了一定的更改，包括改变了首页文章评论和分享按钮的位置；给文章预览页面添加上文字渐隐的效果。</description>
    </item>
    
    <item>
      <title>从零开始的Hexo学习</title>
      <link>https://yuukidach.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84hexo%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 20 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84hexo%E5%AD%A6%E4%B9%A0/</guid>
      <description>Don’t Dissect the Frog, Build It.
 这句话在之前的一篇文章就提到过了。光是看是没有用的，要自己实践之后，才能理解一个东西，从而有所收获。
最近在一点点完善自己的博客。随着改动地程度不断加大，对于Hexo的理解就显得不够了。因此，在博客开了一个月了才来写这篇文章，也算是一种亡羊补牢吧。
layout模板  Every templates apply to layout template by default.
 Hexo的主题布局都在layout文件夹下，每个模板都是用layout.ejs作为布局。以我这里的文件为例。打开layout.ejs，里面的内容如下：
&amp;lt;%- partial(&amp;#39;_partial/head&amp;#39;) %&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;wrap&amp;#34;&amp;gt; &amp;lt;%- partial(&amp;#39;_partial/header&amp;#39;, null, {cache: !config.relative_link}) %&amp;gt; &amp;lt;div class=&amp;#34;outer&amp;#34;&amp;gt; &amp;lt;section id=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;%- body %&amp;gt;&amp;lt;/section&amp;gt; &amp;lt;% if (theme.sidebar &amp;amp;&amp;amp; theme.sidebar !== &amp;#39;bottom&amp;#39;){ %&amp;gt; &amp;lt;%- partial(&amp;#39;_partial/sidebar&amp;#39;, null, {cache: !config.relative_link}) %&amp;gt; &amp;lt;% } %&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;%- partial(&amp;#39;_partial/footer&amp;#39;, null, {cache: !config.relative_link}) %&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;%- partial(&amp;#39;_partial/mobile-nav&amp;#39;, null, {cache: !</description>
    </item>
    
    <item>
      <title>UVa OJ 1606 - Amphiphilic Carbon Molecules</title>
      <link>https://yuukidach.github.io/p/uva-oj-1606-amphiphilic-carbon-molecules/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1606-amphiphilic-carbon-molecules/</guid>
      <description>Problem 平面上有n（n≤1000）个点，每个点为白点或者黑点。现在需放置一条隔板，使得隔板一侧的白点数加上另一侧的黑点数总数最大。隔板上的点可以看作是在任意一侧。
Input 不超过10个测试情况。每种情况以一个整数N开始，代表点的个数，接着输入N行x,y,r，分别表示坐标点的x坐标，y坐标和点的颜色，其中1是黑色。输入以0结束。
Output For each test case, output a line containing a single integer, which is the maximum number of dots we count.
Sample Input 3 0 0 0 0 1 0 2 2 1 4 0 0 0 0 4 0 4 0 0 1 2 1 7 -1 0 0 1 2 1 2 3 0 2 1 1 0 3 1 1 4 0 -1 2 0 0 Sample Output 3 3 6 Solution 扫描问题。只需要以一个点为基准点，然后做线，统计两边的点的数量就行。 在做这道题的时候，只是一个小小等式的区别，导致我TLE了好多次。后来也是测试了好久，才发现了这个问题。究其原因，还是取模太耗费时间，于是我就把取模的部分做了点修改，最终成功通过。 这里我利用先排序的方式，选好基准点之后，对每个点关于基准点的角度进行排序，然后才开始真正的扫描。</description>
    </item>
    
    <item>
      <title>Get Start With HTML</title>
      <link>https://yuukidach.github.io/p/get-start-with-html/</link>
      <pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/get-start-with-html/</guid>
      <description>这些天在鼓捣博客，对界面所做的改动，也都是landscape这个主题的框架下所进行的。虽然说自由度相对于别的博客站点的自由度要高很多，但是自己没有一点网页编程知识的话，也是不能够讲网页完全设计成自己所喜欢的样子。因此在这里开一个类似于笔记本性质的文章吧，也方便我以后进行回忆。
Introduction  HTML指的是超文本标记语言 (Hyper Text Markup Language) HTML不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML使用标记标签来描述网页  Basic   HTML的链接通过&amp;lt;a&amp;gt;来进行定义
&amp;lt;a href=&amp;ldquo;url&amp;rdquo;&amp;gt;link text&amp;lt;/a&amp;gt;
  图像通过&amp;lt;img&amp;gt; &amp;lt;img src=&amp;ldquo;link&amp;rdquo; settings/&amp;gt;
在src的后面还能加上alt 表示在图片加载不出来时显示的文字信息，如：&amp;lt;img src=&amp;ldquo;link&amp;rdquo; alt=&amp;ldquo;text&amp;rdquo; settings/&amp;gt;
  Conditional comments defines some HTML tags to be executed by Internet Explorer only.
  &amp;lt;!--[if IE 8]&amp;gt; .... some HTML here .... &amp;lt;![endif]--&amp;gt; The &amp;lt;title&amp;gt; element defines the title of the document, and is required in all HTML/XHTML documents.</description>
    </item>
    
    <item>
      <title>UVa OJ 11054 - Wine trading in Gergovia</title>
      <link>https://yuukidach.github.io/p/uva-oj-11054-wine-trading-in-gergovia/</link>
      <pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11054-wine-trading-in-gergovia/</guid>
      <description>Problem As you may know from the comic “Asterix and the Chieftain’s Shield”, Gergovia consists of one street, and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simple enough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides how much wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that each inhabitant gets what he wants.</description>
    </item>
    
    <item>
      <title>UVa OJ 11134 - Fabled Rooks</title>
      <link>https://yuukidach.github.io/p/uva-oj-11134-fabled-rooks/</link>
      <pubDate>Wed, 10 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11134-fabled-rooks/</guid>
      <description>Problem  在n*n的棋盘上放n（n≤5000）个车，使得任意两个车不相互攻击，且第i个 车在一个给定的矩形Ri之内。用4个整数xli, yli, xri, yri（1≤xli≤xri≤n，1≤yli≤yri≤n）描述第i个 矩形，其中(xli,yli)是左上角坐标，(xri,yri)是右下角坐标，则第i个车的位置(x,y)必须满 足xli≤x≤xri，yli≤y≤yri。如果无解，输出IMPOSSIBLE；否则输出n行，依次为第1,2,…,n个车 的坐标。
Input The input consists of several test cases. The first line of each of them contains one integer number, n, the side of the board. n lines follow giving the rectangles where the rooks can be placed as described above. The i-th line among them gives xli, yli, xri, and yri. The input file is terminated with the integer ‘0’ on a line by itself.</description>
    </item>
    
    <item>
      <title>Way to Clean Code</title>
      <link>https://yuukidach.github.io/p/way-to-clean-code/</link>
      <pubDate>Wed, 10 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/way-to-clean-code/</guid>
      <description>——Code, without tests, is not clean. No matter how elegant it is, no matter how readable and accessible, if it hath not tests, it be unclean.
——没有测试的代码不干净。不管它有多优雅，不管有多可读、多易理解，微乎测试，其不洁亦可知也。
 这两天看了下Clean Code这本书，感觉还是有一些收获。同时也对之前自己在学习STM32所使用的库函数，有了一个更加深入的了解。嘛，下面就把看到的一些东西做个笔记吧，时不时可能会加上一点。
Basic Principles
  Runs all the tests
  Contains no duplication
  Expresses all the design ideas that are in the system
  Minimizes the number of entities such as classes, methods, functions, and the like</description>
    </item>
    
    <item>
      <title>UVa OJ 1152 - 4 Values whose Sum is 0</title>
      <link>https://yuukidach.github.io/p/uva-oj-1152-4-values-whose-sum-is-0/</link>
      <pubDate>Mon, 08 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1152-4-values-whose-sum-is-0/</guid>
      <description>Problem 给定4个n（1≤n≤4000）元素集合A, B, C, D，要求分别从中选取一个元素a, b, c, d，使得 a+b+c+d=0。问：有多少种选法？
Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.
 The first line of the input file contains the size of the lists n (this value can be as large as 4000).</description>
    </item>
    
    <item>
      <title>UVa OJ 1605 - Building for UN</title>
      <link>https://yuukidach.github.io/p/uva-oj-1605-building-for-un/</link>
      <pubDate>Sun, 07 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1605-building-for-un/</guid>
      <description>Problem  你的任务是设计一个包含若干层的联合国大楼，其中每层都是一个等大的网格。有若干 国家需要在联合国大楼里办公，你需要把每个格子分配给一个国家，使得任意两个不同的国 家都有一对相邻的格子（要么是同层中有公共边的格子，要么是相邻层的同一个格子）。你设计的大厦最多不能超过1000000个格子。
Input  输入国家的个数n（n≤50）。
Output  输出大楼的层数H、每层楼的行数W和列数L，然后是每层 楼的平面图.不同的国家用不同的大小写字母表示。
Sample Input 4 Sample Output 2 2 2 AB CC zz zz Solution  这个题目没有给定楼层限制，也没有给定国家占地的限制，那么就显得很简单了。因为只需要保证每一个国家和另外一个国家的办公室都有邻边。那么我们可以直接把第一层的每个行分给不同的国家，然后第二层的每个列也分给不同的国家，问题就解决了。下面是简单而粗糙的代码
#include &amp;lt;cstdio&amp;gt;using namespace std; int main(){ int n,contry[55]; while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) == 1){ printf(&amp;#34;%d %d %d\n&amp;#34;, 2, n, n); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j) printf(&amp;#34;%c&amp;#34;, i &amp;lt; 26 ? &amp;#39;a&amp;#39; + i : &amp;#39;A&amp;#39; + i - 26); putchar(&amp;#39;\n&amp;#39;); } putchar(&amp;#39;\n&amp;#39;); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j) printf(&amp;#34;%c&amp;#34;, j &amp;lt; 26 ?</description>
    </item>
    
    <item>
      <title>UVa OJ 120 - Stacks of Flapjacks</title>
      <link>https://yuukidach.github.io/p/uva-oj-120-stacks-of-flapjacks/</link>
      <pubDate>Sat, 06 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-120-stacks-of-flapjacks/</guid>
      <description>Problem  有一叠煎饼正在锅里。煎饼共有n（n≤30）张，每张都有一个数字，代表它的大小，如 图8-11所示。厨师每次可以选择一个数k，把从锅底开始数第k张上面的煎饼全部翻过来，即 原来在上面的煎饼现在到了下面。
 设计一种方法使得所有煎饼按照从小到大排序（最上面的煎饼最小）。输入时，各个煎 饼按照从上到下的顺序给出。
Input The input consists of a sequence of stacks of pancakes. Each stack will consist of between 1 and 30 pancakes and each pancake will have an integer diameter between 1 and 100. The input is terminated by end-of-file. Each stack is given as a single line of input with the top pancake on a stack appearing first on a line, the bottom pancake appearing last, and all pancakes separated by a space.</description>
    </item>
    
    <item>
      <title>UVa OJ 11212 - Editing a Book</title>
      <link>https://yuukidach.github.io/p/uva-oj-11212-editing-a-book/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11212-editing-a-book/</guid>
      <description>&lt;h1 id=&#34;problem&#34;&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;  你有一篇由n（2≤n≤9）个自然段组成的文章，希望将它们排列成1, 2,…, n。可以用 Ctrl+X（剪切）和Ctrl+V（粘贴）快捷键来完成任务。每次可以剪切一段连续的自然段，粘贴时按照顺序粘贴。注意，剪贴板只有一个，所以不能连续剪切两次，只能剪切和粘贴交替。&lt;/p&gt;
&lt;p&gt;  例如，为了将{2,4,1,5,3,6}变为升序，可以剪切1将其放到2前，然后剪切3将其放到4 前。再如，对于排列{3,4,5,1,2}，只需一次剪切和一次粘贴即可——将{3,4,5}放在{1,2}后， 或者将{1,2}放在{3,4,5}前。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UVa OJ 1601 - The Morning after Halloween</title>
      <link>https://yuukidach.github.io/p/uva-oj-1601-the-morning-after-halloween/</link>
      <pubDate>Thu, 04 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1601-the-morning-after-halloween/</guid>
      <description>Problem You are working for an amusement park as an operator of an obakeyashiki, or a haunted house, in which guests walk through narrow and dark corridors. The house is proud of their lively ghosts, which are actually robots remotely controlled by the operator, hiding here and there in the corridors. One morning, you found that the ghosts are not in the positions where they are supposed to be. Ah, yesterday was Halloween.</description>
    </item>
    
    <item>
      <title>关于博客的二三事</title>
      <link>https://yuukidach.github.io/p/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</link>
      <pubDate>Thu, 04 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</guid>
      <description>自从博客搭建以来，已经陆续续地将页面更新几次了。总一开始的默认的landscape主题，到hueman，再到icarus，都有过尝试，最终还是选定了landscape作为主题。主要还是这个主题的自主性更大一些，而且有一个很大的banner，看起来比较舒服。
 在调整各种颜色的时候，只是觉得黑色的比较舒服，没有那么刺眼，现在再看我的博客，居然和我在第二篇文章里提到的Morris&amp;rsquo;s Blog十分的相似(摊手)。
 之前在各个板块，包括图标什么的，调整过很多次了，但是没有及时的记载下来，现在才想起来要有个记录什么的。不过话说回来，在知乎上看到别人更新的时候，都会用“某年某月某日”更新了XXX&amp;hellip;早就也想着要这样试一次了，借此机会，也算满足我的一个小愿望吧
2016-08-04 1.更新了主页右上角图标 美化了GitHub的标志，同时增加了Facebook的图标，搜索栏也能使用Google搜索了。话说回来，我的Facebook基本没加什么好友哇，求勾搭(笑)。
2.提交了Google和百度的抓取 一开始提交了好几次都不成功，后来才发现，在利用html文件进行验证的时候，需要把文件放在theme的source目录下，而不是根目录的source目录下。
 不得不说还是Google的操作方便，效率也高啊。
2016-08-06 3.解决了字符缩进问题 贴上去的代码再也不会出现莫名其妙的缩进问题了，高亮问题也得到了解决。其实更多的是编辑器的问题 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄
4.返回顶部按钮优化 调用本地上传的jQuery文件，不会出现国内网络点击“返回顶部”按钮没有反应的问题
5.新增文章目录 再也不用担心鼠标滚轮滚坏了还找不到需要的内容啦！
6.更换了网页图标 没有烦人的四方形白边框了。这应该不是强迫症吧┑(￣Д ￣)┍
7.右上角新加微博图标 大家一起愉快地刷微博啊。
2016-08-07 8.更换了主页标题的字体样式 终于感觉看自己的博客首页没有那么别扭了！
2016-08-11 9.修改了底部导航栏颜色 一片白色根本什么都看不清啊。还是黑色的舒服。
2016-08-12 10.增加了文章封面 终于不用担心目录和文章开头的图片相冲突了。
11.增加了二级目录 啊，缠绕在心头的心病终于解决了。
2016-08-14 12.修改了水平线格式 果然还是1.3px，solid 叫人放心啊。
2016-08-16 13.修复了最底部出现双斜杠的情况 找了好久的原因，最后发现是一个注释给写错了 (:зゝ∠)
2016-08-17 14.更改了主页文章footer的位置 将主页文章的footer提到了标题下，为后续的界面更改做准备。
15.修改了分享框内字体颜色 一开始大意了，没有调整，导致看不清框内文字，现已修正为黑色。
2016-08-18 16.Recent Posts栏目更改 文章名称前增加了字符画，美化界面
2016-08-21 17.修改文章预览效果 给文章预览的底部加上了文字渐隐效果。Read More按钮也将进行后续改进，以提升文章的打开速度，方便阅读
2016-08-23 18.完善了Read More按钮 借鉴了Morris博客里的展开按钮。可以在主页进行展开和收缩，阅读更加快速和方便。但是焦点问题还是需要一点点修复
2016-08-24 19.更改了引用的样式 进行了一定的美化，缩小了字样，添加了左边界，一定程度上有助于阅读
20.进一步美化Recent Post栏目 令过长文章名称可以以省略号的形式隐藏，并将文章数量扩增到10个，文章名称前的字符画也改为用fontawesome中的图标</description>
    </item>
    
    <item>
      <title>无所事事的闲暇时光</title>
      <link>https://yuukidach.github.io/p/%E6%97%A0%E6%89%80%E4%BA%8B%E4%BA%8B%E7%9A%84%E9%97%B2%E6%9A%87%E6%97%B6%E5%85%89/</link>
      <pubDate>Thu, 04 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/%E6%97%A0%E6%89%80%E4%BA%8B%E4%BA%8B%E7%9A%84%E9%97%B2%E6%9A%87%E6%97%B6%E5%85%89/</guid>
      <description>博客已经开起来了，后续还会继续地完善。
不过我本身水平有限，开这样一个博客，或许更多的，是一种的自娱自乐吧。能给大家带来一点帮助的话，自然是不胜荣幸的。
嘛，既然自己现在还处在一个入门的阶段，对编程的理解也是很浅显，那就还有很多的东西需要去学，需要去尝试。有时候会感觉，写代码不光是数学层面的计算，还融合了语言的表达能力在里面。
来一个突兀的中断吧。先暂时写这么多。</description>
    </item>
    
    <item>
      <title>UVa OJ 10603 - Fill</title>
      <link>https://yuukidach.github.io/p/uva-oj-10603-fill/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-10603-fill/</guid>
      <description>Problem There are three jugs with a volume of a, b and c liters. (a, b, and c are positive integers not greater than 200). The first and the second jug are initially empty, while the third is completely filled with water. It is allowed to pour water from one jug into another until either the first one is empty or the second one is full. This operation can be performed zero, one or more times.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://yuukidach.github.io/p/hello-world/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/hello-world/</guid>
      <description>Welcome to Yuuki_Dach&amp;rsquo;s Blog! :D
This is my very first post. I will upload some of my learning progress in this blog. If you are interested in my projects, you can also find them in My GitHub.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming Exercises on Dash&#39;s Blog</title>
    <link>https://yuukidach.github.io/categories/programming-exercises/</link>
    <description>Recent content in Programming Exercises on Dash&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://yuukidach.github.io/categories/programming-exercises/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UVa OJ 1220 - Party at Hali-Bula</title>
      <link>https://yuukidach.github.io/p/uva-oj-1220-party-at-hali-bula/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1220-party-at-hali-bula/</guid>
      <description>Problem Here is the: problem link
Solution 这道题目一开始没有用f[][]来标记是否重复，导致WA了一次，后来就加上去了。另外，在处理人名时，虽然实例输入里，上司和下属名字出现是有先后的，但是提交之后，系统的测试数据貌似不一定是这样，所以要先判断是否出现，没出现就用cnt加1再赋值
递归的思路还是不难的，选了上司，那么直属员工就不选，用d[][0]表示不选;没选的话就可以选直属员工，也可以不选，分别是d[][1]和d[][0]
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; #define G sons[b][i] const int maxn = 205; int n, res, yn, d[maxn][2], f[maxn][2]; char c1[maxn], c2[maxn]; map&amp;lt;string, int&amp;gt; p; vector&amp;lt;int&amp;gt; sons[maxn]; int dp(int b,int y) { int&amp;amp; ans = d[b][y]; if (ans != -1) return ans; int k = sons[b].size(); if(!k) {f[b][y] = 1; return ans = y;} int mark = 1; if(y) { for(int i = 0; i &amp;lt; k; ++i) { ans += dp(G,0); if(!</description>
    </item>
    
    <item>
      <title>UVa OJ 12186 - Another Crisis</title>
      <link>https://yuukidach.github.io/p/uva-oj-12186-another-crisis/</link>
      <pubDate>Thu, 29 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12186-another-crisis/</guid>
      <description>Problem A couple of years ago, a new world wide crisis started, leaving many people with economical problems. Some workers of a particular company are trying to ask for an increase in their salaries.
The company has a strict hierarchy, in which each employee has exactly one direct boss, with the exception of the owner of the company that has no boss. Employees that are not bosses of any other employee are called workers.</description>
    </item>
    
    <item>
      <title>UVa OJ 1331 - Minimax Triangulation</title>
      <link>https://yuukidach.github.io/p/uva-oj-1331-minimax-triangulation/</link>
      <pubDate>Thu, 29 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1331-minimax-triangulation/</guid>
      <description>Problem Here is the: problem link
Solution 这道题目一开始用递归做，但是时间比较长，于是花了比较长的时间去想应该怎么才能转化成递推
这道题目用d[i][j]来表示从i点切割到j点中所含的面积最大的三角形中，最小的那个
这里用了三个循环，第一层是确定分割时跨越的点数，第二层是起点，第三层就是起点和终点中任意取一点分割。同时还要注意分割时会不会有点卡在中间导致实际上不能被分割的情况
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;iomanip&amp;gt;using namespace std; const int maxn = 55; int n, cas; double x[maxn], y[maxn], d[maxn][maxn]; double cntArea(int a, int b, int c) { return fabs((x[b]-x[a])*(y[c]-y[a])-(y[b]-y[a])*(x[c]-x[a]))/2; } bool isOK(int x,int y, int z) { double s = cntArea(x, y, z); for (int i = 0; i &amp;lt; n; ++i) { if (i == x || i == y || i ==z) continue; double tmp = cntArea(x,y,i)+cntArea(x,z,i)+cntArea(y,z,i); if (fabs(s-tmp) &amp;lt; 1e-6) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>UVa OJ 10003 - Cutting Sticks</title>
      <link>https://yuukidach.github.io/p/uva-oj-10003-cutting-sticks/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-10003-cutting-sticks/</guid>
      <description>Problem You have to cut a wood stick into pieces. The most affordable company, The Analog Cutting Machinery, Inc. (ACM), charges money according to the length of the stick being cut. Their procedure of work requires that they only make one cut at a time.
It is easy to notice that different selections in the order of cutting can led to different prices. For example, consider a stick of length 10 meters that has to be cut at 2, 4 and 7 meters from one end.</description>
    </item>
    
    <item>
      <title>UVa OJ 1625 - Color Length</title>
      <link>https://yuukidach.github.io/p/uva-oj-1625-color-length/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1625-color-length/</guid>
      <description>Problem Here is the prolem link
Solution 这道题目要先处理好每个颜色的起止位置，不然会很不方便。用数组d[i][j]表示已经插入了第一个字符串的i个，第二个字符串的j个字母。递推的时候，只要发现还有字母没有用完，就加1
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; const int maxn = 5002; char n[maxn], m[maxn]; int cas, l1, l2; int begs[2][26], endz[2][26], d[maxn][maxn]; void findLetter(char a[], int l, int o) { for (int i = 1; i &amp;lt;= l; ++i) { if (!endz[o][a[i]-&amp;#39;A&amp;#39;]) begs[o][a[i]-&amp;#39;A&amp;#39;] = i; endz[o][a[i]-&amp;#39;A&amp;#39;] = i; } } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; cas; while(cas--) { cin &amp;gt;&amp;gt; n+1 &amp;gt;&amp;gt; m+1; n[0] = m[0] = 0; memset(begs, 0x3f, sizeof(begs)); memset(endz, 0, sizeof(endz)); l1 = strlen(n+1); l2 = strlen(m+1); findLetter(n, l1, 0); findLetter(m, l2, 1); for (int i = 0; i &amp;lt;= l1; ++i) { for (int j = 0; j &amp;lt;= l2; ++j) { int num = 0, ans = 0x3f3f3f3f; for (int k = 0; k &amp;lt; 26; ++k) if ((i &amp;gt;= begs[0][k] || j &amp;gt;= begs[1][k]) &amp;amp;&amp;amp; (i &amp;lt; endz[0][k] || j &amp;lt; endz[1][k])) ++num; if (i) ans = min(d[i-1][j], ans); if (j) ans = min(ans, d[i][j-1]); d[i][j] = (ans==0x3f3f3f3f?</description>
    </item>
    
    <item>
      <title>UVa OJ 11400 - Lighting System Design</title>
      <link>https://yuukidach.github.io/p/uva-oj-11400-lighting-system-design/</link>
      <pubDate>Sun, 25 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11400-lighting-system-design/</guid>
      <description>Problem You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current.</description>
    </item>
    
    <item>
      <title>UVa OJ 11584 - Partitioning by Palindromes</title>
      <link>https://yuukidach.github.io/p/uva-oj-11584-partitioning-by-palindromes/</link>
      <pubDate>Sun, 25 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11584-partitioning-by-palindromes/</guid>
      <description>Problem Here is the: link
Solution 先对字符串进行预处理，把回文字符串的长度全部记录下来，然后用DP对回文字符串的个数进行处理。最小个数=min(之前已经处理过的长度所含回文字符串的最小值+未处理的长度所含回文字符数的最小值)
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; const int maxn = 1005; char s[maxn]; int d[maxn], idx[maxn][maxn], cas; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; cas; while(cas--) { cin &amp;gt;&amp;gt; s+1; int n = strlen(s+1); memset(d, 0x3f, sizeof(d)); d[0] = 0; for (int i = 1; i &amp;lt;= n; ++i) { idx[i][i] = 1; for (int j = i+1; j &amp;lt;= n; ++j) { bool isOK = false; for (int k = 0; k &amp;lt; (j-i+1&amp;gt;&amp;gt;1); ++k) if (s[i+k] !</description>
    </item>
    
    <item>
      <title>UVa OJ 116 - Unidirectional TSP</title>
      <link>https://yuukidach.github.io/p/uva-oj-116-unidirectional-tsp/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-116-unidirectional-tsp/</guid>
      <description>Problem Here is the: problem link
Solutions 这道题目不难，但是要注意一下输出的格式，我因为输出格式的问题反复提交了好几次
我们用dp[i][j]来表示(i,j)距离最后一列的距离。为了节省时间，用了一个Next[]数组来保存向右走的路径，避免反复取余造成的时间上的浪费。
还有，记得不要用next和end，是关键字 =_=
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;using namespace std; int r, c, start, End; int Next[12]; int block[12][102], idx[12][102]; long dp[12][102]; int main(){ ios::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  while(cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c) { memset(idx, 0, sizeof(idx)); memset(dp, 0, sizeof(dp)); for (int i = 1; i &amp;lt;= r; ++i) Next[i] = i; Next[r+1] = 1; Next[0] = r; for (int i = 1; i &amp;lt;= r; ++i) for (int j = 1; j &amp;lt;= c; ++j) cin &amp;gt;&amp;gt; block[i][j]; for (int j = c; j &amp;gt; 0; --j) { for (int i = 1; i &amp;lt;= r; ++i) { long tmp = 0x3f3f3f3f3f3f; for (int k = -1; k &amp;lt; 2; ++k) { long a = dp[Next[i+k]][j+1]+block[i][j]; if (a &amp;lt; tmp) { tmp = dp[i][j] = a; idx[i][j] = Next[i+k]; } else if (a == tmp) idx[i][j] = min(idx[i][j], Next[i+k]); } } } start = 1; long tmp, minh = dp[1][1]; for (int i = 2; i &amp;lt;= r; ++i) { tmp = dp[i][1]; if (tmp &amp;lt; minh) { start = i; minh = tmp; } } End = start; for(int j = 1; j &amp;lt; c; ++j) { cout &amp;lt;&amp;lt; End &amp;lt;&amp;lt; &amp;#39; &amp;#39;; End = idx[End][j]; } cout &amp;lt;&amp;lt; End &amp;lt;&amp;lt; &amp;#39;\n&amp;#39; &amp;lt;&amp;lt; dp[start][1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } </description>
    </item>
    
    <item>
      <title>UVa OJ 12563 - Jin Ge Jin Qu hao</title>
      <link>https://yuukidach.github.io/p/uva-oj-12563-jin-ge-jin-qu-hao/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12563-jin-ge-jin-qu-hao/</guid>
      <description>Problem Here is the: link
Solution 这道题目一开始用时间作为一个大循环去进行递推，但是发现并不是很好判断歌曲是否有唱过，所以后来还是采用歌曲作为大循环，再以时间为小循环。不过记得要留出1s来给《劲歌金曲》
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; int T, n, t, cas, ans; int song[51], dp[9001]; long long lis[9001]; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; T; while(T--) { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; t; memset(dp, 0x8f, sizeof(dp)); dp[0] = 0; ans = t-1; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; song[i]; for (int i = 0; i &amp;lt; n; ++i) for (int j = t-1; j &amp;gt;= song[i]; --j) dp[j] = max(dp[j], dp[j-song[i]]+1); for (int i = t-1; i &amp;gt;=0; --i) ans = dp[i]&amp;gt;dp[ans] ?</description>
    </item>
    
    <item>
      <title>UVa OJ 1347 - Tour</title>
      <link>https://yuukidach.github.io/p/uva-oj-1347-tour/</link>
      <pubDate>Fri, 23 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1347-tour/</guid>
      <description>Problem John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi = &amp;lt; xi, yi &amp;gt; . John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point.</description>
    </item>
    
    <item>
      <title>UVa OJ 437 - The Tower of Babylon</title>
      <link>https://yuukidach.github.io/p/uva-oj-437-the-tower-of-babylon/</link>
      <pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-437-the-tower-of-babylon/</guid>
      <description>Problem The babylonians had n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.
They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block.</description>
    </item>
    
    <item>
      <title>UVa OJ 714 - Copying Books</title>
      <link>https://yuukidach.github.io/p/uva-oj-714-copying-books/</link>
      <pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-714-copying-books/</guid>
      <description>Problem Here is the Problem Link
Solution 在车站有三种选择：1.等；2.向右走 3.向左走
我们从约定的地点和约定的时间倒回来考虑，如果能够在0（初始时刻）回到车站1,就表示能够完成。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;using namespace std; int n, T, m1, m2, cas;; int t[55], d[255], e[255]; int fromRight[205][55], fromLeft[205][55], takeTime[205][55]; void init() { memset(fromLeft, 0, sizeof(fromLeft )); memset(fromRight, 0, sizeof(fromRight)); cin &amp;gt;&amp;gt; T; for (int i = 1; i &amp;lt; n ; ++i) cin &amp;gt;&amp;gt; t[i]; cin &amp;gt;&amp;gt; m1; for (int i = 1; i &amp;lt;= m1; ++i) { cin &amp;gt;&amp;gt; d[i]; int tmp = d[i]; fromLeft[tmp][1] = 1; for (int j = 1; j &amp;lt; n; ++j) { tmp += t[j]; if (tmp &amp;lt;= T) fromLeft[tmp][j+1] = 1; else break; } } cin &amp;gt;&amp;gt; m2; for (int i = 1; i &amp;lt;= m2; ++i) { cin &amp;gt;&amp;gt; e[i]; int tmp = e[i]; fromRight[tmp][n] = 1; for (int j = n-1; j &amp;gt; 1; --j) { tmp += t[j]; if (tmp &amp;lt;= T) fromRight[tmp][j] = 1; else break; } } memset(takeTime, 0x3f, sizeof(takeTime)); takeTime[T][n] = 0; } int main() { ios_base::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>UVa OJ 12265 - Selling Land</title>
      <link>https://yuukidach.github.io/p/uva-oj-12265-selling-land/</link>
      <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12265-selling-land/</guid>
      <description>Problem 输入一个n*m(1≤n,m≤1000)矩阵,每个格子可能是空地,也可能是沼泽。对于每个空地格子,求出以它为右下角的空矩形的最大周长,然后统计每个周长出现了多少次。
Input On the first line a positive integer: the number of test cases, at most 100. After that per test case:
 One line with two integers n and m (1 ≤ n, m ≤ 1000): the dimensions of Per’s parcel. n lines, each with m characters. Each character is either ‘#’ or ‘.’. The j-th character on the i-th line is a ‘#’ if position (i, j) is a swamp, and ‘.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-11 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-11-solution/</link>
      <pubDate>Tue, 20 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-11-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这个题目感觉就很玄乎了，就只给我们一张图片，网页源码里空空如也
这里实际上是把一张图片拆分成两张来看。
我尝试了不同的奇偶拆分方式，最终还是选定了X轴和Y轴相加的方式来判断奇偶
from io import BytesIO from PIL import Image __author__ = &amp;#39;Yuuki_Dach&amp;#39; img = Image.open(&amp;#39;cave.jpg&amp;#39;) width, height = img.size even = Image.new(&amp;#39;RGB&amp;#39;, (width &amp;gt;&amp;gt; 1, height &amp;gt;&amp;gt; 1)) odd = Image.new(&amp;#39;RGB&amp;#39;, (width &amp;gt;&amp;gt; 1, height &amp;gt;&amp;gt; 1)) for i in range(width): for j in range(height): imgPixel = img.getpixel((i, j)) if (i + j) &amp;amp; 1 == 1: odd.putpixel((i &amp;gt;&amp;gt; 1, j &amp;gt;&amp;gt; 1), imgPixel) else: even.</description>
    </item>
    
    <item>
      <title>UVa OJ 1442 - Cav</title>
      <link>https://yuukidach.github.io/p/uva-oj-1442-cav/</link>
      <pubDate>Tue, 20 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1442-cav/</guid>
      <description>Problem Link: 1442 - Cav
Solution Use greedy algorithm to deal with this problem.
Adjust the height of ceiling to fit the requirements.
Here is the code:
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;using namespace std; const int maxn = 1e6+5; int cas, n, cnt; int ceiling[maxn], floor[maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); //freopen(&amp;#34;input.txt&amp;#34; , &amp;#34;r&amp;#34;, stdin );  //freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout);  cin &amp;gt;&amp;gt; cas; while(cas--) { cnt = 0; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; floor[i]; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; ceiling[i]; int tmp = maxn; for (int i = 0; i &amp;lt; n; ++i) { tmp = min(tmp, ceiling[i]); tmp = max(tmp, floor[i]); ceiling[i] = tmp; } tmp = maxn; for (int i = n-1; i &amp;gt; -1; --i) { tmp = min(tmp, ceiling[i]); tmp = max(tmp, floor[i]); ceiling[i] = tmp; cnt += ceiling[i] - floor[i]; } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } </description>
    </item>
    
    <item>
      <title>The Python Challenge Level 9-10 Solutions</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-9-10-solutions/</link>
      <pubDate>Mon, 19 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-9-10-solutions/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
Level 9 第九关树的图片其实是一个提示，就是要我把点一个个的连起来，而这个点是由网页源代码里注释的first和second部分给出的，我直接把两个部分的坐标提取到一起，能够得到一个牛的图片
import requests import re from PIL import Image, ImageDraw webUrl = &amp;#39;http://www.pythonchallenge.com/pc/return/good.html&amp;#39; webContent = requests.get(webUrl, auth=(&amp;#39;huge&amp;#39;,&amp;#39;file&amp;#39;)).text print(webContent) pattern = re.compile(r&amp;#34;(\d{2,3})&amp;#34;) nums = re.findall(pattern, webContent) nums = list(map(int,nums)) nums.remove(nums[0]) nums.remove(nums[0]) print(nums) img = Image.new(&amp;#39;RGB&amp;#39;, (800,800)) draw = ImageDraw.Draw(img) draw.polygon(nums, &amp;#39;white&amp;#39;) img.show() 这里最先发应的是&amp;rsquo;cow&amp;rsquo;这个单词，输入后提示我们是公的。于是再输入&amp;rsquo;ox&#39;，结果还是不对。输入&amp;rsquo;bull&amp;rsquo;就对了
Level 10 这一关简单明了，就是找规律（然而渣渣的我还是找了很久）
可以发现，后一个数实际上是前一个数的读法，比如
a[0] = 1 a[1] = 1个1 # 11 a[2] = 2个1 # 21 # 以此类推 a, sub = &amp;#39;1&amp;#39;, &amp;#39;&amp;#39; for i in range(30): j = k = 0 while j &amp;lt; len(a): while k &amp;lt; len(a) and a[k] == a[j]: k += 1 sub += str(k-j) + a[j] j = k a, sub = sub, &amp;#39;&amp;#39; print(len(a)) 最后结果是5808</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-7 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-7-solution/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-7-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这道题目网页源代码里没有什么别的提示，而图片中有个条形码类似物，那么就需要我们对图片进行处理了。先想办法把条形码读出来,并且转换成可读的文字
#! /usr/bin/env python3 # -*- coding: utf-8 -*- from PIL import Image from io import BytesIO import requests imgUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/oxygen.png&amp;#39; img = Image.open(BytesIO(requests.get(imgUrl).content)) for i in range(img.width): midPixel = img.getpixel((i,img.height&amp;gt;&amp;gt;1)) print(midPixel) 得到结果以后我们可以发现，条形码中没一条的宽度是7个像素，所以我们可以再处理一下，把相同的条形码rgb值取一个即可。另外还要注意的是，条形码没有覆盖全部的图片，最后无序的rgb值需要删掉，所以改进一下代码
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from PIL import Image from io import BytesIO import requests imgUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/oxygen.png&amp;#39; img = Image.open(BytesIO(requests.get(imgUrl).content)) midPixel = [img.getpixel((i,img.height&amp;gt;&amp;gt;1)) for i in range(0,img.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-8 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-8-solution/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-8-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这道题目消耗了我相当长的一段时间，让我对str和byte也有了一个新的认识。
首先还是老样子，进入网页源代码，看看里面有什么
首先引入眼帘的是一大串坐标代码，加上第七题的做法，很容易让人产生误会。我也试着去把他门转换了一下，发现并没有什么用处，然后就把目光集中在了里面的链接上，点了一下，需要用户名和密码，随便输入了123,并没有什么效果
再看看源代码底部有&amp;rsquo;un&amp;rsquo;和&amp;rsquo;pw&#39;，刚好两个，而且和&amp;rsquo;user name&#39; &amp;lsquo;password&amp;rsquo;相对应。 但是这两串字符又有什么意义呢？
我查了一下，发现这实际上是经bz2压缩后的信息，于是开始编写程序解码
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &#39;Yuuki_Dach&#39; import bz2 un = b&amp;quot;BZh91AY&amp;amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&amp;lt;]\xc9\x14\xe1BA\x06\xbe\x084&amp;quot; pw = b&amp;quot;BZh91AY&amp;amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&amp;lt;]\xc9\x14\xe1BBP\x91\xf08&amp;quot; print(bz2.decompress(un)) print(bz2.decompress(pw)) 得到用户名和密码就能进入下一关了</description>
    </item>
    
    <item>
      <title>The Python Challenge Level 0-1 Solutions</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-0-1-solutions/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-0-1-solutions/</guid>
      <description>前两天听说了有The Python Chanllenge这么一个游戏，于是自己也想来尝试一下。感觉还是一个挺有意思的。
附上我在Github上存放的代码仓库: The Python Challenge
Challenge 0 第0关只是一个让你大概清楚怎么玩的一个关卡，只要按照图片上的意思，计算2的38次方即可。这个就无所谓是用Python还是别的什么方式来计算了，能够得到结果就行，所以代码就不贴出来了。
算出结果之后，将结果复制到网页的url栏,将.html前面的单词替换掉就好
Challenge 1 根据图片给的提示我们可以发现，从K到M，O到Q，以及E到G，都是把单词给推后了两个。所以，我们只需要把他底下给我们的一大串字符串给统一推后两个字母就行了。另外要注意y要对应a,z则对应b。下面是我的初版代码:
#! /usr/bin/env python3 # -*- coding: utf-8 -*- code = (&amp;#34;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dm&amp;#34; &amp;#34;p. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&amp;#39;q ufw rfgq rcvr gq &amp;#34; &amp;#34;qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc&amp;#34; &amp;#34; spj.&amp;#34;) addr = &amp;#34;&amp;#34; for alpha in code: if alpha!</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-2 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-2-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-2-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
The Python Challenge第二关给了我们一张书的图片，但是十分模糊的，什么都看不清，这个时候，我们看看它给我们的文字提示是
 MAYBE they are in the page source.
 这个时候我们点击鼠标右键，查看网页的源代码，会发现，果然有一大长条乱七八糟的符号。不难猜到，我们所需要的下一关的url就藏在这堆符号里。于是我们用简单的爬虫爬取网页代码，然后利用正则表达式来捕捉我们需要的字母。
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from urllib import request import re pyUrl = &amp;#34;http://www.pythonchallenge.com/pc/def/ocr.html&amp;#34; req = request.Request(pyUrl) resq = request.urlopen(req) content = resq.read() book = re.compile(b&amp;#34;&amp;lt;!--(.*?)--&amp;gt;&amp;#34;, re.S) bookContents = re.findall(book, content) wordsCmpl = re.compile(b&amp;#34;([ a-zA-Z])&amp;#34;, re.S) for bookContent in bookContents: words = re.findall(wordsCmpl, bookContent) code = &amp;#34;&amp;#34; for word in words: code += word.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-3 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-3-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-3-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这里按照题目意思，利用正则匹配，找到恰好分别被三个大写字母包在左右的小写字母就好
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from urllib import request import re pyUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/equality.html&amp;#39; req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() pattern = re.compile(b&amp;#39;[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]&amp;#39;, re.S) contents = re.findall(pattern, urlContent) code = &amp;#39;&amp;#39; for content in contents: code += content.decode(&amp;#34;ascii&amp;#34;) print(code) 得到linkedlist，输入到url中，得到提示
linkedlist.php 把&#39;.html&amp;rsquo;的后缀改成&#39;.php&amp;rsquo;就通关了</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-4 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-4-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-4-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
依然是先查看网页源代码。发现有个链接&#39;&amp;hellip;nothing=12345&#39;
点进去之后发现又给我们一个数字，引导我们去下一个链接，于是可以知道，只要链接爬到了终点，那么就会出现别的提示信息
果然，爬到终点之后，提示我们除以二，继续爬，所以只要把代码改个数字就好，我的代码如下：
#!/usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &#39;Yuuki_Dach&#39; from urllib import request import re mainUrl = &#39;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=&#39; subUrl = &#39;8022&#39; # first try is &#39;12345&#39; subUrl2 = &#39;&#39; i = 400 while subUrl != subUrl2: subUrl2 = subUrl pyUrl = mainUrl + subUrl req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() pattern = re.compile(b&#39;\d+&#39;, re.S) contents = re.findall(pattern, urlContent) for content in contents: subUrl = content.</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-5 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-5-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-5-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
先看提示:
pronounce it 再看看网页源码，&amp;lsquo;peak hell&amp;rsquo;能代表什么？
我一开始以为是&amp;rsquo;pick&amp;rsquo;什么东西，点开&amp;rsquo;banner.p&amp;rsquo;之后没发现什么规律，于是先google了一下&amp;rsquo;peak hell&amp;rsquo;，发现了Python有pickle这么一个模块，那么就必然和这个有关系了。
pickle这个模块是python用来保存数据的，主要是loads和dumps方法的运用（这两个是对内存进行操作，如果要对硬盘进行操作，形成文件等形式，就是用load和dump），一个是读，一个是写，这里因为是直接从网页中获取数据，所以只要读就行了。
读完能发现这实际上是一个list组，再仔细点观察的话，就会注意到每一个[]中，把&#39; &amp;lsquo;和&amp;rsquo;#&amp;lsquo;后跟着的数字加起来，恰好是95。于是可以估计，这应该是利用点阵的方式来进行显示，而点阵的一行，有95个字符。这样就有了如下代码：
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; from urllib import request import pickle pyUrl = &amp;#39;http://www.pythonchallenge.com/pc/def/banner.p&amp;#39; req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() code = [] pic = pickle.loads(urlContent) for line in pic: for letter, num in line: code.append(num*letter) code.append(&amp;#39;\n&amp;#39;) print(&amp;#34;&amp;#34;.join(code)) 运行之后得到的点阵图是
 ##### ##### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ### #### ### ### ##### ### ##### ### ### #### ### ## #### ####### ## ### #### ####### #### ####### ### ### #### ### ### ##### #### ### #### ##### #### ##### #### ### ### #### ### #### #### ### ### #### #### #### #### ### #### #### ### #### #### ### #### #### #### #### ### ### #### #### #### #### ## ### #### #### #### #### #### ### #### #### #### #### ########## #### #### #### #### ############## #### #### #### #### ### #### #### #### #### #### #### #### #### #### #### #### ### #### #### #### #### #### #### ### #### #### #### ### #### #### #### #### ### #### ### ## #### #### ### #### #### #### #### #### ### ## #### ### ## #### #### ########### #### #### #### #### ### ## #### ### ###### ##### ## #### ###### ########### ##### ### ###### 大家请把终端的宽度拉大一点，不然会和我一开始一样，读不出什么东西来，并且怀疑是不是程序写错了 =_=</description>
    </item>
    
    <item>
      <title>The Python Challenge Level-6 Solution</title>
      <link>https://yuukidach.github.io/p/the-python-challenge-level-6-solution/</link>
      <pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/the-python-challenge-level-6-solution/</guid>
      <description>先附上我在Github上存放的代码仓库: The Python Challenge
这道题目开始让人很迷茫了（至少我是这样），先点开网页源码，没发现什么有价值等东西，然后又看看图片，发现右上角有个箭头，指着几个数字3，于是照着填进去了，发现没有链接，于是又跑去看源码，终于在开头发现了这个：
&amp;lt;!-- &amp;lt;-- zip --&amp;gt; 于是将&#39;.html&amp;rsquo;替换成&#39;.zip&#39;，居然下载下来了一个压缩包，点开之后会发现有一个readme.txt，再继续点开，内容如下：
welcome to my zipped list. hint1: start from 90052 hint2: answer is inside the zip 很明显，和前几题一样，就是按照90052这个数字找下去了，不过这次找的不是网页，而是文件。这里我们用zipfile这个模块来完成我们的需求
#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = &amp;#39;Yuuki_Dach&amp;#39; import zipfile import re zipFileName= &amp;#39;channel.zip&amp;#39; zipBag = zipfile.ZipFile(zipFileName) num = &amp;#39;90052&amp;#39; while True: zipContent = zipBag.read(num+&amp;#34;.txt&amp;#34;).decode(&amp;#34;utf-8&amp;#34;) print(zipContent) content = re.search(&amp;#34;(\d+)&amp;#34;, zipContent) if content == None: break num = content.group() 运行代码，会发现有以下信息：
Collect the comments.</description>
    </item>
    
    <item>
      <title>UVa OJ 1609 - Foul Play</title>
      <link>https://yuukidach.github.io/p/uva-oj-1609-foul-play/</link>
      <pubDate>Thu, 15 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1609-foul-play/</guid>
      <description>Problem n支队伍(2≤n≤1024,且n是2的整数幂)打淘汰赛,每轮都是两两配对,胜者进入下一轮。每支队伍的实力固定,并且已知每两支队伍之间的一场比赛结果。你喜欢1号队。虽然它不一定是最强的,但是它可以直接打败其他队伍中的至少一半,并且对于每支1号队不能直接打败的队伍t,总是存在一支1号队能直接打败的队伍t&amp;rsquo;使得t&amp;rsquo;能直接打败t。问:是否存在一种比赛安排,使得1号队夺冠?
Input For each test case, the input is as follows:
  One line containing the number of teams n, where n is a power of two and 2 ≤ n ≤ 1024. Teams are numbered from 1 to n, where team 1 is your favourite team.
  n lines, each containing a string of n binary digits. The k-th digit on the j-th line is ‘1’ if team j would certainly win from team k, otherwise it is ‘0’.</description>
    </item>
    
    <item>
      <title>UVa OJ 1608 - Non-boring sequences</title>
      <link>https://yuukidach.github.io/p/uva-oj-1608-non-boring-sequences/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1608-non-boring-sequences/</guid>
      <description>Problem A sequence is called non-boring if its every connected subsequence contains a unique element, i.e. an element such that no other element of that subsequence has the same value.
Given a sequence of integers, decide whether it is non-boring.
Input The first line of the input contains the number of test cases T. The descriptions of the test cases follow:
Each test case starts with an integer n (1 ≤ n ≤ 200000) denoting the length of the sequence.</description>
    </item>
    
    <item>
      <title>UVa OJ 12174 - Shuffle</title>
      <link>https://yuukidach.github.io/p/uva-oj-12174-shuffle/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12174-shuffle/</guid>
      <description>Problem You are listening to your music collection using the shuffle function to keep the music surprising. You assume that the shuffle algorithm of your music player makes a random permutation of the songs in the playlist and plays the songs in that order until all songs have been played. Then it reshuffles and starts playing the list again.
You have a history of the songs that have been played. However, your record of the history of played songs is not complete, as you started recording songs at a certain point in time and a number of songs might already have been played.</description>
    </item>
    
    <item>
      <title>UVa OJ 1607 - Gates</title>
      <link>https://yuukidach.github.io/p/uva-oj-1607-gates/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1607-gates/</guid>
      <description>Problem 描述起来很麻烦，大家还是直接去OJ站看吧。我之后也会解释一下题目的意思
题目链接： 1607 - Gates
Input The first line of the input contains exactly one positive integer d equal to the number of data sets, 1 ≤ d ≤ 20. The data sets follow.
Each data set consists of two consecutive lines. The rst of those lines contains exactly two positive integers n and m separated by single space, 1 ≤ n ≤ 100.000, 1 ≤ m ≤ 200.000. Integer n is the number of the net inputs and integer m is the number of the gates in the net.</description>
    </item>
    
    <item>
      <title>UVa OJ 11093 - Just Finish it up</title>
      <link>https://yuukidach.github.io/p/uva-oj-11093-just-finish-it-up/</link>
      <pubDate>Mon, 05 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11093-just-finish-it-up/</guid>
      <description>Problem Along a circular track, there are N gas stations, which are numbered clockwise from 1 up to N. At station i, there are pi gallons of petrol available. To race from station i to its clockwise neighbor one need qi gallons of petrol. Consider a race where a car will start the race with an empty fuel tank. Your task is to find whether the car can complete the race from any of the stations or not.</description>
    </item>
    
    <item>
      <title>UVa OJ 12627 - Erratic Expansion</title>
      <link>https://yuukidach.github.io/p/uva-oj-12627-erratic-expansion/</link>
      <pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-12627-erratic-expansion/</guid>
      <description>Problem 这个问题要带图才能方便理解题意，这里为了节省时间，大家自己去网站看题目就好。我真是太懒了 :p
Input The first line of input is an integer T (T &amp;lt; 1000) that indicates the number of test cases. Each case contains 3 integers K, A and B. The meanings of these variables are mentioned above. K will be in the range [0, 30] and 1 ≤ A ≤ B ≤ 2K.
Output For each case, output the case number followed by the total number of red balloons in rows [A, B] after K-th hour.</description>
    </item>
    
    <item>
      <title>UVa OJ 10954 - Add All</title>
      <link>https://yuukidach.github.io/p/uva-oj-10954-add-all/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-10954-add-all/</guid>
      <description>Problem 有n（n≤5000）个数的集合S，每次可以从S中删除两个数，然后把它们的和放回集合， 直到剩下一个数。每次操作的开销等于删除的两个数之和，求最小总开销。所有数均小于 105。
Input Each test case will start with a positive number, N (2 ≤ N ≤ 5000) followed by N positive integers (all are less than 100000). Input is terminated by a case where the value of N is zero. This case should not be processed.
Output For each case print the minimum total cost of addition in a single line.
Sample Input 3 1 2 3 4 1 2 3 4 0 Sample Output 9 19 Solution 题目很简单，就是最小的两个数相加，用优先队列只要几行代码就能完成。但是我为什么还要发一篇文章呢？因为通过这道题目，我知道了一个新的头文件 &amp;lt;functional&amp;gt; .</description>
    </item>
    
    <item>
      <title>UVa OJ 714 - Copying Books</title>
      <link>https://yuukidach.github.io/p/uva-oj-714-copying-books/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-714-copying-books/</guid>
      <description>Problem 把一个包含m个正整数的序列划分成k个（1≤k≤m≤500）非空的连续子序列，使得每个正 整数恰好属于一个序列。设第i个序列的各数之和为S(i)，你的任务是让所有S(i)的最大值尽 量小。例如，序列1 2 3 2 5 4划分成3个序列的最优方案为1 2 3 | 2 5 | 4，其中S(1)、S(2)、S(3) 分别为6、7、4，最大值为7；如果划分成1 2 | 3 2 | 5 4，则最大值为9，不如刚才的好。每个 整数不超过107。如果有多解，S(1)应尽量小。如果仍然有多解，S(2)应尽量小，依此类推
Input The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers m and k, 1 ≤ k ≤ m ≤ 500.</description>
    </item>
    
    <item>
      <title>UVa OJ 1451 - Average</title>
      <link>https://yuukidach.github.io/p/uva-oj-1451-average/</link>
      <pubDate>Mon, 29 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1451-average/</guid>
      <description>Problem 给定一个长度为n的01串，选一个长度至少为L的连续子串，使得子串中数字的平均值最 大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号 为1～n，因此[1,n]就是完整的字符串。1≤n≤100000，1≤L≤1000。
例如，对于如下长度为17的序列00101011011011010，如果L=7，最大平均值为6/8（子 序列为[7,14]，其长度为8）；如果L=5，子序列[7,11]的平均值最大，为4/5。
Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers n (1 ≤ n ≤ 100, 000) and L (1 ≤ L ≤ 1, 000) which are the length of a binary sequence and a length lower bound, respectively.</description>
    </item>
    
    <item>
      <title>UVa OJ 1471 - Defense Lines</title>
      <link>https://yuukidach.github.io/p/uva-oj-1471-defense-lines/</link>
      <pubDate>Fri, 26 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1471-defense-lines/</guid>
      <description>Problem After the last war devastated your country, you - as the king of the land of Ardenia - decided it was high time to improve the defense of your capital city. A part of your fortification is a line of mage towers, starting near the city and continuing to the northern woods. Your advisors determined that the quality of the defense depended only on one factor: the length of a longest contiguous tower sequence of increasing heights.</description>
    </item>
    
    <item>
      <title>UVa OJ 11572 - Unique Snowflakes</title>
      <link>https://yuukidach.github.io/p/uva-oj-11572-unique-snowflakes/</link>
      <pubDate>Thu, 25 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11572-unique-snowflakes/</guid>
      <description>Problem 输入一个长度为n（n≤106）的序列A，找到一个尽量长的连续子序列AL～AR，使得该序 列中没有相同的元素。
Input The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing an integer n, the number of snowflakes processed by the machine. The following n lines each contain an integer (in the range 0 to 109, inclusive) uniquely identifying a snowflake. Two snowflakes are identified by the same integer if and only if they are identical.</description>
    </item>
    
    <item>
      <title>UVa OJ 1606 - Amphiphilic Carbon Molecules</title>
      <link>https://yuukidach.github.io/p/uva-oj-1606-amphiphilic-carbon-molecules/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1606-amphiphilic-carbon-molecules/</guid>
      <description>Problem 平面上有n（n≤1000）个点，每个点为白点或者黑点。现在需放置一条隔板，使得隔板一侧的白点数加上另一侧的黑点数总数最大。隔板上的点可以看作是在任意一侧。
Input 不超过10个测试情况。每种情况以一个整数N开始，代表点的个数，接着输入N行x,y,r，分别表示坐标点的x坐标，y坐标和点的颜色，其中1是黑色。输入以0结束。
Output For each test case, output a line containing a single integer, which is the maximum number of dots we count.
Sample Input 3 0 0 0 0 1 0 2 2 1 4 0 0 0 0 4 0 4 0 0 1 2 1 7 -1 0 0 1 2 1 2 3 0 2 1 1 0 3 1 1 4 0 -1 2 0 0 Sample Output 3 3 6 Solution 扫描问题。只需要以一个点为基准点，然后做线，统计两边的点的数量就行。 在做这道题的时候，只是一个小小等式的区别，导致我TLE了好多次。后来也是测试了好久，才发现了这个问题。究其原因，还是取模太耗费时间，于是我就把取模的部分做了点修改，最终成功通过。 这里我利用先排序的方式，选好基准点之后，对每个点关于基准点的角度进行排序，然后才开始真正的扫描。</description>
    </item>
    
    <item>
      <title>UVa OJ 11054 - Wine trading in Gergovia</title>
      <link>https://yuukidach.github.io/p/uva-oj-11054-wine-trading-in-gergovia/</link>
      <pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11054-wine-trading-in-gergovia/</guid>
      <description>Problem As you may know from the comic “Asterix and the Chieftain’s Shield”, Gergovia consists of one street, and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simple enough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides how much wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that each inhabitant gets what he wants.</description>
    </item>
    
    <item>
      <title>UVa OJ 11134 - Fabled Rooks</title>
      <link>https://yuukidach.github.io/p/uva-oj-11134-fabled-rooks/</link>
      <pubDate>Wed, 10 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11134-fabled-rooks/</guid>
      <description>Problem  在n*n的棋盘上放n（n≤5000）个车，使得任意两个车不相互攻击，且第i个 车在一个给定的矩形Ri之内。用4个整数xli, yli, xri, yri（1≤xli≤xri≤n，1≤yli≤yri≤n）描述第i个 矩形，其中(xli,yli)是左上角坐标，(xri,yri)是右下角坐标，则第i个车的位置(x,y)必须满 足xli≤x≤xri，yli≤y≤yri。如果无解，输出IMPOSSIBLE；否则输出n行，依次为第1,2,…,n个车 的坐标。
Input The input consists of several test cases. The first line of each of them contains one integer number, n, the side of the board. n lines follow giving the rectangles where the rooks can be placed as described above. The i-th line among them gives xli, yli, xri, and yri. The input file is terminated with the integer ‘0’ on a line by itself.</description>
    </item>
    
    <item>
      <title>UVa OJ 1152 - 4 Values whose Sum is 0</title>
      <link>https://yuukidach.github.io/p/uva-oj-1152-4-values-whose-sum-is-0/</link>
      <pubDate>Mon, 08 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1152-4-values-whose-sum-is-0/</guid>
      <description>Problem 给定4个n（1≤n≤4000）元素集合A, B, C, D，要求分别从中选取一个元素a, b, c, d，使得 a+b+c+d=0。问：有多少种选法？
Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.
 The first line of the input file contains the size of the lists n (this value can be as large as 4000).</description>
    </item>
    
    <item>
      <title>UVa OJ 1605 - Building for UN</title>
      <link>https://yuukidach.github.io/p/uva-oj-1605-building-for-un/</link>
      <pubDate>Sun, 07 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1605-building-for-un/</guid>
      <description>Problem  你的任务是设计一个包含若干层的联合国大楼，其中每层都是一个等大的网格。有若干 国家需要在联合国大楼里办公，你需要把每个格子分配给一个国家，使得任意两个不同的国 家都有一对相邻的格子（要么是同层中有公共边的格子，要么是相邻层的同一个格子）。你设计的大厦最多不能超过1000000个格子。
Input  输入国家的个数n（n≤50）。
Output  输出大楼的层数H、每层楼的行数W和列数L，然后是每层 楼的平面图.不同的国家用不同的大小写字母表示。
Sample Input 4 Sample Output 2 2 2 AB CC zz zz Solution  这个题目没有给定楼层限制，也没有给定国家占地的限制，那么就显得很简单了。因为只需要保证每一个国家和另外一个国家的办公室都有邻边。那么我们可以直接把第一层的每个行分给不同的国家，然后第二层的每个列也分给不同的国家，问题就解决了。下面是简单而粗糙的代码
#include &amp;lt;cstdio&amp;gt;using namespace std; int main(){ int n,contry[55]; while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) == 1){ printf(&amp;#34;%d %d %d\n&amp;#34;, 2, n, n); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j) printf(&amp;#34;%c&amp;#34;, i &amp;lt; 26 ? &amp;#39;a&amp;#39; + i : &amp;#39;A&amp;#39; + i - 26); putchar(&amp;#39;\n&amp;#39;); } putchar(&amp;#39;\n&amp;#39;); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j) printf(&amp;#34;%c&amp;#34;, j &amp;lt; 26 ?</description>
    </item>
    
    <item>
      <title>UVa OJ 120 - Stacks of Flapjacks</title>
      <link>https://yuukidach.github.io/p/uva-oj-120-stacks-of-flapjacks/</link>
      <pubDate>Sat, 06 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-120-stacks-of-flapjacks/</guid>
      <description>Problem  有一叠煎饼正在锅里。煎饼共有n（n≤30）张，每张都有一个数字，代表它的大小，如 图8-11所示。厨师每次可以选择一个数k，把从锅底开始数第k张上面的煎饼全部翻过来，即 原来在上面的煎饼现在到了下面。
 设计一种方法使得所有煎饼按照从小到大排序（最上面的煎饼最小）。输入时，各个煎 饼按照从上到下的顺序给出。
Input The input consists of a sequence of stacks of pancakes. Each stack will consist of between 1 and 30 pancakes and each pancake will have an integer diameter between 1 and 100. The input is terminated by end-of-file. Each stack is given as a single line of input with the top pancake on a stack appearing first on a line, the bottom pancake appearing last, and all pancakes separated by a space.</description>
    </item>
    
    <item>
      <title>UVa OJ 11212 - Editing a Book</title>
      <link>https://yuukidach.github.io/p/uva-oj-11212-editing-a-book/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-11212-editing-a-book/</guid>
      <description>&lt;h1 id=&#34;problem&#34;&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;  你有一篇由n（2≤n≤9）个自然段组成的文章，希望将它们排列成1, 2,…, n。可以用 Ctrl+X（剪切）和Ctrl+V（粘贴）快捷键来完成任务。每次可以剪切一段连续的自然段，粘贴时按照顺序粘贴。注意，剪贴板只有一个，所以不能连续剪切两次，只能剪切和粘贴交替。&lt;/p&gt;
&lt;p&gt;  例如，为了将{2,4,1,5,3,6}变为升序，可以剪切1将其放到2前，然后剪切3将其放到4 前。再如，对于排列{3,4,5,1,2}，只需一次剪切和一次粘贴即可——将{3,4,5}放在{1,2}后， 或者将{1,2}放在{3,4,5}前。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UVa OJ 1601 - The Morning after Halloween</title>
      <link>https://yuukidach.github.io/p/uva-oj-1601-the-morning-after-halloween/</link>
      <pubDate>Thu, 04 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-1601-the-morning-after-halloween/</guid>
      <description>Problem You are working for an amusement park as an operator of an obakeyashiki, or a haunted house, in which guests walk through narrow and dark corridors. The house is proud of their lively ghosts, which are actually robots remotely controlled by the operator, hiding here and there in the corridors. One morning, you found that the ghosts are not in the positions where they are supposed to be. Ah, yesterday was Halloween.</description>
    </item>
    
    <item>
      <title>UVa OJ 10603 - Fill</title>
      <link>https://yuukidach.github.io/p/uva-oj-10603-fill/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yuukidach.github.io/p/uva-oj-10603-fill/</guid>
      <description>Problem There are three jugs with a volume of a, b and c liters. (a, b, and c are positive integers not greater than 200). The first and the second jug are initially empty, while the third is completely filled with water. It is allowed to pour water from one jug into another until either the first one is empty or the second one is full. This operation can be performed zero, one or more times.</description>
    </item>
    
  </channel>
</rss>

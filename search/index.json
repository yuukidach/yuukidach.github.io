[{"content":"为什么要进行迁移 对我来说HEXO实在是过于麻烦。\n最早接触这个东西，是看到别人的博客，发现很有趣，因此自己也想写一点东西上去。那个时候普遍采用 GitHub Page + HEXO 的做法，我自然也使用了同样的方法。\n然而随着时间线的拉长，在不同的环境下进行博客的恢复、管理，让我开始想尝试HEXO以外的方式。HEXO对我来说，不好的有以下几个方面：\n  包管理复杂。HEXO不像HUGO这样已经编译好，而使用npm进行各种包的管理，对于一个这方面的小白来说，我完全没法自己处理好各种 warning 和 error。GitHub也常常提示我有安全漏洞，但是我都不知道如何去修复比较好\n  图片插入麻烦。最开始我选择将图片上传到7牛进行托管，但是几年后我发现链接早就已经失效了。还是放在本地比较保险。而HEXO的本地插入实在是不敢恭维。\n  公式编辑。在我最开始使用到HEXO的时候，我并没有关心公式编辑这个问题。但是随着专业学习的深入，我逐渐开始依赖起这个功能来。承接第一点，让 HEXO 支持公式编辑费了我不少时间，让我对 HEXO 的易用程度进一步失去信心。我不想再未来当我需要新功能的时候，发现已经办法再去添加了。\n  不过不再使用HEXO也有一点小小的遗憾，那就是自己当初花了大把大把的时间去魔改我所有的主题模板，现在一下就舍弃掉，还是有那么点心疼，自己的心血终究还是被推倒了。\n 老界面1 \n 老界面2 \n 老界面3 \n不管怎么说，以后还是用HUGO吧，尽管它的主题比HEXO少了很多。但是对于不喜欢频繁更换主题的我来说，这点并不算能够阻挡我使用 HUGO 的原因。\n不强求博客更新多么高质量和频繁，以后能想起来就更新一点点吧。\n","date":"2020-12-30T17:32:31+08:00","image":"https://yuukidach.github.io/p/migratetohugo/cover_hub662a7dadcf66f5ea9d1983c35e8cae7_995899_120x120_fill_q75_box_smart1.jpg","permalink":"https://yuukidach.github.io/p/migratetohugo/","title":"从HEXO迁移到HUGO"},{"content":"Entropy 1. Shannon information\n\\[ I = -\\log_2{p} \\]\n $ p $ is the probability of the event Event with smaller probability contains more information. Logrithm base is 2 beacause in information technology 1 bit represents \u0026quot;0\u0026quot; or \u0026quot;1\u0026quot;.  It can also be regarded as how many bits we need to represent a random variable\n\\[ \\#bits = \\log_2{1\\over{p}} \\]\nFor example, when one variable has 8 possibilities. Each of them has a probability of 1/8. Then we need $ \\log_2{8} = 3 $ bits to represent the variable.\n2. Shannon entropy\n\\[ H = - \\sum_{i=1}^{n}{p_i\\log_{2}{p}_i} \\]\n $ H $ is sum of all possible events H = 1 means completly uncertain about the result. H = 0 means the result is known.  For example, if we throw a coin, it will have 2 results, both probabilities is 0.5.\n\\[ H = -0.5 \\times \\log_2{0.5} - 0.5 \\times \\log_2{0.5} = 1 \\]\nThe result is totally uncertain.\n3. Information gain\n\\[ IG(T, a) = H(T) - H(T|a) \\\\ H (T|a) = -\\sum_{x \\in {a}, y \\in{T}}{p(x, y)\\log{p(x, y) \\over {p(x)}}} \\]\n $ H(T|a) $ is the conditional entropy of T given the value of attribute a.  ID3 (Iterative Dichotomiser 3) Algorithm ID3 is an algorithm invented by Ross Quinlan used to generate a decision tree from a dataset.\nIt can be used for dataset with categorical features like:\n   Day Outlook Temperature Humidity Wind Play ball     D1 Sunny Hot High Weak No (-)   D2 Sunny Hot High Strong No (-)   D3 Overcast Hot High Weak Yes (+)   D4 Rain Mild High Weak Yes (+)   D5 Rain Cool Normal Weak Yes (+)   D6 Rain Cool Normal Strong No (-)   D7 Overcast Cool Normal Strong Yes (+)   D8 Sunny Mild High Weak No (-)    Pseudocode:\nID3 (Examples, Target_Attribute, Attributes) Create a root node for the tree If all examples are positive, Return the single-node tree Root, with label = +. If all examples are negative, Return the single-node tree Root, with label = -. If number of predicting attributes is empty, then Return the single node tree Root, with label = most common value of the target attribute in the examples. Otherwise Begin A ← The Attribute that best classifies examples. Decision Tree attribute for Root = A. For each possible value, vi, of A, Add a new tree branch below Root, corresponding to the test A = vi. Let Examples(vi) be the subset of examples that have the value vi for A If Examples(vi) is empty Then below this new branch add a leaf node with label = most common target value in the examples Else below this new branch add the subtree ID3 (Examples(vi), Target_Attribute, Attributes – {A}) End Return Root ID3 does not guarantee an optimal solution. It can converge upon local optima. It uses a greedy strategy by selecting the locally best attribute to split the dataset on each iteration.\nC4.5 Algorithm It can be used for data with continuous features.\nProcedure:\n Sort the data records by the attribute values Calculate the partition point for 2 consecutive records by $ (vi + v{i+1})/2 $ Partition the records into 2 sets by that partition point Calculate the entropy reduction (information gain) of the resulting partitions If all partition points are calculated, choose the point that yields the highest entropy reduction. Otherwise, ad i by 1 and go back to step 2  The whole process is nearly the same as ID3 algorithm, except for continuous feature, we need to calculate the partition point. But in ID3 algorithm, we can directly use the categories to split records.\nk-Nearest Neighbors Algorithm Distance between instance i and j\n\\[ d(x^{(i)}, x^{(j)}) = \\sqrt{\\sum_{r=1}^{n}{(f_r(x^{i})-f_r(x^{(j)}))^2}} \\]\n$f_r(x)$ is the feature value of instance $ x $.\nTo predict a new instance $ x^{(q)} $:\n1. Continues value\n\\[ \\hat{f} \\gets \\frac{1}{k} \\sum_{i=1}^{k}f(x^{(ki)}) \\]\n2. Discrete values\n\\[ \\hat{f} \\gets \\text{argmax}_{v \\in V} \\sum_{i=1}^{k} I(f(x^{(i)}) == v) \\]\nWe can also use distance weighted nearest neighbor algorithm:\n\\[ \\hat{f} \\gets \\frac{\\sum_{i=1}^{k}{w_if(x^{(i)})}}{\\sum_{i=1}^{k}{w_i}}, \\ \\text {where} \\ w_i = \\frac{1}{d(x^{(q)}, x^{(i)})^2} \\]\nEvaluation Classification 1. Evaluation Metrics\n\n\\[ Accuracy = \\frac{a+d}{a+b+c+d} \\\\ Precision = \\frac{d}{b+d} \\\\ Sensitivity = Recall = \\frac{d}{c+d} \\\\ Specificity = \\frac{a}{a+b} \\\\ (False\\ Positive\\ Rate = 1 - Specificity) \\]\n2. Area Under ROC Curve (AUC)\n\n Cutoff is the threshold a classification model uses to split between 2 classes. As the cutoff decreases, more and more cases are classified as 1; hence, the sensitivity increases and speificity decreases. As the ROC curvebows above the diagonal, the predictive power increases. Curve 1 is better than curve 2  Issues in Decision Tree Learning 1. Features with many unique values\nProblem: Gain tends to select features with many unique values to clssify instance.\nSolution: Adjust Gain to GainRatio\n\\[ SplitInfomation(S,A) \\equiv -\\sum_{i=1}^{c}\\frac{|S_i|}{|S|}\\log_2{\\frac{|S_i|}{|S|}} \\\\ GainRatio(S,A) = \\frac{Gain(S,A)}{SplitInfomation(S,A)} \\]\n$ S $ is the set of all records in a prarent node. $ S_i $ is a subset of records that have feature $ A_i $\nWhen should Gain Ratio be used in place of Gain?\n Compute both Gain Ratio and Gain for each feature Use Gain Ratio only for features with above-average Gain  2. Overfitting\nWays to avoid overfitting:\n Stop growing tree when data split is not statistically significant. Grow full tree then post-prune.  Selecting best tree:\n Measure performance over taining data Measure performance over seperate validation datases Add penalty against complexity  3. Unknown feature values\nStrategies to impute missing values of feature A:\n Use most common value of A in all instances having missing value for A Within each group of instances having same target value, assign most common value of A to instances  ","date":"2020-11-18T00:00:00Z","permalink":"https://yuukidach.github.io/p/ml/decision-tree-and-knn-learning/","title":"Decision Tree and k-Nearest Neighbors Learning"},{"content":"Transaction Definition Transaction: A sequence of multiple actions to be executed as an atomic unit.\nTransaction in SQL view:\n Begin transaction Sequence of SQL statements End transaction  Transaction Manager controls excution of transactions. Program logic is invisible to DBMS. For example:\n1. start transaction 2. read(R) 3. R = R - 100 ------\u0026gt; Invisible 4. write(R) 5. read(S) 6. S = S + 100 ------\u0026gt; Invisible 7. write(S) 8. end transaction ACID Properties A tomicity: All actions in the transaction happen, or none happen. C onsistency: If the database starts our consistent, it ends up consistent at the end of the transaction. I solation: Execution of each transaction is isolated from that of others. D urability: If a transaction commits, its effect persist.\nNote:\n For isolation, it\u0026rsquo;s just the excution not being affected. Consistency in database system refers to the requirement that any given DB transaction must change affected data only in allowed ways. (wiki)  Concurrency Control Serial schedule: Each transaction runs from start to finish without any intervening actions from other transactions.\nEquivalent: Two Schedules are equivalent, when:\n involve same transaction each individual transaction\u0026rsquo;s actions are ordered the same both schedules leave the DB in the same final state  Serializable: A serial is equivalent to some serial schedule.\nConflict: Two oprations are conflict, when:\n Are by different transactions Are on the same object At least one is write   Order of non-conflict operations has no effect on the final state of the DB.\n Conflict equivalent:\n involve the same actions of the same transactions every pair of conflicting actions is ordered the same way  Conflict serializable:\n the serial is conflict equivalent to some serial schedule the serial is also serializable   Some serializable schedule is not conflict serializable.\n Example:\na. conflict serializable\nT1: R(A) W(A) R(B) W(B) T2: R(A) W(A) R(B) W(B) b. not conflict serializable\nT1: R(A) W(A) T2: R(A) W(A) It is serializable but not conflict serializable View serializable:\n same initial reads same dependent reads same winning writes (If Ti writes finial value of A in S1, then Ti also writes final value of A in S2)  Two Phase Locking (2PL) Rules: transaction must obtain as S (shared) lock before reading, and an X (exclusive) lock before writing.\n2PL guarantees conflict serializability.\n2PL \u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; Release one by one strict 2PL \u0026mdash;\u0026gt; Release at the same time\n","date":"2020-11-13T00:00:00Z","permalink":"https://yuukidach.github.io/p/transaction-and-concurrency-control/","title":"Transaction and Concurrency Control"},{"content":"Manjaro edition: Manjaro-i3\nThis post is about how I configure my Manjaro i3\nSoftwares to Install  fcitx5 (no need to install sogou pinyin for linux anymore) deepin-wine-wechat deepin-wine-tim wps-office (together with ttf-wps-fonts) ttf-menlo-powerline-git (font for terminal) mpv (vedio player) netease-cloud-music Insync (sync a certain folder with google driver) variety (wallpaper software) picom albert (a fast launcher) vim (with vimplus) flameshot (screen capture tool) nerd-fonts-jetbrains-mono (font for vscode)  Multiple Monitors When we plug a HDMI/VGA cable into the computer, Manjaro i3 will not automatically display content in the external monitor. We need to use xrandr to set the display mode.\nMore specific usage can be found here: Multiple monitors.\n","date":"2020-11-03T00:00:00Z","permalink":"https://yuukidach.github.io/p/my-manjaro-i3-configurations/","title":"My Manjaro i3 Configurations"},{"content":"   Environment version     WSL 2   Docker Engine v19.03.13   Oracle Database Enterprise 12.2.0.1    Install WLS2 Check detailed and official document here.\nProblems I encountered 1. Use any commands related to WSL2 will cause error： “The attempted operation is not supported for the type of object referenced.”\nThis is beacause the proxy software conflicts with the sock port of WSL2.\nShort term solution Run command line as admin:\nnetsh winsock reset Then reboot computer.\nLong term solution Download NoLsp.exe here.\nRun command line as admin:\n\u0026lt;Location of NoLsp.exe\u0026gt; C:\\windows\\system32\\wsl.exe Install Docker and Oracle Download docker desktop and pull the image like in this post.\nUse SQL Developer Directly download and connection to the database.\nProblem I encountered 1. Invalid username / password\nI\u0026rsquo;m still a newbie to database. I still don\u0026rsquo;t know why this happened. But the solution to this is to create a new user account in database system directly in docker. Then reboot and we can use the new accout to login.\nCommand to create a new user account:\nSQL\u0026gt; alter session set \u0026#34;_ORACLE_SCRIPT\u0026#34;=true; SQL\u0026gt; create user \u0026lt;username\u0026gt; identified by \u0026lt;password\u0026gt;; SQL\u0026gt; GRANT CONNECT, RESOURCE, DBA TO \u0026lt;username\u0026gt;; ","date":"2020-10-20T00:00:00Z","permalink":"https://yuukidach.github.io/p/use-oracle-on-docker-for-windows/","title":"Use Oracle on Docker for Windows"},{"content":"距离本周一提出离职已经过去4天。在同CEO以及CTO都经过交流之后，终于思考清楚，也能好好地把事情做个记录。\n给人力的离职信全文\n本次离职的直接原因是生病发烧，带来心态上的变化，根本原因还是对工作内容的不喜欢。在和两位老板交流时，他们都表达了挽留的意思。但是挽留的说法却不尽相同。\n我是在周一晚上向CEO提出离职的，随后便进行了一次长达51分钟的电话聊天。聊天内容基本上是在问我对工作不满意的地方，以及我希望怎么样调整工作的方向。我个人对于CEO的印象还是非常不错的。年轻，没有架子，思辨性很强，对员工也极为友善，愿意培养新人。当初也是他直接省去了后续的面试，在两轮面试后，直接将我招进公司。在和他聊了这么多之后，我不由得感觉到一阵内疚加失落，这种感觉一直持续到周二结束。\n一方面我个人觉得这样的老板之后确实是很难遇到了，另一方面，虽然我的离职想法早就确定了，但是在目前公司缺人的情况下突然提出来，还是有点惭愧。\n为此我特意和我同样在工作的同学进行了短暂的意见交流，在得到他的支持意见后，我也逐渐安下心来。离职的想法也愈加坚定。\n到了周五，即今天，和CTO交流时，老实说还是有些许紧张。浑身上下会不自觉的发抖。站在阳台的阳光中之后，这才停了下来。CTO的挽留相对于CEO来说，更为理性一些。首先是肯定了我做的一些贡献，表达了对我的欣赏，后续又说了一些未来工作的迁移方向，以及自己当初工作的一点经历。\n必须得承认的是，我确实是被CTO的话语所打动。作为技术负责人，他对于我们所在做的事情，以及方向有很好的把握。对比CEO能描述出一个更为具体的发展计划、前景展望。在这一点上，是更让我心动的。\n但是还是需要继续保持坚定的离职的态度。写这篇post，其实也是方便我对此进行梳理：\n 虽然离职是周一提出来的，但是离职的想法是一直在的，最终还是要离开的。 读书已然势在必行。虽然我会担心疫情的影响，但是总体看法是乐观的。 公司的发展我认为前景无限，但是我对我自己未来的发展也抱有相对较高的期望。 公司的职位让我感觉到成长瓶颈。 其他人离职之后的发展也是不错的。  具体时间线上，准备下周去公司交接，下下周回家，之后通过网络完成工作的收尾。\n此次一别，想必是以后无法碰到现在的老板和同事了。大家都加油吧。\n","date":"2020-04-10T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BE%9E%E8%81%8C/","title":"第一次辞职"},{"content":"大概是在1月初的时候，我从隔壁工位的同事听说武汉出现了「不明原因的肺炎」。当时还不以为意，直到1月20日晚，准备回家过年的前一天，新闻上报道有肺炎扩散的趋势，自己这才开始重视起来。于是一向不喜欢戴口罩的我，在21日带着双层口罩出了门，乘地铁至火车站，后乘高铁回家。期间，在地铁上遇到的人，偶有一两个是佩戴了口罩的，其余人似乎都没受到肺炎相关新闻的影响。及至高铁，佩戴口罩的人稍多，但是大部分在列车发动一段时间后都摘了口罩，我自己亦是如此。只有邻座隔壁两人是除了吃午饭之外，始终保持佩戴的。见他们如此，我在午饭后也还是把口罩又重新戴了起来。\n之后的事情就和网上大部分人的情况一样了。在1月22日，也就是法定节假日开始的这天，大部分年轻人已经意识到肺炎的严重性，口罩已经成为大家出门必备的物品了，而上年纪的人往往却并不太在意。我在家也不断提醒父母做好防护，并囤积好足够的口粮，建议他们不去参加大型的集会。陪他们去菜市场的时候，整个市场我所发现的佩戴口罩的人，也仅仅只有我一个。\n在24日除夕过去之后，随着各项大型集会被取消，父母的防护意识开始被竖立起来，甚至一度比我更为紧张。\n2月2日，在经过了一段时间的假期延长后，我按照公司要求回到北京。\n在北京的头三周（大概），我一直在居家办公，偶尔会去公司拿点东西。每次出去都是心惊胆战，回来以后把出门的衣服全部脱下、清洗。\n2月末3月初，一直到现在，我们变成了现场办公，上班时间11AM - 4PM 。这段时间也是国内疫情开始缓和期间。这段时间我通常都是10点多抵达公司，尔后4-5点下班。但是公司的同事都去得特别早，还是和之前一样9点到，让我有些许的尴尬和不解。尴尬在于，每次我去的时候大家基本都到了，不解在于，大家在早高峰上班，难道已经不担心肺炎的事情了吗。关于这段时间北京的交通，就我自己的经历，车流和人流都是逐渐增加的，最开始一辆公交车可能载0-3人，现在已经有人没有座位了，若是按照正常时间上下班，还会堵车。交通密集程度大致有平常的百分之九十。\n在上述这段期间，国外的疫情开始显现出来。先是韩国和日本，日本的数据不太正常。暂且不论，韩国在不断加强检测力度后，逐渐被控制住。随后是伊朗，接着再是欧洲诸国，从意大利开始，疫情变得不可收拾，感染人数不断上升。现如今，美国报道出来的感染人数已经30万有余，实在是令人担忧。也正是如此，国内的疫情防控已经转变为防控境外输入了。北京作为首都，重要的交通枢纽，面临巨大的防控压力。这段时间看新闻，丝毫没有结束的迹象，倒是小城市已经没有什么危险了。有些人已经不戴口罩了。\n说起来，现场办公的这段时间，我对疫情的紧张程度是慢慢降低的。昨天和室友以及一个跳槽的同事聊天，他们的公司都准备在这周都准备调整回正常现场办公（我们现场办公时间比较早，是因为我们公司规模小）。正当我觉得一切都要回归正常的时候，4月5日，也就是昨天，我在下午发烧了，38.2℃。我第一时间通知了我准备回来住的室友，之后联系了医院的大夫，并把发烧的事情告诉给家里人。随后在医生的建议和室友的压力下，我在晚上8点多前往发热门诊做了核酸检测，排除了新冠肺炎感染的可能性。\n在发热门诊的检测，护士会先让你测体温和血压，随后才分诊到对应的部门。测量体温期间，三个穿着防护服的医护人员推着一辆病床进来。病床上是一个老头，旁边还陪着一老太太。我第一反应害怕，立马走到角落里，担心老头有肺炎疑似症状。之后护士见状首先处理了这个病号，同样需要先挂号检测。要说如果是快速的走完这个流程，我倒是不会那么害怕。可那老太太口齿不清，还不断干扰正常流程，不愿意挂号检测。尽管一个医护人员看不下去，愿意自掏腰包出钱，老太太还是不愿意检测，坚持认为医院已经或是准备坑她的钱。在他们僵持期间，我还是完成了挂号和检测的流程。再去照CT的路上，偶然从老太太口中听到老头是「北大教数学的教授」。这让我大为震惊。联系之前她说没有就医卡，能不能拿北大的卡替代的情况，我觉得这应该是实话。但是堂堂北大教授的老伴为什么会有这种表现呢？\n4月5号晚上九点多，我回到家中，和家里人开了个视频会议，提出了准备今天辞职，然后回家的想法，得到了家里人的赞同。在疫情发生之前，我是准备5月份离开北京的，后续觉得里我重回学校还有这么久，不如晚点回家，一方面多赚点钱也不亏，另一方面还能把药给打完，因此又改成了7月份回家。可是因为昨晚发烧这件事情，原本对工作内容长期积压的不满一时间涌现出来，让我觉得有借口和亲人及老板说我回家的事情了。我对家里人的说法是我担心北京的防疫，实际上让我真正不想继续干下去的根本原因，还是工作本身。而且我之前因为得去医院，已经请假一周，这次发烧我也不可能直接去公司，也还得请假一到两周，在家工作，与其如此，不如直接离职。\n在写这篇杂谈的时候，已经下午6点了，我还是没能下定决心和老板或者人事提出辞职。准备晚上八点之前做完最终的决定。大概率还是离开了。最让我纠结的，除开打药本身的影响外，还有就是公司的工作，虽然我不喜欢，但是目前人手不够，没人能承接我的工作。我的离开，等于公司对应项目的暂时搁浅。\n不行，还是不纠结了。和人事提出离职吧。\n","date":"2020-04-06T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E5%8F%91%E7%83%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BF%83%E6%80%81%E5%8F%98%E5%8C%96/","title":"发烧带来的心态变化"},{"content":"Background Image Processing Library To process a image, the easiest way is using a open source library.\nSince this project is written for others. They are not familiar with the image processing and it\u0026rsquo;s to hard for them to install OpenCV in their computer. So, I tried to find a light-weight image processing processing library called CImg.\nTo use this repo, we just need to put the header file CImg.h into our own project folder and include it in the program.\nNOTE: The CImg library can only deal with bmp file. In my project we need to deal with a jpg image, so we need to download ImageMagick in our computer to convert the jpg image into bmp image\nConversion Principle Because we will use ASCII code to represent the image, and the ASCII code only has one color, we only need to process a gray image. So the conversion steps become very simple:\n If the image is not gray, convert it to gray image Crop the image to the desired size (usually smaller than its original size) Define a string S which contains different ASCII code.(And its length l is better to be short) Convert the pixel value to a number res not bigger than l Subsitude the pixels with S[res]  Code #include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt; #undef cimg_display #define cimg_display 0 // no need to show image #include \u0026#34;CImg.h\u0026#34; using namespace cimg_library; using namespace std; const char *ASCII_LIST = \u0026#34;$@B%8\u0026amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~\u0026lt;\u0026gt;i!lI;:,\\\u0026#34;^`\u0026#39;. \u0026#34;; CImg\u0026lt;\u0026gt; rgb2gray(CImg\u0026lt;\u0026gt; color_img) { // create a gray image  CImg\u0026lt;\u0026gt; gray_img(color_img.width(), color_img.height(), 1, 1, 0); // for all pixels x,y in image  cimg_forXY(color_img, x, y) { // separation of channels  int R = (int) color_img(x, y, 0, 0); int G = (int) color_img(x, y, 0, 1); int B = (int) color_img(x, y, 0, 2); // calculate gray value  // (x, y) -\u0026gt; val_a, (x, y) -\u0026gt; a, b, c  int gray_val = (int) (0.299 * R + 0.587 * G + 0.114 * B); gray_img(x, y, 0, 0) = gray_val; } gray_img.normalize(0, 255); return gray_img; } /* * The input must be gray image. If not, use \u0026#39;rgb2gray\u0026#39; * to do a shift. * * gray_img: gray image * file_name: output file name * w: weight * h: height */ void print_gray2ascii(CImg\u0026lt;\u0026gt; gray_img, const char* file_name, int w, int h) { // output to out.txt  ofstream out(file_name); gray_img.resize(w, h); cimg_forY(gray_img,y) { cimg_forX(gray_img,x) { int val = gray_img(x, y, 0, 0) / sizeof(ASCII_LIST); out \u0026lt;\u0026lt; ASCII_LIST[val]; } out \u0026lt;\u0026lt; endl; } out.close(); } int main(void) { cimg::imagemagick_path(\u0026#34;D:\\\\\\\\\\\u0026#34;Program Files\\\u0026#34;\\\\ImageMagick-7.0.9-Q16\\\\magick.exe\u0026#34;); // Init images  CImg\u0026lt;\u0026gt; img(\u0026#34;test.jpg\u0026#34;); img = rgb2gray(img); const char *file_name = \u0026#34;out.txt\u0026#34;; print_gray2ascii(img, file_name, 200, 80); return 0; } ","date":"2020-02-19T00:00:00Z","permalink":"https://yuukidach.github.io/p/convert-image-to-ascii-art/","title":"Convert Image to ASCII Art"},{"content":"新冠病毒的爆发，让大家都闲在了家里，我也有时间好好整理一下最近的东西，顺带更新一下尘封已久的博客了。\n开始之前 「我为什么要搭建这个博客呢？」\n仔细想想，我好像还从来没说起过这个原因。不过那也已经是很久以前的事情了。\n最直接的原因是在搜索一道UVa OJ题解的时候，翻到了一位名叫Morris的博主的博客。在浏览他博客的过程中，由于自己本身也有希望给自己的成长做个记录的想法，「不如我也自己写一个博客吧！」这样的声音也不断在我脑海中浮现。于是乎，我照着这位博主的方式，也将这个博客搭建了起来。整体风格还是模仿他来的。但是由于自己水平有限，网站的整体技术上还是存在不小的差距。\n刚开始的时候，会频繁的更新这个博客。但随着时间的流逝，凡事三分钟热度的我，还是逐渐断更了，没再打理这个网站。中间偶然捡起来过几次，但最后终归是没再管过了。\n毕业 现在这个时代背景下，大家都在拼了命地读书，本科生遍地走，研究生往往成为了一个工作的起点。作为本科时代学习还不错我的，自然也是抱着「最少也得读个研」的想法了。因为自己的动手能力比较强，做项目、参加比赛往往能得到不错的成绩，加上GPA高，因此我身边的人无一不觉得我是可以保研成功的，我自己也是抱有这种想法的人之一。可是当我得知我恰在保研名单后两位的时候，不想再学习、考试的感觉不断地喷薄而出，我便也没参加考研，直接找了份工作就职了。\n找工作的那段时间，也算是我印象比较清晰的煎熬的时间段了。但是这份难受并不是找工作带来的，而是看着比我菜的人排名在我前面，顺顺利利地保研带来的。「我劝天公重抖擞，不拘一格降人才」这句话虽然说的夸张了，但是这大抵就是我内心最真实的想法了。\n记得大四上的时候，保研已经结束了，学院开始做课程设计，我和两位已经保研的同学一块。其中一人经常问我，另外一人真是什么都不会，上课听不懂，下课代码和报告都得找我要。\n 你在耍我是吗？在耍我是吧 – 徒然喜欢你 \n我当时真的很像抓住他们一顿乱锤，然后提到院长面前说他看看保研的都是什么人。但是这又有什么用呢，根据学院的评判标准，综合量化低的我，还是无力改变。既然如此，那就工作吧，工作吧！工作了也就自由了！\n工作 「工作了也就自由了」这是我内心的想法。我也顺利的拿了一个保底年薪300k，965的offer，这在本科生里边还是不错的。后续又因为表现突出，入职三个月后老板便给涨了一波工资。\n尽管这在大部分人看来，已经安稳了，但是我内心还是充满了痛苦。\n自身学历过低。公司里的同事，除了个别一两个学历一般意外，其余都是学校优于我，或者学历高于我的人。同学聚会的时候，大家也都纷纷出国深造。这让我显得十分难堪。尽管大家会说「你这个已经很好了」，但是以后呢？他们毕业之后是什么样呢？这个大环境下，本科生后续成长是很艰难的吧？\n发展方向无感。我就职的公司，老板喜欢往让我们凡事都研究透彻一点。这一点我是很赞赏的，但是当你研究的事情是你不喜欢的事情时，技术上的深挖反而成为了你生活中最痛苦的一件事。到公司实习的那段时期，因为怎么都解决不掉工作中发现的一个问题，往下挖也无迹可寻，生活一下子就压抑了起来，害怕去公司，害怕面对公司里的同事。以前总觉得电视里，主人公说自己被事情整的头晕头疼，是一件夸大的修辞方式，但是亲身经历过之后，才知道，艺术确实是源于生活。曾一度以为自己要抑郁，吓得父母轮番给我打电话谈心，以至于最后不得不到北京来看望我。现在想起来，那个时候也就已经担心起未来了吧。\n个人成长受限。自己来公司一段时间了，但是提升并不明显。想起来找工作面试的时候，自己关心更多的是待遇问题。犹记的有两段面试，都是在确定给offer之后，一位面试官对我说「第一份工作一定要自己喜欢，这才是最重要的」，另一位则是觉得「你应该去读研的」。但是当时的我都不以为意，现在想想，也需是他们也经历了这样一个时期，才会好意提醒我吧。\n 我这个人笨，说不清楚 – 徒然喜欢你 \n有些道理，或许没有经历过，就怎么也弄不懂，总觉得自己和别人不一样，等真正经历了，才会对当初的所作所为追悔莫及。\n申请 有了前面的经历，自己总算是决定重返校园，申请学校。因为身体上的因素，只申请了HK和新加坡的学校。\n说来也不知道我是幸运还是不幸。若是大三就开始申请，我现在大抵已经在HK读书了。但是19年的动荡，加上现在20年初的新冠病毒，让在HK的内陆学子，基本上都是在上网课了，收效甚微。而我尽管浪费了一年，倒也没有经历19年这一遭。\n目前HK申请的都拿到了offer，新加坡的倒是还没出结果。如果可以的话，最后大概率还是去后者吧。\n担忧 今年1月份的时候，我重新翻看了Morris的博客，发现他也许久未更新了，6号更新的一篇文章，大抵是和我相似的想法。也不知道他现在如何，工作是否顺心？有没有下定决心回去读书呢？希望他也能顺利吧。\n至于自己，刚开始申请的时候，一直在犹豫申请硕士还是博士，但终究还是无法下定决心直接申请博士。最近浏览网站，看到大家谈论自己博士毕业后的生活，联系起自己的身体，突然又冒出读博的想法了。这样犹豫不觉得我，也不知道改如何是好。想到之前找老师要推荐信的时候，他建议我先读研再决定，我觉得我还是该听取一下别人的意见吧，现在先努力地不去想这件事情。\n另外就是身体因素了，选择离家近的地方，也就是因为这个。目前还不知道去新加坡能否保证自己身体不出问题，还是比较烦的。\n「自己究竟想去做什么呢？自己想成为一个什么样的人呢？」\n这听起来像是给小朋友的问题，但是往往大人也无法搞清楚这个问题的答案啊。我们又有什么资格去问别人呢？\n 我已经等得够久了，你也该告诉我了吧 – 徒然喜欢你 \n自己的将来还会继续后悔下去吗？\n我希望是不会的吧。\n","date":"2020-02-19T00:00:00Z","image":"https://yuukidach.github.io/p/%E5%AF%B9%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%9B%B0%E6%83%91/%E5%AF%B9%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%9B%B0%E6%83%91-0_hudf79e89601825aa0295c04be598f8691_160907_120x120_fill_q75_box_smart1.jpg","permalink":"https://yuukidach.github.io/p/%E5%AF%B9%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%9B%B0%E6%83%91/","title":"对于未来的困惑"},{"content":"Background NOTE: This article is from chapter 7.2 in Hackers' Delight. I write this post because:\n To have a better understanding of the algorithm Need to apply it in a similar situation  Resources sometimes can be scarce in MCU. We may tend to use as little resources as possible and do calculations as fast as we could when the performance of MCU just barely meets our demands.\nBesides when talking about calculations in MCU, many people would think about bit operation. For example, in normal C program, we will write:\nint a = 8 / 2; However, for program running in MCU, people usually write:\nint32_t a = 8 \u0026gt;\u0026gt; 1; Because the bit operation is faster than arithmetic operation in most situations.\nNow cames the problem:\nHow can we shuffle bits efficiently?\nExample Suppose we need to shuffle a 32-bit word:\nabcd efgh ijkl mnop ABCD EFGH IJKL MNOP into\naAbB cCdD eEfF gGhH iIjJ kKlL mMnN oOpP Step 1 To solve to problem, we can do shuffles like:\nabcd efgh ijkl mnop ABCD EFGH IJKL MNOP abcd efgh ABCD EFGH ijkl mnop IJKL MNOP abcd ABCD efgh EFGH ijkl IJKL mnop MNOP abAB cdCD efEF ghGH ijIJ klKL mnMN opOP aAbB cCdD eEfF gGhH iIjJ kKlL mMnN oOpP These operations can be done with basic RISC instructions in log2(w/2) steps. w is the how many bits the word has. In this example, w = 32.\nx = (x \u0026amp; 0x0000ff00) \u0026lt;\u0026lt; 8 | (x \u0026gt;\u0026gt; 8) \u0026amp; 0x0000ff00 | x \u0026amp; 0xff0000ff; x = (x \u0026amp; 0x00f000f0) \u0026lt;\u0026lt; 4 | (x \u0026gt;\u0026gt; 4) \u0026amp; 0x00f000f0 | x \u0026amp; 0xf00ff00f; x = (x \u0026amp; 0x0c0c0c0c) \u0026lt;\u0026lt; 2 | (x \u0026gt;\u0026gt; 2) \u0026amp; 0x0c0c0c0c | x \u0026amp; 0xc3c3c3c3; x = (x \u0026amp; 0x22222222) \u0026lt;\u0026lt; 1 | (x \u0026gt;\u0026gt; 1) \u0026amp; 0x22222222 | x \u0026amp; 9999999999; Step 2 The code above seems quit efficient. But let\u0026rsquo;s think about how to exchange 2 variables value with XOR:\na = a ^ b; b = a ^ b; a = a ^ b; You see, by using XOR，the exchange becomes much more easier, can we apply the similar mathod to the code above?\nt = (x ^ (x \u0026gt;\u0026gt; 8)) \u0026amp; 0x0000ff00; x = x ^ t ^ (t \u0026lt;\u0026lt; 8); t = (x ^ (x \u0026gt;\u0026gt; 4)) \u0026amp; 0x00f000f0; x = x ^ t ^ (t \u0026lt;\u0026lt; 4); t = (x ^ (x \u0026gt;\u0026gt; 2)) \u0026amp; 0x0c0c0c0c; x = x ^ t ^ (t \u0026lt;\u0026lt; 2); t = (x ^ (x \u0026gt;\u0026gt; 1)) \u0026amp; 0x22222222; x = x ^ t ^ (t \u0026lt;\u0026lt; 1); Here is an interesting trick: To unshuffle the word, we could simply perform the swaps in reverse order\nt = (x ^ (x \u0026gt;\u0026gt; 1)) \u0026amp; 0x22222222; x = x ^ t ^ (t \u0026lt;\u0026lt; 1); t = (x ^ (x \u0026gt;\u0026gt; 2)) \u0026amp; 0x0c0c0c0c; x = x ^ t ^ (t \u0026lt;\u0026lt; 2); t = (x ^ (x \u0026gt;\u0026gt; 4)) \u0026amp; 0x00f000f0; x = x ^ t ^ (t \u0026lt;\u0026lt; 4); t = (x ^ (x \u0026gt;\u0026gt; 8)) \u0026amp; 0x0000ff00; x = x ^ t ^ (t \u0026lt;\u0026lt; 8); Bundle Here comes another question:\nShuffle\n0000 0000 0000 0000 ABCD EFGH IJKL MNOP to\n0A0B 0C0D 0E0F 0G0H 0I0J 0K0L 0M0N 0O0P With the knowledge above, this becames easy to do:\nx = ((x \u0026amp; 0xff00) \u0026lt;\u0026lt; 8) | (x \u0026amp; 0x00ff); x = ((x \u0026lt;\u0026lt; 4) | x) \u0026amp; 0x0f0f0f0f; x = ((x \u0026lt;\u0026lt; 2) | x) \u0026amp; 0x33333333; x = ((x \u0026lt;\u0026lt; 1) | x) \u0026amp; 0x55555555; To unshuffle\nx = x \u0026amp; 0x55555555; x = ((x \u0026gt;\u0026gt; 1) | x) \u0026amp; 0x33333333; x = ((x \u0026gt;\u0026gt; 2) | x) \u0026amp; 0x0F0F0F0F; x = ((x \u0026gt;\u0026gt; 4) | x) \u0026amp; 0x00FF00FF; x = ((x \u0026gt;\u0026gt; 8) | x) \u0026amp; 0x0000FFFF; ","date":"2019-08-12T09:44:44Z","permalink":"https://yuukidach.github.io/p/shuffling-bits/","title":"Shuffling Bits"},{"content":"Abstract In order to manage our project easily, we may tend to make for help. Usually, our projects will contians many subdirectories. So writing a makefile which can always compile our projects successfully when our project add, delete or modify some sub-dirs is quite important.\nBackground Take my private projects kmusb for example.\nIt file structure is like:\n. ├── README.md ├── arg_parser │ ├── arg_parser.c │ └── arg_parser.h ├── bin ├── data ├── kmusb.c ├── kmusb.h ├── makefile ├── obj ├── semihost │ ├── usb_semihost.c │ └── usb_semihost.h ├── virtual_com.c └── virtual_com.h I know the structure is awful. But let\u0026rsquo;s forget about it first, since our final goal is to write a universal makefile that can compile our project, no matter what file structure they have.\nFor the above project:\n main function is contianed in kmsub.c arg_parser/, semihost/are 2 directories that we write our code in them bin/ contains the output file obj/ contains all *.obj files and list them just like *.c files in the project. data/ is a folder that we store the data created when the program is running  Practice Practice 1 - Write All Targets Directly To write a most simple makefile, we can code like:\nTARGET = kmusb OUTDIR = ./bin DATADIR = ./data DIR_INC = ./semihost DIR_OBJ = ./obj CC = gcc objects = kmusb.o usb_5411x.o .PHONY: clean $(TARGET): clean $(objects) $(CC) -o $(OUTDIR)/$(TARGET) $(objects) kmusb.o: kmusb.c ./semihost/usb_semihost.h ./arg_parser/arg_parser.h $(CC) -I./semihost -I./arg_paser -c kmusb.c virtual_com.o: virtual_com.c virutual_com.h $(CC) -c virtual_com.c arg_parser.o: ./arg_parser/arg_parser.c ./arg_parser/arg_parser.h $(CC) -c ./arg_parser/arg_parser.c usb_semihost.o: ./semihost/usb_semihost.c ./semihost/usb_semihost.h $(CC) -c ./semihost/usb_semihost.c clean: rm -rf $(OUTDIR)/* $(DATADIR)/* *.o We write all the targets directly.\n .PHONY: A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request.\nThere are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance. [1]\n Pracetice 2 - Use variables It\u0026rsquo;s unconvinient to write all the target directly. If we modify our project later, we need to change a lot in the makefile. Just like the variable CC, we can also define varibles to store the subfolders.\nTARGET = kmusb CC = gcc CFLAGS = -g OUTDIR = ./bin DATADIR = ./data SUBDIR = semihost stream arg_parser DIR_OBJ = ./obj INCS = $(wildcard *.h $(foreach fd, $(SUBDIR), $(fd)/*.h)) SRCS = $(wildcard *.c $(foreach fd, $(SUBDIR), $(fd)/*.c)) NODIR_SRC = $(notdir $(SRCS)) OBJS = $(addprefix $(DIR_OBJ)/, $(SRCS:c=o)) # obj/xxx.o obj/folder/xxx .o INC_DIRS = $(addprefix -I, $(SUBDIR)) .PHONY: clean echoes $(TARGET): $(OBJS) $(CC) -o $(OUTDIR)/$@ $(OBJS) $(DIR_OBJ)/%.o: %.c $(INCS) mkdir -p $(@D) $(CC) -o $@ -c $\u0026lt; $(CFLAGS) $(INC_DIRS) clean: rm -rf $(OUTDIR)/* $(DATADIR)/* $(DIR_OBJ)/* echoes: @echo \u0026#34;INC files: $(INCS)\u0026#34; @echo \u0026#34;SRC files: $(SRCS)\u0026#34; @echo \u0026#34;OBJ files: $(OBJS)\u0026#34;  foreach: It causes one piece of text to be used repeatedly, each time with a different substitution performed on it. It resembles the for command in the shell sh and the foreach command in the C-shell csh.[2]\n Systax: $(foreach var,list,text)  $(@D): automatic variables. The directory part of the file name of the target, with the trailing slash removed. If the value of $@ is dir/foo.o then $(@D) is dir. This value is . if $@ does not contain a slash.\n Here we add a variable SUBDIR and add our subfolders in it. Then we can use make syntax like wildcard, foreachand so on to get all *.c and *.h file in the project. As for the obj/ folder, to better maintain all the *.obj, we will create folders with the same name as the subfolders in the projects under obj/.\nBesides, we add a target echoes to help us debug our makefile.\nNow, our makefile can compile the projects with subfolders easily. Just change the contents in SUBDIR.\nPractice 3 - Complete the makefile From above actions, we wrote a makefile that can adapt to various of projects. This part just some small modification to make our makefile better to look.\nTARGET = kmusb CC = gcc CFLAGS = -g OUTDIR = ./bin DATADIR = ./data SUBDIR = semihost stream arg_parser DIR_OBJ = ./obj INCS = $(wildcard *.h $(foreach fd, $(SUBDIR), $(fd)/*.h)) SRCS = $(wildcard *.c $(foreach fd, $(SUBDIR), $(fd)/*.c)) NODIR_SRC = $(notdir $(SRCS)) OBJS = $(addprefix $(DIR_OBJ)/, $(SRCS:c=o)) # obj/xxx.o obj/folder/xxx .o INC_DIRS = -I./ $(addprefix -I, $(SUBDIR)) LIBS = -largp LIB_DIRS = -L/usr/local/Cellar/argp-standalone/1.3/lib PHONY := $(TARGET) $(TARGET): $(OBJS) $(CC) -o $(OUTDIR)/$@ $(OBJS) $(LIB_DIRS) $(LIBS) $(DIR_OBJ)/%.o: %.c $(INCS) mkdir -p $(@D) $(CC) -o $@ $(CFLAGS) -c $\u0026lt; $(INC_DIRS) PHONY += clean clean: rm -rf $(OUTDIR)/* $(DATADIR)/* $(DIR_OBJ)/* PHONY += echoes echoes: @echo \u0026#34;INC files: $(INCS)\u0026#34; @echo \u0026#34;SRC files: $(SRCS)\u0026#34; @echo \u0026#34;OBJ files: $(OBJS)\u0026#34; @echo \u0026#34;LIB files: $(LIBS)\u0026#34; @echo \u0026#34;INC DIR: $(INC_DIRS)\u0026#34; @echo \u0026#34;LIB DIR: $(LIB_DIRS)\u0026#34; .PHONY = $(PHONY) Let\u0026rsquo;s leave alone the include library I added, since our main goal is to write a makefile to complie projects with subfolders. This makefile is copied from my projects.\nYou see, I adjust the way to write .PHONY.\nThis is a trick that I got from busybox. We add contents to the .PHONY wehen we write a new target is easier to maintain the makefile when it grows bigger and bigger.\nReferences  Phony Targets The foreach Function Automatic Variables busybox GitHub repo Automatic Directory Creation in Make  ","date":"2019-08-05T00:00:00Z","permalink":"https://yuukidach.github.io/p/makefile-for-projects-with-subdirectories/","title":"Makefile for Projects with Subdirectories"},{"content":"测试目标 配置LPC55S69 EVK所带的高速USB作为功能设备，测试其最快速率能达到多少，用于验证后续的开发。\nLPC55S69配置 LPC55S69是一款基于ARM内核的双核MCU， 由两个Cortex-M33构成。其最高运行频率为100MHz。\n LPC55S69 EVK \n整个工程的准备工作如下：\n 选用CPU0作为默认的控制核心 配置MAIN_CLK为96MHz（为了使用高速USB口，CPU时钟频率不得低于60MHz） 给USB HS PHY上电 USB功能设备配置  配置功能设备，需要先使能host controller的时钟，以便进行USB配置 DEV_ENABLE置1，让一个端口表现为USB设备 清除USB1_HOST位，关闭host controller，降低能耗   USB时钟配置  USB PHY配置48MHz时钟 USB PHY以及对应SRAM时钟使能    传输测试 连接方式：LPC55S69 EVK \u0026lt;\u0026mdash;\u0026mdash;-USB 2.0 HS \u0026mdash;\u0026mdash;\u0026ndash;\u0026gt; MacBook\nCorex-M33 freq: 100MHz\n使用官方提供的SKD（v2.5.1），利用块传输（bulk transfer）。循环发送\nwhile (1) { USB_DeviceCdcAcmSend(s_cdcVcom.cdcAcmHandle, USB_CDC_VCOM_BULK_IN_ENDPOINT, tmp_buf, buf_len); } tmp_buf为buffer地址，buf_len是需要传送的数据长度\n使用上述方式发送数据，buf_len越长，发送USB发送速率越快，最快能到8MB/s左右，无传输错误发生。\n8MB/s的速率对于HS USB来说是明显偏低的。通过调整整个工程的优化等级，可以提高速率。将优化等级调整至-O1或者以上，USB的速率可以达到21MB/s，无传输错误发生。\n 测试结果 \n此外，如果MCU的时钟频率降低，USB的传输速率也会相应降低，通过USB分析仪观察后，可以发现是NAK的数量变多。\n结果分析 虽然最后通过增长buf_len，以及调整优化等级，可以使得高速USB口的速率在21MB/s左右。但是对于最高速率480Mbps的Hi-Speed USB来说，速率上还是有所欠缺。\n采用USB分析仪进行抓包分析  抓包分析 \n可以发现在进行数据传输的时候，USB发送了过多的NAK。测试中的USB传输，其发送NAK与发送有效数据的时间基本相同，可以做如下简单计算：\n由于一次有效的数据传输不光包含了数据本身，还包含了令牌包和握手包，因此有效数据在一次事务传输中的占比可以考虑为512/518。计算480Mbps下的理论传输速率为\n考虑到实际的损耗，21MB/s看起来就是一个可以接受的数据了。\n值得注意的是，由于MCU的时钟频率降低，NAK的数量会变多。而NAK的数量变多不外乎两种原因：\n USB device没有数据需要发送 USB device正忙，无法相应host的请求  MCU的时钟频率降低会导致NAK增多，也就说尽管整个测试工程只执行了USB搬运，但是MCU还是有大量的操作需要处理。结合优化后的USB速率会变高这一情况来看，USB工作在21MB/s的速率，极有可能是MCU的数据搬运不及时，没有搬运到USB发送数据的缓存当中。\n可以从软件上考虑对USB速率的优化。\n参考  LPCXpresso55S69 Development Board (Rev. 1.2 — 25 April 2019) LPC55S6x User manual (Rev. 1.2 — 3 May 2019)  ","date":"2019-05-23T00:00:00Z","permalink":"https://yuukidach.github.io/p/lpc55s69-usb-%E9%AB%98%E9%80%9F%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E4%B8%80/","title":"LPC55S69 USB 高速模式测试（一）"},{"content":"很久没更新博客了。从最开始饶有兴致地搭建，到现在，愈发地发现自己能说的东西变得少了，以至于都将近荒废了这个地方。\n不是说自己变得慵懒，而是近来常常有种感觉，觉得自身的知识储备太匮乏了。与其用无意义地更新博客来达到一种自我满足的状态，倒不如静下心来好好的提升自我，做点有意义的事情。\n写一个自己的记账软件Ucount是出于对现有记账软件各种冗余功能和广告的不满。本来寒假的时候，就应该完成记编写。但是由于自己的资料准备问题，一直到了开学都已经过去一段时间了，才真正开始着手。\n最基本的功能编写了两三天的样子，后来花了十多天一直优化到现在，已经将所有的基础功能都更新完毕，也算是把自己定下的诺言给实现了。\n接下来也就不会再去深究安卓了，毕竟这不是自己想要坚持的方向。要赶紧回到正轨才行，OJ的练习，Linux的学习还是要继续下去的。\n稍微写了一点文字，虽然条理十分还乱，但也算是对自己完成一个目标之后的记录吧。\n","date":"2017-03-27T00:00:00Z","permalink":"https://yuukidach.github.io/p/ucount-%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/","title":"Ucount 完结之后"},{"content":"还是老样子，先上GitHub：Yuuki_Dach\u0026rsquo;s GitHub\n上次自己写了一个字幕批量重命名的脚本，结果发现在处理字幕文件的时候还是存在bug（毕竟是自己一边看番，一边测试+改进，没有特意的去找测试样本）\n首先是关于视频文件的查找，原来的查找方式十分简单，也没有使用正则表达式，只是粗略的查找了一下，这里利用find的功能，使得查找更加精确。\n在处理字幕文件的时候，也有问题。for循环在利用find查找的时候，会把空格视为一个间断。因此，这里利用IFS，把find指令找到的文件名当作一整块来处理就行了。\n另外，字幕文件的后缀名有多种，而且利用正则表达式来匹配的方式也有很多，这里就留到下次再来处理。\n#! /bin/bash echo \u0026quot;Before the opration stars, please make sure you have been in the right folder!\u0026quot; while true; do read -p \u0026quot;Do you want to continue? y/n \u0026quot; yn case ${yn} in [Yy]* ) break;; [Nn]* ) exit;; * ) echo \u0026quot;Please answer yes or no.\u0026quot;;; esac done echo \u0026quot;What is the videos' extension name?\u0026quot; read video_extension_name echo \u0026quot;How many episodes does it have?\u0026quot; read total_video_episode_num echo \u0026quot;These files were renamed successfully:\u0026quot; for target_episode in `seq -w 1 ${total_video_episode_num}` do target_video=`find -regex \u0026quot;.*[^0-9]?${target_episode}[^0-9]?.*${video_extension_name}\u0026quot;` target_video=${target_video%${video_extension_name}} target_video=${target_video:2} echo \u0026quot;${target_video}\u0026quot; find -regex \u0026quot;.*[^0-9\\.i]${target_episode}[^0-9\\.P].*ass\u0026quot; | while IFS=\u0026quot; \u0026quot; read target_sub do echo \u0026quot;${target_sub}\u0026quot; rename \u0026quot;s/.*[^0-9\\.i]${target_episode}[^0-9\\.P].*\\./${target_video}/\u0026quot; \u0026quot;${target_sub}\u0026quot; done done ","date":"2017-02-12T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E8%84%9A%E6%9C%AC%E4%BA%8C-linux/","title":"字幕文件批量重命名脚本（二） —— Linux"},{"content":"现在更新博客的速度大大降低了，主要还是认为把自己做的题目传上来对别人和自己的帮助都不是很大。行，废话少说，我们切入正题吧。\n刚刚闲来无事，想到之前看番的时候，有些另外下载的字幕会和视频名字不匹配，给观看带来不必要的麻烦，所以动手写了一个比较粗糙的字幕文件批量重命名的脚本。\n代码已经上传到Yuuki_Dach\u0026rsquo;s GitHub，后续还会慢慢添加别的脚本。\n其实代码并不复杂，就是先确定文件路径，然后手动输入视频文件后缀名和集数，然后开始运行就行了，这里还是把代码也贴一下，方便大家吧\n#! /bin/bash  echo \u0026#34;Before the opration stars, please make sure you have been in the right folder!\u0026#34; while true; do read -p \u0026#34;Do you want to continue? y/n\u0026#34; yn case ${yn} in [Yy]* ) break;; [Nn]* ) exit;; * ) echo \u0026#34;Please answer yes or no.\u0026#34;;; esac done echo \u0026#34;What is the videos\u0026#39; extension name?\u0026#34; read video_extension_name echo \u0026#34;How many episodes does it have?\u0026#34; read total_video_episode_num echo \u0026#34;These files were renamed successfully:\u0026#34; for target_episode in `seq -w 1 ${total_video_episode_num}` do target_video=(*[^0-9]${target_episode}[^0-9]*${video_extension_name}) target_video=${target_video%${video_extension_name}} for target_srt in `find -regex \u0026#34;.*[^0-9]?${target_episode}[^0-9]?.*srt\u0026#34;` do echo ${target_srt} rename \u0026#34;s/.*[^0-9]?${target_episode}[^0-9]?.*?\\./${target_video}/\u0026#34; ${target_srt} done done ","date":"2017-02-05T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E8%84%9A%E6%9C%AC-linux/","title":"字幕文件批量重命名脚本 —— Linux"},{"content":"从开始准备学校“驭远杯”比赛，到现在比赛结束，自己和自己的队伍以初赛和决赛都是第一名的成绩成功夺冠，不知不觉已经过去一段时间了。这段时间里，没有和往常一样定期的刷OJ，也少了一定的闲暇时光。基本每天都是在白天上课和写作业，晚上准备比赛这样的节奏中度过。物理实验什么的都停了好久，差点选不够了_(:зゝ∠)_\n虽然忙碌，但是最后的结果还是很不错的，也证明了我们这么多天的辛苦没有白费吧。这里还是简单记录一下自己的参赛过程。\n先附上自己的代码: Controller of Mars exploration\n以及视频链接： Youtobe、Bilibili\n比赛整体分为三个阶段，第一个阶段是对燃料块（方块）和仪器（圆球）的抓取，至少要抓取一个燃料块，抓取两个会有时间的附加分，这一阶段为手动控制。第二阶段开始为自动控制，要求小车能够对亮起的灯塔进行搜寻并触发相应的开关以关闭灯塔。触碰完四个灯塔后方可进入到下一阶段。第三阶段就是上高台了，小车需要自己调整好角度，成功登上高台，并且把仪器（球）放下。\n整个驭远比赛的赛制则分为初赛、晋级赛和决赛。初赛选取4组队伍直接进入决赛，5-12名则进入晋级赛，并从中再挑选四组。\n我们组在最初确定车身形状时想要让小车能够灵活的转弯，便试用了两轮驱动的圆形底盘。而后，在实际使用中，发现由于电机的不稳定性以及两轮驱动自身的缺陷，车在直线行进时会发生较大漂移。遂采用四轮驱动的方形底盘。\n在团队分工时，由于队伍中有三人都可独立完成任务，直接把项目按照比赛流程划分为三个部分，以时间充裕性直接分配任务。对于重合模块，直接由前一部分提供API，如电机驱动，二三阶段的底盘驱动直接调用一阶段提供的API。\n第1阶段主要问题为，机械臂的安装与控制。我们最初的方案中，机械臂的运动较为复杂，稳定性差。后在调试的过程中，受其他组的启发，将机械由4自由度简化为2自由度，使机械臂的运动更为简单稳定。\n第2阶段中，我们在小车的前后各安装了一个红外复眼，以此实现了在第二场地中的任意位置对开启状态灯塔的定位。以红外复眼为判据，到达合适的位置后，分析红外复眼接受强度的数据，引导小车撞向灯塔。在实际调试过程中，发现踩灯后小车的回位稳定性较差。为解决这一问题，为小车上增加了电子陀螺仪模块，实现了较为准确的姿态控制。但只依靠红外复眼无法找到较为合适的转弯触灯位置，于是又在小车的左右各装了一个红外接收灯（连接到寻迹模块），用于转弯的判定。\n当靠近2区域进出口的灯塔亮起时，小车会因过于靠近进出口而卡住，或回位时无法检测到黑线（黑线长度限制）。便在前后加装灰度传感器，用以避免小车转弯时过于靠近进出口。至此，2阶段完美完成。\n第3阶段相对来说是比较简单的，在使用电子陀螺仪之前，我们在小车的正前方对称安装了3个不同朝向的超声波测距模块，以超声测距为主要依据，最终以非网格路径登上高台。然而，这样做的话，依靠超声测距调整小车时会消耗过多的时间，而且稳定性也欠佳。使用电子陀螺仪后，第3阶段的方案也随之改变。路径由不规则的，变为每次只转90度的网格路径，用陀螺仪来精确控制转角，3个超声测距也精简为1个用于辅助。这样虽然看似路径变长了，基本不需要复杂的调整，更加的稳定简洁。\n比赛过程中也看到了很多新奇的创意，比如直接用空心杯来吸取泡沫，利用胶带直接粘（这个看起来很低端但是确实高效啊！只是物快放置的时候容易GG）等等。同时也见识了一些奇妙的状况，包括灯塔被“巨型”车体怼坏（想想都可怕= =）、成功冲上对方高地之类的。\n嘛，就这么多吧。毕竟还在考期…… ","date":"2017-01-05T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E9%A9%AD%E8%BF%9C%E8%B7%AF%E4%B8%8Astm32%E6%AF%94%E8%B5%9B%E4%BD%9C%E5%93%81%E7%9A%84%E8%AE%B0%E5%BD%95/","title":"驭远路上——STM32比赛作品的记录"},{"content":"更新了Ubuntu 16.10之后，发现有线连接模块消失了，于是又和以前一样对r8168进行编译安装。具体的方法请参考我的另一篇文章: Ubuntu以太网已断开的解决办法\n结果发现在 \u0026lsquo;make clean modules\u0026rsquo; 这一步居然出错了。错误信息如下：\n/home/user/download/r8168-8.042.00/src/r8168_n.c: In function ‘rtl8168_init_one’: /home/user/download/r8168-8.042.00/src/r8168_n.c:22799:28: error: ‘struct net_device’ has no member named ‘gso_min_segs’; did you mean ‘gso_max_segs’? dev-\u0026gt;gso_min_segs = NIC_MIN_PHYS_BUF_COUNT; ^~ /home/yuukidach/下载/r8168-8.042.00/src/r8168_n.c:22807:28: error: ‘struct net_device’ has no member named ‘gso_min_segs’; did you mean ‘gso_max_segs’? dev-\u0026gt;gso_min_segs = NIC_MIN_PHYS_BUF_COUNT; ^~ /home/user/download/r8168-8.042.00/src/r8168_n.c: In function ‘rtl8168_start_xmit’: /home/user/download/r8168-8.042.00/src/r8168_n.c:24969:12: error: ‘struct net_device’ has no member named ‘trans_start’; did you mean ‘mem_start’? dev-\u0026gt;trans_start = jiffies; 其实这个错误是因为r8168的版本和Ubuntu版本不配对导致的，只要去官网下载新的r8168的版本就行了。\n","date":"2016-10-15T00:00:00Z","permalink":"https://yuukidach.github.io/p/ubuntu-r8168%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"Ubuntu r8168模块编译错误的解决办法"},{"content":"Problem Here is the: problem link\nSolution 这道题目一开始没有用f[][]来标记是否重复，导致WA了一次，后来就加上去了。另外，在处理人名时，虽然实例输入里，上司和下属名字出现是有先后的，但是提交之后，系统的测试数据貌似不一定是这样，所以要先判断是否出现，没出现就用cnt加1再赋值\n递归的思路还是不难的，选了上司，那么直属员工就不选，用d[][0]表示不选;没选的话就可以选直属员工，也可以不选，分别是d[][1]和d[][0]\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; #define G sons[b][i] const int maxn = 205; int n, res, yn, d[maxn][2], f[maxn][2]; char c1[maxn], c2[maxn]; map\u0026lt;string, int\u0026gt; p; vector\u0026lt;int\u0026gt; sons[maxn]; int dp(int b,int y) { int\u0026amp; ans = d[b][y]; if (ans != -1) return ans; int k = sons[b].size(); if(!k) {f[b][y] = 1; return ans = y;} int mark = 1; if(y) { for(int i = 0; i \u0026lt; k; ++i) { ans += dp(G,0); if(!f[G][0]) mark = 0; } } else { for(int i = 0; i \u0026lt; k; ++i) { if(dp(G, 0) == dp(G, 1)) {mark = 0; ans += d[G][0];} else if(d[G][0] \u0026gt; d[G][1]) { if(!f[G][0]) mark = 0; ans += d[G][0]; } else { if(!f[G][1]) mark = 0; ans += d[G][1]; } } } f[b][y] = mark; return ans += y+1; } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { p.clear(); memset(d, 0xff, sizeof(d)); for(int i = 0;i \u0026lt; n; ++i) sons[i].clear(); cin \u0026gt;\u0026gt; c2; p[c2] = 0; int cnt = 0; for(int i = 1;i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; c2; if(!p.count(c1)) p[c1] = ++cnt; if(!p.count(c2)) p[c2] = ++cnt; sons[p[c2]].push_back(p[c1]); } if(dp(0,0) \u0026gt; dp(0,1)) {res = d[0][0]; yn = f[0][0];} else if(d[0][0] == d[0][1]) {res = d[0][0]; yn = 0;} else {res = d[0][1]; yn = f[0][1];} cout \u0026lt;\u0026lt; res; if(yn) cout \u0026lt;\u0026lt; \u0026#34; Yes\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34; No\\n\u0026#34;; } return 0; } ","date":"2016-09-30T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1220-party-at-hali-bula/","title":"UVa OJ 1220 - Party at Hali-Bula"},{"content":"Problem A couple of years ago, a new world wide crisis started, leaving many people with economical problems. Some workers of a particular company are trying to ask for an increase in their salaries.\nThe company has a strict hierarchy, in which each employee has exactly one direct boss, with the exception of the owner of the company that has no boss. Employees that are not bosses of any other employee are called workers. The rest of the employees and the owner are called bosses. To ask for a salary increase, a worker should file a petition to his direct boss. Of course, each boss is encouraged to try to make their subordinates happy with their current income, making the company’s profit as high as possible. However, when at least T percent of its direct subordinates have filed a petition, that boss will be pressured and have no choice but to file a petition himself to his own direct boss. Each boss files at most 1 petition to his own direct boss, regardless on how many of his subordinates filed him a petition. A boss only accounts his direct subordinates (the ones that filed him a petition and the ones that didn’t) to calculate the pressure percentage.\nNote that a boss can have both workers and bosses as direct subordinates at the same time. Such a boss may receive petitions from both kinds of employees, and each direct subordinate, regardless of its kind, will be accounted as 1 when checking the pressure percentage.\nWhen a petition file gets all the way up to the owner of the company, all salaries are increased. The workers’ union is desperately trying to make that happen, so they need to convince many workers to file a petition to their direct boss.\nGiven the company’s hierarchy and the parameter T, you have to find out the minimum number of workers that have to file a petition in order to make the owner receive a petition.\nInput There are several test cases. The input for each test case is given in exactly two lines. The first line contains two integers N and T (1 ≤ N ≤ 105 , 1 ≤ T ≤ 100), separated by a single space. N indicates the number of employees of the company (not counting the owner) and T is the parameter described above. Each of the employees is identified by an integer between 1 and N. The owner is identified by the number 0. The second line contains a list of integers separated by single spaces. The integer Bi , at position i on this list (starting from 1), indicates the identification of the direct boss of employee i (0 ≤ Bi ≤ i − 1).\nThe last test case is followed by a line containing two zeros separated by a single space.\nOutput For each test case output a single line containing a single integer with the minimum number of workers that need to file a petition in order to get the owner of the company to receive a petition.\nSample Input 3 100 0 0 0 3 50 0 0 0 14 60 0 0 1 1 2 2 2 5 7 5 7 5 7 5 0 0 Sample Output 3 2 5 Solution 从老板开始，先询问第一层的员工每个人如果要签字，需要各自多少员工签字，然后第二层，第三层……直到最后一层\n接着排序，把需要最少的排前面，相加即可\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int maxn = 1e5+2; int n,t; vector\u0026lt;int\u0026gt; b[maxn]; int dp(int x) { if (b[x].empty()) return 1; vector\u0026lt;int\u0026gt; son; int len = b[x].size(); for (int i = 0; i \u0026lt; len; ++i) son.push_back(dp(b[x][i])); sort(son.begin(), son.end()); int ans = 0, bor = (len*t-1)/100+1; for (int i = 0; i \u0026lt; bor; ++i) ans += son[i]; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t \u0026amp;\u0026amp; n) { int tmp; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; tmp; b[tmp].push_back(i); } cout \u0026lt;\u0026lt; dp(0) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (int i = 0; i \u0026lt;= n; ++i) b[i].clear(); } return 0; } ","date":"2016-09-29T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-12186-another-crisis/","title":"UVa OJ 12186 - Another Crisis"},{"content":"Problem Here is the: problem link\nSolution 这道题目一开始用递归做，但是时间比较长，于是花了比较长的时间去想应该怎么才能转化成递推\n这道题目用d[i][j]来表示从i点切割到j点中所含的面积最大的三角形中，最小的那个\n这里用了三个循环，第一层是确定分割时跨越的点数，第二层是起点，第三层就是起点和终点中任意取一点分割。同时还要注意分割时会不会有点卡在中间导致实际上不能被分割的情况\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;iomanip\u0026gt;using namespace std; const int maxn = 55; int n, cas; double x[maxn], y[maxn], d[maxn][maxn]; double cntArea(int a, int b, int c) { return fabs((x[b]-x[a])*(y[c]-y[a])-(y[b]-y[a])*(x[c]-x[a]))/2; } bool isOK(int x,int y, int z) { double s = cntArea(x, y, z); for (int i = 0; i \u0026lt; n; ++i) { if (i == x || i == y || i ==z) continue; double tmp = cntArea(x,y,i)+cntArea(x,z,i)+cntArea(y,z,i); if (fabs(s-tmp) \u0026lt; 1e-6) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  cin \u0026gt;\u0026gt; cas; while(cas--) { cin \u0026gt;\u0026gt; n; double ans = 0x3f3f3f3f; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; for (int i = 2; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { int a = (i+j) % n; d[j][a] = 0x3f3f3f3f; for (int k = (j+1)%n; k != a; k = (k+1)%n) { if (!isOK(j,k,a)) continue; d[j][a] = min(d[j][a], max(max(d[j][k],d[k][a]),cntArea(j,k,a))); } if (i == n-1) ans = min(ans, d[j][a]); } } cout.setf(ios::fixed); cout \u0026lt;\u0026lt; setprecision(1) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-29T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1331-minimax-triangulation/","title":"UVa OJ 1331 - Minimax Triangulation"},{"content":"Problem You have to cut a wood stick into pieces. The most affordable company, The Analog Cutting Machinery, Inc. (ACM), charges money according to the length of the stick being cut. Their procedure of work requires that they only make one cut at a time.\nIt is easy to notice that different selections in the order of cutting can led to different prices. For example, consider a stick of length 10 meters that has to be cut at 2, 4 and 7 meters from one end. There are several choices. One can be cutting first at 2, then at 4, then at 7. This leads to a price of 10 + 8 + 6 = 24 because the first stick was of 10 meters, the resulting of 8 and the last one of 6. Another choice could be cutting at 4, then at 2, then at 7. This would lead to a price of 10 + 4 + 6 = 20, which is a better price.\nYour boss trusts your computer abilities to find out the minimum cost for cutting a given stick.\nInput The input will consist of several input cases. The first line of each test case will contain a positive number l that represents the length of the stick to be cut. You can assume l \u0026lt; 1000. The next line will contain the number n (n \u0026lt; 50) of cuts to be made.\nThe next line consists of n positive numbers ci (0 \u0026lt; ci \u0026lt; l) representing the places where the cuts have to be done, given in strictly increasing order.\nAn input case with l = 0 will represent the end of the input.\nOutput You have to print the cost of the optimal solution of the cutting problem, that is the minimum cost of cutting the given stick. Format the output as shown below.\nSample Input 100 3 25 50 75 10 4 4 5 7 8 0 Sample Output The minimum cutting is 200. The minimum cutting is 22. Solution 这道题目直接用d[i][j]存储i到j被切开的最小值，即可解决\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; const int INF = 0x3f3f3f3f; int l, n; int cut[55], d[55][55]; int dp(int x, int y) { int\u0026amp; ans = d[x][y]; if (ans != INF) return ans; if (y-x == 1) return 0; for (int i = x+1; i \u0026lt; y; ++i) ans = min(ans, dp(x, i)+dp(i, y)+cut[y]-cut[x]); return ans; } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while (cin \u0026gt;\u0026gt; l \u0026amp;\u0026amp; l) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; cut[i]; cut[n+1] = l; memset(d, 0x3f, sizeof(d)); cout \u0026lt;\u0026lt; \u0026#34;The minimum cutting is \u0026#34; \u0026lt;\u0026lt; dp(0, n+1) \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; } return 0; } ","date":"2016-09-27T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-10003-cutting-sticks/","title":"UVa OJ 10003 - Cutting Sticks"},{"content":"Problem Here is the prolem link\nSolution 这道题目要先处理好每个颜色的起止位置，不然会很不方便。用数组d[i][j]表示已经插入了第一个字符串的i个，第二个字符串的j个字母。递推的时候，只要发现还有字母没有用完，就加1\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int maxn = 5002; char n[maxn], m[maxn]; int cas, l1, l2; int begs[2][26], endz[2][26], d[maxn][maxn]; void findLetter(char a[], int l, int o) { for (int i = 1; i \u0026lt;= l; ++i) { if (!endz[o][a[i]-\u0026#39;A\u0026#39;]) begs[o][a[i]-\u0026#39;A\u0026#39;] = i; endz[o][a[i]-\u0026#39;A\u0026#39;] = i; } } int main() { ios::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  cin \u0026gt;\u0026gt; cas; while(cas--) { cin \u0026gt;\u0026gt; n+1 \u0026gt;\u0026gt; m+1; n[0] = m[0] = 0; memset(begs, 0x3f, sizeof(begs)); memset(endz, 0, sizeof(endz)); l1 = strlen(n+1); l2 = strlen(m+1); findLetter(n, l1, 0); findLetter(m, l2, 1); for (int i = 0; i \u0026lt;= l1; ++i) { for (int j = 0; j \u0026lt;= l2; ++j) { int num = 0, ans = 0x3f3f3f3f; for (int k = 0; k \u0026lt; 26; ++k) if ((i \u0026gt;= begs[0][k] || j \u0026gt;= begs[1][k]) \u0026amp;\u0026amp; (i \u0026lt; endz[0][k] || j \u0026lt; endz[1][k])) ++num; if (i) ans = min(d[i-1][j], ans); if (j) ans = min(ans, d[i][j-1]); d[i][j] = (ans==0x3f3f3f3f?0:ans) + num; } } cout \u0026lt;\u0026lt; d[l1][l2] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-27T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1625-color-length/","title":"UVa OJ 1625 - Color Length"},{"content":"Problem You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating. Now, you know the number of lamps and cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) and complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources and replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.\nInput Each case in the input begins with n (1 ≤ n ≤ 1000), denoting the number of categories. Each of the following n lines describes a category. A category is described by 4 integers - V (1 ≤ V ≤ 132000), the voltage rating, K (1 ≤ K ≤ 1000), the cost of a voltage source of this rating, C (1 ≤ C ≤ 10), the cost of a lamp of this rating and L (1 ≤ L ≤ 100), the number of lamps required in this category. The input terminates with a test case where n = 0. This case should not be processed.\nOutput For each test case, print the minimum possible cost to design the system.\nSample Input 3 100 500 10 20 120 600 8 16 220 400 7 18 0 Sample Output 778 Solution 这道题目一开始其实并没有看懂，不知道他到底要多少瓦灯泡去点亮大厅。后来发现灯泡数量其实是不变的，只要去更换不同的灯泡就行了。\n这里没用结构体或者类，而是直接用o[]来记录每种灯泡的排序，d[i]表示到i种灯泡为止，总共要花多少钱\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int maxn = 1001; int n; int v[maxn], k[maxn], l[maxn], a[maxn]; int d[maxn], o[maxn], s[maxn]; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; k[i] \u0026gt;\u0026gt; l[i] \u0026gt;\u0026gt; a[i]; o[i] = i; } sort(o+1, o+n+1, [](int a, int b){return v[a]\u0026lt;v[b];}); memset(d, 0x3f, sizeof(d)); d[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { s[i] = s[i-1] + a[o[i]]; for (int j = 0; j \u0026lt;= i; ++j) { d[i] = min(d[i], d[j]+(s[i]-s[j])*l[o[i]]+k[o[i]]); } } cout \u0026lt;\u0026lt; d[n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-25T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11400-lighting-system-design/","title":"UVa OJ 11400 - Lighting System Design"},{"content":"Problem Here is the: link\nSolution 先对字符串进行预处理，把回文字符串的长度全部记录下来，然后用DP对回文字符串的个数进行处理。最小个数=min(之前已经处理过的长度所含回文字符串的最小值+未处理的长度所含回文字符数的最小值)\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int maxn = 1005; char s[maxn]; int d[maxn], idx[maxn][maxn], cas; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  cin \u0026gt;\u0026gt; cas; while(cas--) { cin \u0026gt;\u0026gt; s+1; int n = strlen(s+1); memset(d, 0x3f, sizeof(d)); d[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { idx[i][i] = 1; for (int j = i+1; j \u0026lt;= n; ++j) { bool isOK = false; for (int k = 0; k \u0026lt; (j-i+1\u0026gt;\u0026gt;1); ++k) if (s[i+k] != s[j-k]) { idx[i][j] = j-i+1; isOK = true; break; } if (isOK) continue; idx[i][j] = 1; } } for (int i = 1; i \u0026lt;=n; ++i) { for (int j = 0; j \u0026lt;=i; ++j) { d[i] = min(d[i], d[j]+idx[j+1][i]); } } cout \u0026lt;\u0026lt; d[n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-25T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11584-partitioning-by-palindromes/","title":"UVa OJ 11584 - Partitioning by Palindromes"},{"content":"Problem Here is the: problem link\nSolutions 这道题目不难，但是要注意一下输出的格式，我因为输出格式的问题反复提交了好几次\n我们用dp[i][j]来表示(i,j)距离最后一列的距离。为了节省时间，用了一个Next[]数组来保存向右走的路径，避免反复取余造成的时间上的浪费。\n还有，记得不要用next和end，是关键字 =_=\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; int r, c, start, End; int Next[12]; int block[12][102], idx[12][102]; long dp[12][102]; int main(){ ios::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while(cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c) { memset(idx, 0, sizeof(idx)); memset(dp, 0, sizeof(dp)); for (int i = 1; i \u0026lt;= r; ++i) Next[i] = i; Next[r+1] = 1; Next[0] = r; for (int i = 1; i \u0026lt;= r; ++i) for (int j = 1; j \u0026lt;= c; ++j) cin \u0026gt;\u0026gt; block[i][j]; for (int j = c; j \u0026gt; 0; --j) { for (int i = 1; i \u0026lt;= r; ++i) { long tmp = 0x3f3f3f3f3f3f; for (int k = -1; k \u0026lt; 2; ++k) { long a = dp[Next[i+k]][j+1]+block[i][j]; if (a \u0026lt; tmp) { tmp = dp[i][j] = a; idx[i][j] = Next[i+k]; } else if (a == tmp) idx[i][j] = min(idx[i][j], Next[i+k]); } } } start = 1; long tmp, minh = dp[1][1]; for (int i = 2; i \u0026lt;= r; ++i) { tmp = dp[i][1]; if (tmp \u0026lt; minh) { start = i; minh = tmp; } } End = start; for(int j = 1; j \u0026lt; c; ++j) { cout \u0026lt;\u0026lt; End \u0026lt;\u0026lt; \u0026#39; \u0026#39;; End = idx[End][j]; } cout \u0026lt;\u0026lt; End \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; dp[start][1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-24T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-116-unidirectional-tsp/","title":"UVa OJ 116 - Unidirectional TSP"},{"content":"Problem Here is the: link\nSolution 这道题目一开始用时间作为一个大循环去进行递推，但是发现并不是很好判断歌曲是否有唱过，所以后来还是采用歌曲作为大循环，再以时间为小循环。不过记得要留出1s来给《劲歌金曲》\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; int T, n, t, cas, ans; int song[51], dp[9001]; long long lis[9001]; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t; memset(dp, 0x8f, sizeof(dp)); dp[0] = 0; ans = t-1; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; song[i]; for (int i = 0; i \u0026lt; n; ++i) for (int j = t-1; j \u0026gt;= song[i]; --j) dp[j] = max(dp[j], dp[j-song[i]]+1); for (int i = t-1; i \u0026gt;=0; --i) ans = dp[i]\u0026gt;dp[ans] ? i : ans; cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; dp[ans]+1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans+678 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-24T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-12563-jin-ge-jin-qu-hao/","title":"UVa OJ 12563 - Jin Ge Jin Qu hao"},{"content":"Problem John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi = \u0026lt; xi, yi \u0026gt; . John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x -coordinates.\nWrite a program that, given a set of n points in the plane, computes the shortest closed tour that connects the points according to John\u0026rsquo;s strategy.\nInput The program input is from a text file. Each data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the x coordinate. White spaces can occur freely in input. The input data are correct.\nOutput For each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result.\nNote: An input/output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their x and y coordinates. The second point, for example, has the x coordinate 2, and the y coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).\nSample Input 3 1 1 2 3 3 1 4 1 1 2 3 3 1 4 2 Sample Output 6.47 7.89 Solution Another DP problem.\nlen[i][j] represents the sum of the distance between destination and x[i],x[j].\n\u0026lsquo;std::setprecision()\u0026rsquo; can help us set the decimal precision to be used to format floating-point values on out put operations. And \u0026lsquo;std::cout.setf(ios::fixed)\u0026rsquo; makes cout display floating-point values in fixed point notation.\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;iomanip\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; const int maxn = 61; int n; double x[maxn], y[maxn]; double dist[maxn][maxn], len[maxn][maxn]; int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while(cin \u0026gt;\u0026gt; n) { for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) dist[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])); for (int i = n-2; i \u0026gt; 0; --i) { for (int j = 0; j \u0026lt; i; ++j) { if ( i == n-2) len[i][j] = dist[i][n-1] + dist[j][n-1]; else len[i][j] = min(len[i+1][j]+dist[i+1][i], len[i+1][i]+dist[i+1][j]); } } double ans = dist[1][0] + len[1][0]; cout.setf(ios::fixed); cout \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-23T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1347-tour/","title":"UVa OJ 1347 - Tour"},{"content":"std::ios_base::sync_with_stdio() 今天在做OJ的时候意外地发现printf和cout的输出顺序和代码顺序不一样，如下\nprintf(\u0026#34;Case Number %d: \u0026#34;, ++cas); if(takeTime[0][1] \u0026gt;= 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; else cout \u0026lt;\u0026lt; takeTime[0][1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 得到的输出却是\nimpossible impossible impossible Case Number 1: Case Number 2: Case Number 3: 后来仔细地看了看，才发现问题是出在ios_base::sync_with_stdio()这个函数上。\n这个函数当我们填入false的值时，相当于把C和C++的输入输出流解绑了，那么cout就能够拥有自己的缓冲区。如果我们去掉解绑的话，那么我们就会看到结果变得和我们预想的是一样了。\nCase Number 1: impossible Case Number 2: impossible Case Number 3: impossible 所以将C++和C的输入输出流同步，是一种比较安全的方式，不要滥用ios_base::sync_with_stdio()\ncin.tie() 还有一个值得一提的就是cin.tie().\n和sync_with_sdtio类似，cin.tie()也是为了让输入输出变得比较安全的方式。当我们填入NULL或者0解绑之后，对于\ncout \u0026lt;\u0026lt; \u0026#34;Enter name:\u0026#34;; cin \u0026gt;\u0026gt; name; 就会发现，是先输入，再输出\u0026rsquo;Enter name:'\n这是因为解绑了输入输出之后cout需要在缓冲区写入之后才能执行\n参考  Significance of ios_base::sync_with_stdio(false); cin.tie(NULL)  ","date":"2016-09-22T00:00:00Z","permalink":"https://yuukidach.github.io/p/stdios_basesync_with_stdio/","title":"std::ios_base::sync_with_stdio()"},{"content":"Problem The babylonians had n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.\nThey wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.\nYour job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks.\nInput The input file will contain one or more test cases. The first line of each test case contains an integer n, representing the number of different blocks in the following data set. The maximum value for n is 30.\nEach of the next n lines contains three integers representing the values xi , yi and zi.\nInput is terminated by a value of zero (0) for n.\nOutput ‘Case case: maximum height = height’\nSample Input 1 10 20 30 2 6 8 10 5 5 5 7 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 7 7 7 5 31 41 59 26 53 58 97 93 23 84 62 64 33 83 27 0 Sample Output Case 1: maximum height = 40 Case 2: maximum height = 21 Case 3: maximum height = 28 Case 4: maximum height = 342 Solution Use DP to solve this problem.\nFirst, save the height, length and width of each blocks in idx[][]. For Example, when we use idx[1][2], it means we choose No.2 block and its thrid line to be be height of the tower.\nAfter dealing with the statistics, we are coming to do the most important work of the programming \u0026ndash; listing the equation.\nIn my code, I use \u0026lsquo;the height of the block1 = max(the height of the block2 +length of block1)\u0026rsquo; as the equation.\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; int n, maxh, cas; int idx[31][3], idxh[31][3]; bool canBPiled(int x, int y, int i, int j) { int a[2], b[2], cnt1 = 0, cnt2 = 0; for (int m = 0; m \u0026lt;3; ++m) { if (m != y) a[cnt1++] = idx[x][m]; if (m != j) b[cnt2++] = idx[i][m]; } if (max(a[0],a[1])\u0026gt;max(b[0], b[1]) \u0026amp;\u0026amp; min(a[0],a[1])\u0026gt;min(b[0], b[1])) return true; return false; } int dp(int x, int y) { int\u0026amp; ans = idxh[x][y]; if (ans) return ans; ans = idx[x][y]; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; 3; ++j) { if (canBPiled (x, y, i, j)) ans = max(ans, dp(i,j)+idx[x][y]); } } return ans; } int main() { ios_base::sync_with_stdio(false); cin.tie(0); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { maxh = 0; memset(idxh, 0, sizeof(idxh)); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; 3; ++j) cin \u0026gt;\u0026gt; idx[i][j]; for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; 3; ++j) maxh = max(maxh, dp(i, j)); cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++cas \u0026lt;\u0026lt; \u0026#34;: maximum height = \u0026#34; \u0026lt;\u0026lt; maxh \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-22T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-437-the-tower-of-babylon/","title":"UVa OJ 437 - The Tower of Babylon"},{"content":"Problem Here is the Problem Link\nSolution 在车站有三种选择：1.等；2.向右走 3.向左走\n我们从约定的地点和约定的时间倒回来考虑，如果能够在0（初始时刻）回到车站1,就表示能够完成。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; int n, T, m1, m2, cas;; int t[55], d[255], e[255]; int fromRight[205][55], fromLeft[205][55], takeTime[205][55]; void init() { memset(fromLeft, 0, sizeof(fromLeft )); memset(fromRight, 0, sizeof(fromRight)); cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt; n ; ++i) cin \u0026gt;\u0026gt; t[i]; cin \u0026gt;\u0026gt; m1; for (int i = 1; i \u0026lt;= m1; ++i) { cin \u0026gt;\u0026gt; d[i]; int tmp = d[i]; fromLeft[tmp][1] = 1; for (int j = 1; j \u0026lt; n; ++j) { tmp += t[j]; if (tmp \u0026lt;= T) fromLeft[tmp][j+1] = 1; else break; } } cin \u0026gt;\u0026gt; m2; for (int i = 1; i \u0026lt;= m2; ++i) { cin \u0026gt;\u0026gt; e[i]; int tmp = e[i]; fromRight[tmp][n] = 1; for (int j = n-1; j \u0026gt; 1; --j) { tmp += t[j]; if (tmp \u0026lt;= T) fromRight[tmp][j] = 1; else break; } } memset(takeTime, 0x3f, sizeof(takeTime)); takeTime[T][n] = 0; } int main() { ios_base::sync_with_stdio(false); cin.tie(0); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { init(); for (int i = T-1; i \u0026gt;= 0; --i) { for (int j = 1; j \u0026lt;= n; ++j) { takeTime[i][j] = takeTime[i+1][j]+1; if (j \u0026gt; 1 \u0026amp;\u0026amp; fromRight[i][j] \u0026amp;\u0026amp; i+t[j-1] \u0026lt;= T) takeTime[i][j] = min(takeTime[i][j], takeTime[i+t[j-1]][j-1]); if (j \u0026lt; n \u0026amp;\u0026amp; fromLeft[i][j] \u0026amp;\u0026amp; i+t[j] \u0026lt;=T) takeTime[i][j] = min(takeTime[i][j], takeTime[i+t[j]][j+1]); } } cout \u0026lt;\u0026lt; \u0026#34;Case Number \u0026#34; \u0026lt;\u0026lt; ++cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; if(takeTime[0][1] \u0026gt;= 0x3f3f3f3f) cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; else cout \u0026lt;\u0026lt; takeTime[0][1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-22T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-714-copying-books/","title":"UVa OJ 714 - Copying Books"},{"content":"Problem 输入一个n*m(1≤n,m≤1000)矩阵,每个格子可能是空地,也可能是沼泽。对于每个空地格子,求出以它为右下角的空矩形的最大周长,然后统计每个周长出现了多少次。\nInput On the first line a positive integer: the number of test cases, at most 100. After that per test case:\n One line with two integers n and m (1 ≤ n, m ≤ 1000): the dimensions of Per’s parcel. n lines, each with m characters. Each character is either ‘#’ or ‘.’. The j-th character on the i-th line is a ‘#’ if position (i, j) is a swamp, and ‘.’ if it is grass. The north-west corner of Per’s parcel has coordinates (1, 1), and the south-east corner has coordinates (n, m).  Output Zero or more lines containing a complete list of how many parcels of each perimeter Per needs to sell in order to maximize his profit. More specifically, if Per should sell piparcels of perimeter i in the optimal solution, output a single line ‘pixi’. The lines should be sorted in increasing order of i. No two lines should have the same value of i, and you should not output lines with pi= 0.\nSample Input 1 6 5 ..#.# .#... #..## ...#. #.... #..#. Sample Output 6 x 4 5 x 6 5 x 8 3 x 10 1 x 12 Solution My code is inefficient, it takes about 2s to run.\nThe main idea is to handle the problem is creating arrays or whatever to record the length(height) of each blocks. And then caculate the circumference of them.\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int maxn = 1005; int cas, n, m, maxCircum, minLength; char land[maxn][maxn]; int landLen[maxn][maxn], idx[maxn \u0026lt;\u0026lt; 2]; int main() { ios::sync_with_stdio(false); cin.tie(0); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  cin \u0026gt;\u0026gt; cas; while(cas--) { memset(idx, 0, sizeof(idx)); maxCircum = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; land[i]+1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { if (land[i][j] != \u0026#39;#\u0026#39;) landLen[i][j] = landLen[i-1][j] + 1; else landLen[i][j] = 0; } } for (int i = n; i \u0026gt; 0; --i) { for (int j = m; j \u0026gt; 0; --j) { if (landLen[i][j]) { int Max = (landLen[i][j]+1) \u0026lt;\u0026lt; 1; minLength = landLen[i][j]; for (int k = j-1; k \u0026gt; 0 \u0026amp;\u0026amp; landLen[i][k]; --k) { minLength = min(minLength, landLen[i][k]); int tmp = j-k+1+minLength \u0026lt;\u0026lt; 1; Max = max(Max, tmp); } ++idx[Max]; maxCircum = max(Max, maxCircum); } } } for (int i = 4; i \u0026lt;= maxCircum; ++i) if (idx[i]) printf(\u0026#34;%d x %d\\n\u0026#34;, idx[i], i); } return 0; } ","date":"2016-09-21T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-12265-selling-land/","title":"UVa OJ 12265 - Selling Land"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n这个题目感觉就很玄乎了，就只给我们一张图片，网页源码里空空如也\n这里实际上是把一张图片拆分成两张来看。\n我尝试了不同的奇偶拆分方式，最终还是选定了X轴和Y轴相加的方式来判断奇偶\nfrom io import BytesIO from PIL import Image __author__ = \u0026#39;Yuuki_Dach\u0026#39; img = Image.open(\u0026#39;cave.jpg\u0026#39;) width, height = img.size even = Image.new(\u0026#39;RGB\u0026#39;, (width \u0026gt;\u0026gt; 1, height \u0026gt;\u0026gt; 1)) odd = Image.new(\u0026#39;RGB\u0026#39;, (width \u0026gt;\u0026gt; 1, height \u0026gt;\u0026gt; 1)) for i in range(width): for j in range(height): imgPixel = img.getpixel((i, j)) if (i + j) \u0026amp; 1 == 1: odd.putpixel((i \u0026gt;\u0026gt; 1, j \u0026gt;\u0026gt; 1), imgPixel) else: even.putpixel((i \u0026gt;\u0026gt; 1, j \u0026gt;\u0026gt; 1), imgPixel) even.show() odd.show() ","date":"2016-09-20T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-11-solution/","title":"The Python Challenge Level-11 Solution"},{"content":"Problem Link: 1442 - Cav\nSolution Use greedy algorithm to deal with this problem.\nAdjust the height of ceiling to fit the requirements.\nHere is the code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; const int maxn = 1e6+5; int cas, n, cnt; int ceiling[maxn], floor[maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  cin \u0026gt;\u0026gt; cas; while(cas--) { cnt = 0; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; floor[i]; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; ceiling[i]; int tmp = maxn; for (int i = 0; i \u0026lt; n; ++i) { tmp = min(tmp, ceiling[i]); tmp = max(tmp, floor[i]); ceiling[i] = tmp; } tmp = maxn; for (int i = n-1; i \u0026gt; -1; --i) { tmp = min(tmp, ceiling[i]); tmp = max(tmp, floor[i]); ceiling[i] = tmp; cnt += ceiling[i] - floor[i]; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-20T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1442-cav/","title":"UVa OJ 1442 - Cav"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\nLevel 9 第九关树的图片其实是一个提示，就是要我把点一个个的连起来，而这个点是由网页源代码里注释的first和second部分给出的，我直接把两个部分的坐标提取到一起，能够得到一个牛的图片\nimport requests import re from PIL import Image, ImageDraw webUrl = \u0026#39;http://www.pythonchallenge.com/pc/return/good.html\u0026#39; webContent = requests.get(webUrl, auth=(\u0026#39;huge\u0026#39;,\u0026#39;file\u0026#39;)).text print(webContent) pattern = re.compile(r\u0026#34;(\\d{2,3})\u0026#34;) nums = re.findall(pattern, webContent) nums = list(map(int,nums)) nums.remove(nums[0]) nums.remove(nums[0]) print(nums) img = Image.new(\u0026#39;RGB\u0026#39;, (800,800)) draw = ImageDraw.Draw(img) draw.polygon(nums, \u0026#39;white\u0026#39;) img.show() 这里最先发应的是\u0026rsquo;cow\u0026rsquo;这个单词，输入后提示我们是公的。于是再输入\u0026rsquo;ox'，结果还是不对。输入\u0026rsquo;bull\u0026rsquo;就对了\nLevel 10 这一关简单明了，就是找规律（然而渣渣的我还是找了很久）\n可以发现，后一个数实际上是前一个数的读法，比如\na[0] = 1 a[1] = 1个1 # 11 a[2] = 2个1 # 21 # 以此类推 a, sub = \u0026#39;1\u0026#39;, \u0026#39;\u0026#39; for i in range(30): j = k = 0 while j \u0026lt; len(a): while k \u0026lt; len(a) and a[k] == a[j]: k += 1 sub += str(k-j) + a[j] j = k a, sub = sub, \u0026#39;\u0026#39; print(len(a)) 最后结果是5808\n","date":"2016-09-19T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-9-10-solutions/","title":"The Python Challenge Level 9-10 Solutions"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n这道题目网页源代码里没有什么别的提示，而图片中有个条形码类似物，那么就需要我们对图片进行处理了。先想办法把条形码读出来,并且转换成可读的文字\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- from PIL import Image from io import BytesIO import requests imgUrl = \u0026#39;http://www.pythonchallenge.com/pc/def/oxygen.png\u0026#39; img = Image.open(BytesIO(requests.get(imgUrl).content)) for i in range(img.width): midPixel = img.getpixel((i,img.height\u0026gt;\u0026gt;1)) print(midPixel) 得到结果以后我们可以发现，条形码中没一条的宽度是7个像素，所以我们可以再处理一下，把相同的条形码rgb值取一个即可。另外还要注意的是，条形码没有覆盖全部的图片，最后无序的rgb值需要删掉，所以改进一下代码\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = \u0026#39;Yuuki_Dach\u0026#39; from PIL import Image from io import BytesIO import requests imgUrl = \u0026#39;http://www.pythonchallenge.com/pc/def/oxygen.png\u0026#39; img = Image.open(BytesIO(requests.get(imgUrl).content)) midPixel = [img.getpixel((i,img.height\u0026gt;\u0026gt;1)) for i in range(0,img.width,7)] code = [r for r, g, b ,a in midPixel if r==g==b] print(\u0026#34;\u0026#34;.join(map(chr,code))) 得到提示\nsmart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121] 再对给出的数字进行处理，就能得到‘integrity’\n","date":"2016-09-18T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-7-solution/","title":"The Python Challenge Level-7 Solution"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n这道题目消耗了我相当长的一段时间，让我对str和byte也有了一个新的认识。\n首先还是老样子，进入网页源代码，看看里面有什么\n首先引入眼帘的是一大串坐标代码，加上第七题的做法，很容易让人产生误会。我也试着去把他门转换了一下，发现并没有什么用处，然后就把目光集中在了里面的链接上，点了一下，需要用户名和密码，随便输入了123,并没有什么效果\n再看看源代码底部有\u0026rsquo;un\u0026rsquo;和\u0026rsquo;pw'，刚好两个，而且和\u0026rsquo;user name' \u0026lsquo;password\u0026rsquo;相对应。 但是这两串字符又有什么意义呢？\n我查了一下，发现这实际上是经bz2压缩后的信息，于是开始编写程序解码\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = 'Yuuki_Dach' import bz2 un = b\u0026quot;BZh91AY\u0026amp;SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00 \\x00!\\x9ah3M\\x07\u0026lt;]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084\u0026quot; pw = b\u0026quot;BZh91AY\u0026amp;SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13\u0026lt;]\\xc9\\x14\\xe1BBP\\x91\\xf08\u0026quot; print(bz2.decompress(un)) print(bz2.decompress(pw)) 得到用户名和密码就能进入下一关了\n","date":"2016-09-18T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-8-solution/","title":"The Python Challenge Level-8 Solution"},{"content":"前两天听说了有The Python Chanllenge这么一个游戏，于是自己也想来尝试一下。感觉还是一个挺有意思的。\n附上我在Github上存放的代码仓库: The Python Challenge\nChallenge 0 第0关只是一个让你大概清楚怎么玩的一个关卡，只要按照图片上的意思，计算2的38次方即可。这个就无所谓是用Python还是别的什么方式来计算了，能够得到结果就行，所以代码就不贴出来了。\n算出结果之后，将结果复制到网页的url栏,将.html前面的单词替换掉就好\nChallenge 1 根据图片给的提示我们可以发现，从K到M，O到Q，以及E到G，都是把单词给推后了两个。所以，我们只需要把他底下给我们的一大串字符串给统一推后两个字母就行了。另外要注意y要对应a,z则对应b。下面是我的初版代码:\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- code = (\u0026#34;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dm\u0026#34; \u0026#34;p. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr\u0026#39;q ufw rfgq rcvr gq \u0026#34; \u0026#34;qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc\u0026#34; \u0026#34; spj.\u0026#34;) addr = \u0026#34;\u0026#34; for alpha in code: if alpha!=\u0026#39; \u0026#39; and alpha!=\u0026#39;.\u0026#39; and alpha!=\u0026#39;\\\u0026#39;\u0026#39; and alpha!=\u0026#39;(\u0026#39; and alpha!=\u0026#39;)\u0026#39;: if alpha == \u0026#39;y\u0026#39;: alpha = \u0026#39;a\u0026#39; elif alpha == \u0026#39;z\u0026#39;: alpha = \u0026#39;b\u0026#39; else: alpha = chr(ord(alpha)+2) addr += alpha print(addr) 还是比较简单直接的。提取到的结果如下：\n i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that\u0026rsquo;s why this text is so long. using string.maketrans() is recommended. now apply on the url.\n 这里提示我们可以用string.maketrans()来提高效率。所以，我们再码一遍代码，利用maketrans（）使代码变得更加简洁和美观。\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- code = (\u0026#34;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dm\u0026#34; \u0026#34;p. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr\u0026#39;q ufw rfgq rcvr gq \u0026#34; \u0026#34;qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc\u0026#34; \u0026#34; spj.\u0026#34;) intab = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; outtab = \u0026#34;cdefghijklmnopqrstuvwxyzab\u0026#34; transtab = \u0026#34;\u0026#34;.maketrans(intab,outtab) print(code.translate(transtab)) 需要注意的是，maketrans()到了python3中就直接包含在str类的方法中了,如果是Python2的话记得import对应的模块。\n最后只要按照提示，把关卡1url里的‘map’也对应向后推两个字母，变成\u0026rsquo;ocr\u0026rsquo;就好了\n","date":"2016-09-17T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-0-1-solutions/","title":"The Python Challenge Level 0-1 Solutions"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\nThe Python Challenge第二关给了我们一张书的图片，但是十分模糊的，什么都看不清，这个时候，我们看看它给我们的文字提示是\n MAYBE they are in the page source.\n 这个时候我们点击鼠标右键，查看网页的源代码，会发现，果然有一大长条乱七八糟的符号。不难猜到，我们所需要的下一关的url就藏在这堆符号里。于是我们用简单的爬虫爬取网页代码，然后利用正则表达式来捕捉我们需要的字母。\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = \u0026#39;Yuuki_Dach\u0026#39; from urllib import request import re pyUrl = \u0026#34;http://www.pythonchallenge.com/pc/def/ocr.html\u0026#34; req = request.Request(pyUrl) resq = request.urlopen(req) content = resq.read() book = re.compile(b\u0026#34;\u0026lt;!--(.*?)--\u0026gt;\u0026#34;, re.S) bookContents = re.findall(book, content) wordsCmpl = re.compile(b\u0026#34;([ a-zA-Z])\u0026#34;, re.S) for bookContent in bookContents: words = re.findall(wordsCmpl, bookContent) code = \u0026#34;\u0026#34; for word in words: code += word.decode(\u0026#34;ascii\u0026#34;) print(code) 这里只要注意一下编码的方式就好。\n运行代码，我们可以得到如下信息\nfind rare characters in the mess below equality 将equality输入到url就能进入下一关了\n","date":"2016-09-17T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-2-solution/","title":"The Python Challenge Level-2 Solution"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n这里按照题目意思，利用正则匹配，找到恰好分别被三个大写字母包在左右的小写字母就好\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = \u0026#39;Yuuki_Dach\u0026#39; from urllib import request import re pyUrl = \u0026#39;http://www.pythonchallenge.com/pc/def/equality.html\u0026#39; req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() pattern = re.compile(b\u0026#39;[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]\u0026#39;, re.S) contents = re.findall(pattern, urlContent) code = \u0026#39;\u0026#39; for content in contents: code += content.decode(\u0026#34;ascii\u0026#34;) print(code) 得到linkedlist，输入到url中，得到提示\nlinkedlist.php 把'.html\u0026rsquo;的后缀改成'.php\u0026rsquo;就通关了\n","date":"2016-09-17T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-3-solution/","title":"The Python Challenge Level-3 Solution"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n依然是先查看网页源代码。发现有个链接'\u0026hellip;nothing=12345'\n点进去之后发现又给我们一个数字，引导我们去下一个链接，于是可以知道，只要链接爬到了终点，那么就会出现别的提示信息\n果然，爬到终点之后，提示我们除以二，继续爬，所以只要把代码改个数字就好，我的代码如下：\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = 'Yuuki_Dach' from urllib import request import re mainUrl = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=' subUrl = '8022' # first try is '12345' subUrl2 = '' i = 400 while subUrl != subUrl2: subUrl2 = subUrl pyUrl = mainUrl + subUrl req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() pattern = re.compile(b'\\d+', re.S) contents = re.findall(pattern, urlContent) for content in contents: subUrl = content.decode(\u0026quot;ascii\u0026quot;) print(subUrl) 最后得到\u0026rsquo;peak'。只不过注意后缀要改回'.html\u0026rsquo;就行了\n","date":"2016-09-17T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-4-solution/","title":"The Python Challenge Level-4 Solution"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n先看提示:\npronounce it 再看看网页源码，\u0026lsquo;peak hell\u0026rsquo;能代表什么？\n我一开始以为是\u0026rsquo;pick\u0026rsquo;什么东西，点开\u0026rsquo;banner.p\u0026rsquo;之后没发现什么规律，于是先google了一下\u0026rsquo;peak hell\u0026rsquo;，发现了Python有pickle这么一个模块，那么就必然和这个有关系了。\npickle这个模块是python用来保存数据的，主要是loads和dumps方法的运用（这两个是对内存进行操作，如果要对硬盘进行操作，形成文件等形式，就是用load和dump），一个是读，一个是写，这里因为是直接从网页中获取数据，所以只要读就行了。\n读完能发现这实际上是一个list组，再仔细点观察的话，就会注意到每一个[]中，把' \u0026lsquo;和\u0026rsquo;#\u0026lsquo;后跟着的数字加起来，恰好是95。于是可以估计，这应该是利用点阵的方式来进行显示，而点阵的一行，有95个字符。这样就有了如下代码：\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = \u0026#39;Yuuki_Dach\u0026#39; from urllib import request import pickle pyUrl = \u0026#39;http://www.pythonchallenge.com/pc/def/banner.p\u0026#39; req = request.Request(pyUrl) resp = request.urlopen(req) urlContent = resp.read() code = [] pic = pickle.loads(urlContent) for line in pic: for letter, num in line: code.append(num*letter) code.append(\u0026#39;\\n\u0026#39;) print(\u0026#34;\u0026#34;.join(code)) 运行之后得到的点阵图是\n ##### ##### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ### #### ### ### ##### ### ##### ### ### #### ### ## #### ####### ## ### #### ####### #### ####### ### ### #### ### ### ##### #### ### #### ##### #### ##### #### ### ### #### ### #### #### ### ### #### #### #### #### ### #### #### ### #### #### ### #### #### #### #### ### ### #### #### #### #### ## ### #### #### #### #### #### ### #### #### #### #### ########## #### #### #### #### ############## #### #### #### #### ### #### #### #### #### #### #### #### #### #### #### #### ### #### #### #### #### #### #### ### #### #### #### ### #### #### #### #### ### #### ### ## #### #### ### #### #### #### #### #### ### ## #### ### ## #### #### ########### #### #### #### #### ### ## #### ### ###### ##### ## #### ###### ########### ##### ### ###### 大家请把终端的宽度拉大一点，不然会和我一开始一样，读不出什么东西来，并且怀疑是不是程序写错了 =_=\n接下来就是把channel输入到url中了\n","date":"2016-09-17T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-5-solution/","title":"The Python Challenge Level-5 Solution"},{"content":"先附上我在Github上存放的代码仓库: The Python Challenge\n这道题目开始让人很迷茫了（至少我是这样），先点开网页源码，没发现什么有价值等东西，然后又看看图片，发现右上角有个箭头，指着几个数字3，于是照着填进去了，发现没有链接，于是又跑去看源码，终于在开头发现了这个：\n\u0026lt;!-- \u0026lt;-- zip --\u0026gt; 于是将'.html\u0026rsquo;替换成'.zip'，居然下载下来了一个压缩包，点开之后会发现有一个readme.txt，再继续点开，内容如下：\nwelcome to my zipped list. hint1: start from 90052 hint2: answer is inside the zip 很明显，和前几题一样，就是按照90052这个数字找下去了，不过这次找的不是网页，而是文件。这里我们用zipfile这个模块来完成我们的需求\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = \u0026#39;Yuuki_Dach\u0026#39; import zipfile import re zipFileName= \u0026#39;channel.zip\u0026#39; zipBag = zipfile.ZipFile(zipFileName) num = \u0026#39;90052\u0026#39; while True: zipContent = zipBag.read(num+\u0026#34;.txt\u0026#34;).decode(\u0026#34;utf-8\u0026#34;) print(zipContent) content = re.search(\u0026#34;(\\d+)\u0026#34;, zipContent) if content == None: break num = content.group() 运行代码，会发现有以下信息：\nCollect the comments. 恰好室友前几天提到zip压缩包的一些相关事项，再配合上一题，于是我将代码稍作更改，把文件里等注释等内容全部读出来\n#! /usr/bin/env python3 # -*- coding: utf-8 -*- __author__ = 'Yuuki_Dach' import zipfile import re zipFileName= 'channel.zip' zipBag = zipfile.ZipFile(zipFileName) num = '90052' comment = '' while True: zipContent = zipBag.read(num+'.txt').decode('utf-8') print(zipContent) comment += zipBag.getinfo(num+'.txt').comment.decode('utf-8') content = re.search(\u0026quot;(\\d+)\u0026quot;, zipContent) if content == None: break num = content.group() print(comment) **************************************************************** **************************************************************** ** ** ** OO OO XX YYYY GG GG EEEEEE NN NN ** ** OO OO XXXXXX YYYYYY GG GG EEEEEE NN NN ** ** OO OO XXX XXX YYY YY GG GG EE NN NN ** ** OOOOOOOO XX XX YY GGG EEEEE NNNN ** ** OOOOOOOO XX XX YY GGG EEEEE NN ** ** OO OO XXX XXX YYY YY GG GG EE NN ** ** OO OO XXXXXX YYYYYY GG GG EEEEEE NN ** ** OO OO XX YYYY GG GG EEEEEE NN ** ** ** **************************************************************** ************************************************************** 再将hockey输入，居然还有一个猜谜！\nit's in the air. look at the letters. 这里不难想到\u0026rsquo;oxygen'，输入即可\n","date":"2016-09-17T00:00:00Z","permalink":"https://yuukidach.github.io/p/the-python-challenge-level-6-solution/","title":"The Python Challenge Level-6 Solution"},{"content":"Problem n支队伍(2≤n≤1024,且n是2的整数幂)打淘汰赛,每轮都是两两配对,胜者进入下一轮。每支队伍的实力固定,并且已知每两支队伍之间的一场比赛结果。你喜欢1号队。虽然它不一定是最强的,但是它可以直接打败其他队伍中的至少一半,并且对于每支1号队不能直接打败的队伍t,总是存在一支1号队能直接打败的队伍t\u0026rsquo;使得t\u0026rsquo;能直接打败t。问:是否存在一种比赛安排,使得1号队夺冠?\nInput For each test case, the input is as follows:\n  One line containing the number of teams n, where n is a power of two and 2 ≤ n ≤ 1024. Teams are numbered from 1 to n, where team 1 is your favourite team.\n  n lines, each containing a string of n binary digits. The k-th digit on the j-th line is ‘1’ if team j would certainly win from team k, otherwise it is ‘0’. A team cannot play against itself, therefore the j-th digit on the j-th line is ‘0’. If j!=k, the k-th digit on the j-th line is different from the j-th digit on the k-th line.\n  Output For each test case, print n − 1 lines of output, specifying a tournament schedule that ensures victory for team 1. The first n/2 lines describe the first round of the tournament. The next n/4 lines describe the second round, if any, etc. The last line describes the final match. Each line contains two integers x and y, indicating that team x plays a match against team y. If there are multiple tournament schedules where team 1 wins, any one of those tournament schedules will be accepted as a correct answer.\nSample Input 4 0110 0011 0000 1010 8 00111010 10101111 00010010 01000101 00110010 10101011 00010000 10101010 Sample Output 1 3 2 4 1 2 1 5 3 7 4 8 2 6 1 3 4 2 1 4 Solution 先把1队能打败的和不能打败的队伍全部区分开来，然后让不能打败的队伍和能被打败的队伍先互相匹配。接着对1匹配能打败的队伍。再让不能打败的队伍相互之间互相匹配，剩下的就随便匹配。每一次能减少一半的队伍，循环几次即可\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; const int maxn = 1025; char team[maxn][maxn]; int n; int main() { ios::sync_with_stdio(false); cin.tie(0); //freopen(\u0026#34;input.txt\u0026#34; , \u0026#34;r\u0026#34;, stdin );  //freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout);  while(cin \u0026gt;\u0026gt; n){ for(int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; team[i]+1; } vector\u0026lt;int\u0026gt; win, lose; for(int i = 2; i \u0026lt;= n; ++i) { if(team[1][i] == \u0026#39;1\u0026#39;) win.push_back(i); else lose.push_back(i); } int leftTeam = n; while (leftTeam \u0026gt; 1) { vector\u0026lt;int\u0026gt; winSub, loseSub, round3; for(int i = 0; i \u0026lt; lose.size(); ++i) { bool matched = false; for(int j = 0; j \u0026lt; win.size(); ++j){ if(win[j] \u0026amp;\u0026amp; team[win[j]][lose[i]] == \u0026#39;1\u0026#39;){ cout \u0026lt;\u0026lt; win[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt;lose[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; matched = true; winSub.push_back(win[j]); win[j] = 0; break; } } if(!matched) round3.push_back(lose[i]); } bool isOK = false; for(int i = 0; i \u0026lt; win.size(); ++i) { if(win[i]) { if(!isOK){ cout \u0026lt;\u0026lt; \u0026#34;1 \u0026#34; \u0026lt;\u0026lt; win[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; isOK = true; } else { round3.push_back(win[i]); } } } for(int i = 0; i \u0026lt; round3.size(); i += 2) { cout \u0026lt;\u0026lt; round3[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; round3[i+1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int tmp = round3[i+1]; if(team[round3[i]][tmp] == \u0026#39;1\u0026#39;) tmp = round3[i]; if(team[1][tmp] == \u0026#39;1\u0026#39;) winSub.push_back(tmp); else loseSub.push_back(tmp); } win = winSub; lose = loseSub; leftTeam \u0026gt;\u0026gt;= 1; } } return 0; } ","date":"2016-09-15T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1609-foul-play/","title":"UVa OJ 1609 - Foul Play"},{"content":"这篇文章算是给初次在Ubuntu上使用Python编程的人一个提醒吧。\n使用方法 首先我们要知道Ubuntu自带的是Python2，然而有很多人(比如我)在学习Python的时候希望使用Python3\n我们先使用\nsudo apt install python3 老版本Ubuntu请将 \u0026lsquo;apt\u0026rsquo; 改为 \u0026lsquo;apt-get\u0026rsquo;\n安装好了Python3之后，我们想在终端中直接使用Python3，可是当我们输入 \u0026lsquo;python\u0026rsquo;之后，却发现还是Python2。这个时候其实很简单，只要在 \u0026lsquo;python\u0026rsquo;后面加个 \u0026lsquo;3\u0026rsquo; 就好，具体如下:\npython3 cmd cmd 是你自己的指令。这个时候我们就是使用Python3了\nWarning！！！ 不过我要说的不只是这些，而是这篇文章：在Ubuntu中安装Python3\n不推荐大家采用文章里的方式\n这篇文章开头写的很好，告诉我们Ubuntu很多底层采用的是Python2，当时后面居然让我们把link文件改掉。这样会导致Ubuntu的系统出现一些错误，比如安装软件失败。所以大家还是直接使用 \u0026lsquo;python3\u0026rsquo; 这个命令就好，不要自找麻烦。\n","date":"2016-09-14T00:00:00Z","permalink":"https://yuukidach.github.io/p/ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8python3/","title":"Ubuntu下使用Python3"},{"content":"有部分人在使用Ubuntu的时候可能会遇到和我一样的问题，就是以太网显示已断开，这面原因有很多，但是大多都是驱动问题。网上也有教程，亲测以后发现有些地方并不适用，这里我们就来谈谈这个问题。\n我的Ubuntu版本是16.04 LTS， 有线网卡是Realtek的\n装完系统以后以太网显示已断开，但是如果编辑连接的话，可以发现，其实是一直在使用的。真正原因，是网卡驱动不兼容的问题。Ubuntu自带的是r8169，而我需要的是r8168。因此，我们只需要安装上r8168就好了。\n但是网上虽然有比较好的教程，但是有一些瑕疵，不通用，有人会说自己找不到r8169.ko这个文件并删除。实际上，我们应该用find指令去找我们所需要的文件的位置，而不是完全照搬那些解决方法。\n下面开始谈谈解决方式：\n  下载驱动并解压好\n去Realtek官网下载好r8168的驱动: 下载连接\n  获取root权限\n  sudo su 删除r8169模块  rmmod r8169 mv /'-yourFile'/r8169.ko ~/r8169.ko.backup 将'-yourFile'替换成具体的文件路径，也就是存放了r8169.ko这个文件的路径  比如我的是\n\u0026gt;/lib/modules/`4.4.0-36-generic`/kernel/drivers/net/enthernet/realtek 具体还是利用find指令自己去找   安装r8168\n切换到解压完的目录执行以下指令\n  make clean modules make install  添加驱动模块到内核中\n先让系统知道我们的模块，然后添加到内核中\n  depmod -a insmod ./src/r8168.ko 让模块在启动的时候生效  mv /initrd.img ~/initrd.img.backup mkinitramfs -o /boot/initrd.img-`uname -r` `uname -r` echo \u0026quot;r8168\u0026quot; \u0026gt;\u0026gt; /etc/modules \u0026lsquo;uname -r\u0026rsquo;是内核版本代号，就是4.4.0-36-generic这类，具体还是看自己的文件。之前在找r8169.ko的时候就会看到\n最后可以用lspci -v这个指令来看看自己用的是什么驱动\n参考文章   The pain of an Realtek (RTL8111/RTL8168) ethernet card\n  ubuntu装RTL8111/8168B网卡驱动 (第二篇参考文章是转载的，原文链接没找到)\n  ","date":"2016-09-10T00:00:00Z","permalink":"https://yuukidach.github.io/p/ubuntu%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B7%B2%E6%96%AD%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"Ubuntu以太网已断开的解决办法"},{"content":"Problem A sequence is called non-boring if its every connected subsequence contains a unique element, i.e. an element such that no other element of that subsequence has the same value.\nGiven a sequence of integers, decide whether it is non-boring.\nInput The first line of the input contains the number of test cases T. The descriptions of the test cases follow:\nEach test case starts with an integer n (1 ≤ n ≤ 200000) denoting the length of the sequence. In the next line the n elements of the sequence follow, separated with single spaces. The elements are non-negative integers less than 109.\nOutput Print the answers to the test cases in the order in which they appear in the input. For each test case print a single line containing the word ‘non-boring’ or ‘boring’.\nSample Input 4 5 1 2 3 4 5 5 1 1 1 1 1 5 1 2 3 2 1 5 1 1 2 1 1 Sample Output non-boring boring non-boring boring Solution 先找出每个点离它最近的相同点，然后递归，利用分治法从两边向中间搜索，如果有区间的点都能在该区间内找到重复点，那么就表示这个序列是无聊的。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; const int maxn = 200001; int cas, n; int x[maxn], l[maxn], r[maxn]; bool ite(int ll, int rr) { if (ll \u0026gt;= rr) return true; for (int i=ll, j=rr; i\u0026lt;=j; ++i,--j) { if (l[i] \u0026lt; ll \u0026amp;\u0026amp; r[i] \u0026gt; rr) return (ite(ll, i-1) \u0026amp;\u0026amp; ite(i+1, rr)); if (l[j] \u0026lt; ll \u0026amp;\u0026amp; r[j] \u0026gt; rr) return (ite(ll, j-1) \u0026amp;\u0026amp; ite(j+1, rr)); } return false; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; cas; while (cas--){ cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; x[i]; map\u0026lt;int, int\u0026gt; m; for (int i = 0; i \u0026lt; n; ++i) { if (!m.count(x[i])) l[i] = -1; else l[i] = m[x[i]]; m[x[i]] = i; } m.clear(); for (int i = n - 1; i \u0026gt; -1; --i) { if (!m.count(x[i])) r[i] = n; else r[i] = m[x[i]]; m[x[i]] = i; } if (ite(0, n - 1)) cout \u0026lt;\u0026lt; \u0026#34;non-boring\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;boring\u0026#34;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-10T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1608-non-boring-sequences/","title":"UVa OJ 1608 - Non-boring sequences"},{"content":"Problem You are listening to your music collection using the shuffle function to keep the music surprising. You assume that the shuffle algorithm of your music player makes a random permutation of the songs in the playlist and plays the songs in that order until all songs have been played. Then it reshuffles and starts playing the list again.\nYou have a history of the songs that have been played. However, your record of the history of played songs is not complete, as you started recording songs at a certain point in time and a number of songs might already have been played. From this history, you want to know at how many different points in the future the next reshuffle might occur.\nA potential future reshuffle position is valid if it divides the recorded history into intervals of length s (the number of songs in the playlist) with the rst and last interval possibly containing less than s songs and no interval contains a specic song more than once.\nInput On the rst line one positive number: the number of testcases, at most 100. After that per testcase:\n• One line with two integers s and n (1 ≤ s, n ≤ 100000): the number of different songs in the playlist and the number of songs in the recorded playlist history.\n• One line with n space separated integers, x1, x2, . . . , xn (1 ≤ xi ≤ s): the recorded playlist history.\nOutput One line with the number of future positions the next reshuffle can be at. If the history could not be generated by the above mentioned algorithm, output 0.\nSample Input 4 4 10 3 4 4 1 3 2 1 2 3 4 6 6 6 5 4 3 2 1 3 5 3 3 1 1 1 7 3 5 7 3 Sample Output 1 6 0 7 Solution 一开始没想太多，直接用枚举的方式，写了一下代码，提交之后虽然AC了，但是耗时2s多，内心还是不舒服的。于是尝试改了一下，也参考了别人的代码。\n总体说来还是一道滑动窗口的题目，并不是十分复杂，但是处理得当的话，效率能提升很多。这里为了节省时间，通过一次扫描，将每一段可以构成音乐单的数字，用idx这个数组来保存，可以为1，不行则为0.最后再将第一个数字按顺序，先当成第一段的最后一个，再当成第一段的倒数第二个，以此类推，得到结果。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int maxn = 100005; int ans, cas, s, n; int x[3*maxn], idx[maxn\u0026lt;\u0026lt;1], cnt[maxn]; int main(){ ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; cas; while (cas--){ cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; n; memset(x, 0, sizeof(int)*(n+(s\u0026lt;\u0026lt;1)+1)); memset(cnt, 0, sizeof(int)*(s+1)); memset(idx, 0, sizeof(int)*(n+s+1)); for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; x[i+s]; int tot = 0; for (int i = 0; i \u0026lt; n + s + 1; ++i){ if ((tot == s) || (i \u0026lt; s \u0026amp;\u0026amp; tot == i) || (i \u0026gt; n \u0026amp;\u0026amp; tot == n + s - i)) idx[i] = 1; if (x[i] \u0026amp;\u0026amp; !--cnt[x[i]]) --tot; if (x[i + s] \u0026amp;\u0026amp; !cnt[x[i + s]]++) ++tot; } ans = 0; for (int i = 0; i \u0026lt; s; ++i) { bool isOK = true; for (int j = i; j \u0026lt; n + s + 1; j += s) { if (!idx[j]){ isOK = false; break; } } if (isOK) ++ans; } if (ans \u0026gt; n) ans = s; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-06T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-12174-shuffle/","title":"UVa OJ 12174 - Shuffle"},{"content":"Problem 描述起来很麻烦，大家还是直接去OJ站看吧。我之后也会解释一下题目的意思\n题目链接： 1607 - Gates\nInput The first line of the input contains exactly one positive integer d equal to the number of data sets, 1 ≤ d ≤ 20. The data sets follow.\nEach data set consists of two consecutive lines. The rst of those lines contains exactly two positive integers n and m separated by single space, 1 ≤ n ≤ 100.000, 1 ≤ m ≤ 200.000. Integer n is the number of the net inputs and integer m is the number of the gates in the net. The second of those lines contains exactly 2m nonzero integers, separated by single spaces. The numbers on positions 2j - 1 and 2j describe the signal sources for the inputs to gate j. The positive number s means the output of gate s. The negative number s means the (-s)-th input to the net. The gates and the net inputs are numbered starting from one. The input of each gate is connected to an input of the net or to an output of a gate whose description occurred earlier in the sequence. Each net input is connected to at least one gate input. Each gate output is connected to at least one gate input except the output of the last gate that is connected to the output of the net.\nOutput The output should consist of exactly d lines, one line for each data set. The line number i should contain the answer to the i-th data set.\nThe answer to one data set should consist of a sequence of exactly k characters terminated by the end of line (with no spaces in between). Each of those characters should be 0 or 1 or x. The i-th symbol of the sequence denotes the assignment to the i-th input of the net.\nIf there are more than one optimal assignment then your program should output any of them (but only one).\nSample Input 1 3 6 -1 -3 -1 -2 1 2 1 2 4 3 5 5 Sample Output 10x Solution 对于该题，我理解题目意思的时间是长于解题时间的\n一般AC之后我会习惯性的看一下题目数据，方便我知道程序效率的提升空间，对程序作出改进。在看这道题目时，发现提交的人很少，60人左右，但是能提交基本都过了，没过的只有三四人。所以可以发现，题目难点其实主要还是读题。\n输入和输出很好理解，那么这道题目到底要我们干嘛。我稍微说一下。题目的意思其实是给我们n根线，这n根线可以给低电平，也可以给高电平。现在需要我们设计一种电路，完成一项固定的任务。比如永远都是输出0，永远都是输出1，或者永远和我们输入的x相反(例如我们给x以1，则输出0)，和x相同。理解了这个之后，我们就好做题了。\n我们线全部给电路0，再全部给电路1，如果两者相同，电路的输出就永远是0或1，这样我们可以不要x，全部指定输入的电平，比如全0。如果两者不同，把第一个0变1，还是不同则再试第二个0变成1，直到找到x的位置，可以让电路发挥其和x的关系作用。这里用二分法可以提高查找速度。\n#include\u0026lt;iostream\u0026gt; using namespace std; #define LL gate[i].in1 #define RR gate[i].in2  class gateClass { public: int in1, in2, out; } gate[200005]; int n, m, all0, all1; int getOutput(int pos) { for (int i = 1; i \u0026lt;= m; i++) { int x = LL\u0026gt;0 ? gate[LL].out:-LL\u0026lt;=pos; int y = RR\u0026gt;0 ? gate[RR].out:-RR\u0026lt;=pos; gate[i].out = !(x \u0026amp;\u0026amp; y); } return gate[m].out; } int main() { ios::sync_with_stdio(false); cin.tie(0); int cas , mid; cin \u0026gt;\u0026gt; cas; while (cas--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; gate[i].in1 \u0026gt;\u0026gt; gate[i].in2; int all0 = getOutput(0); int all1 = getOutput(n); if (all0 == all1) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; \u0026#39;0\u0026#39;; } else { int lef = 1, rit = n; while (lef \u0026lt; rit) { mid = lef + rit \u0026gt;\u0026gt; 1; if (getOutput(mid) == all1) rit = mid; else lef = mid + 1; } for (int i = 1; i \u0026lt; rit; i++) cout \u0026lt;\u0026lt; \u0026#39;1\u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;x\u0026#39;; for (int i = rit + 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; \u0026#39;0\u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-06T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1607-gates/","title":"UVa OJ 1607 - Gates"},{"content":"Problem Along a circular track, there are N gas stations, which are numbered clockwise from 1 up to N. At station i, there are pi gallons of petrol available. To race from station i to its clockwise neighbor one need qi gallons of petrol. Consider a race where a car will start the race with an empty fuel tank. Your task is to find whether the car can complete the race from any of the stations or not. If it can then mention the smallest possible station i from which the lap can be completed.\nInput First line of the input contains one integer T the number of test cases. Each test case will start with a line containing one integer N, which denotes the number of gas stations. In the next few lines contain 2 ∗ N integers. First N integers denote the values of pis (petrol available at station i), subsequent N integers denote the value of qis (amount of patrol needed to go to the next station in the clockwise direction).\nOutput For each test case, output the case number in the format “Case c:” , where c is the case number starting form 1. Then display whether it is possible to complete a lap by a car with an empty tank or not. If it is not possible to complete the lap then display “Not possible”. If possible, then display “Possible from station X”, where X is the first possible station from which the car can complete the lap.\n T \u0026lt; 25 N \u0026lt; 100001  Sample Input 2 5 1 1 1 1 1 1 1 2 1 1 7 1 1 1 10 1 1 1 2 2 2 2 2 2 2 Sample Output Case 1: Not possible Case 2: Possible from station 4 Solution 这道题可以用链表，从第一个开始遍历，如果遇到了燃料条件不足的车站，则下一次遍历从该车站的下一个站点开始。\n不过还有一个小地方要注意一下，我一开始因为没有注意到如果当遍历开始后，遍历的终点比起点的值还小，就能退出循环了，导致TLE了一次，望大家引以为戒。\n#include \u0026lt;iostream\u0026gt;using namespace std; const int maxn = 100005; int n, temp, pos, isOK, noWay; int p[maxn], q[maxn], dir[maxn]; int main(){ ios::sync_with_stdio(false); cin.tie(0); int cas, casCnt = 0; cin \u0026gt;\u0026gt; cas; while (++casCnt \u0026lt;= cas){ pos = -1; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n-1; ++i){ cin \u0026gt;\u0026gt; p[i]; dir[i] = i + 1; } cin \u0026gt;\u0026gt; p[n-1]; dir[n - 1] = 0; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; q[i]; for (int i = 0; i \u0026lt; n;){ isOK = 1, noWay = 0; temp = p[i] - q[i]; if (temp \u0026lt; 0) { ++i; continue;} for (int j = dir[i]; j != i; j = dir[j]){ temp += p[j] - q[j]; if (temp \u0026lt; 0) { if (i \u0026lt; j) i = j; else noWay = 1; isOK = 0; break; } } if (noWay) break; if (isOK){ pos = i + 1; break; } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; casCnt \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; if (pos != -1) cout \u0026lt;\u0026lt; \u0026#34;Possible from station \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;Not possible\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-05T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11093-just-finish-it-up/","title":"UVa OJ 11093 - Just Finish it up"},{"content":"昨天做题时无意间得知了\u0026lt;functional\u0026gt;这个头文件，之后自己也稍微地了解了一下相关的一些知识。\n内容比较多，叙述方面可能不是很详尽，大家如果看完还有不是很理解的地方，建议进文末的链接看看。\n\u0026lt;functional\u0026gt;头文件 关于这个头文件，在cppreference.com中是这样定义的:\n This header is part of the function objects library and provides the standard hash function.\n 这个头文件定义了许多函数对象类型和支持函数对象的功能。\n函数对象 关于函数对象这里就来比较详细的讲一下，也为后面的内容做一个铺垫。\n先来看看cplusplus.com中关于函数对象（Function object）的定义：\n Function objects are objects specifically designed to be used with a syntax similar to that of functions. In C++, this is achieved by defining member function operator() in their class.\n 简单的说，函数对象是通过重载operator()这个操作符，利用和函数相类似的句法，实现了函数的功能。来看一个例子：\nclass myFunctionClass{ public: int operator()(int x){ return x; } }test; int a = test(6); 这个程序中，如果我们输出a，就会发现，a的值是6，十分简单易懂。\n函数指针 提到了函数对象，就不得不提一下函数指针了。在我学C语言的时候，谭浩强的那本《C语言程序设计》就讲解了一下函数指针。类似于我们普通的变量指针的运用，如：\nint add(int a, int b){ return a+b; } typedef int(*addNumFunc)(int a, int b); addNumFunc add2Num = \u0026amp;add; int a = add2Num(4, 7); 函数指针可以简化我们的代码，但是函数对象与之相比有更大的优势。维基百科上是这样解说这些优势的：\n 函数对象与函数指针相比，有两个优点：第一是编译器可以内联执行函数对象的调用；第二是函数对象内部可以保持状态。\n 第一个不用多说，那么第二个是什么意思呢？就是将数据保存在成员变量中，以实现携带我们说需要的数据\nstd::lambda lambda(/\u0026lsquo;læmdə/) 表达式是用于创建匿名函数的，这是C++的一个新的特性。 我们从例子当中来看lambda的语法和其优势。\nstd::sort(x, x + n, [](int a, int b) { return std::abs(a) \u0026lt; std::abs(b); }); sort函数的第三行就是我们的lambda表达式。它以[]为开始，没有函数名称，接受两个int类型的参数，返回值是bool类型，也就是a\u0026lt;b的真假。其中返回值是自动推定的，而且只有在一个return的情况下，才能自动推定。\n如果我们需要自己定义返回值类型的话，我们可以用如下的方式\n[ capture-list ] ( params ) -\u0026gt; ret { body } 比如：\nstd::cout \u0026lt;\u0026lt; [](float f) -\u0026gt; int { return std::abs(f); } (-2.22); 这里的返回值就是int类型，而且我们在定义了函数之后直接调用该函数。\n另外关于lambda表达式开始的这对[]，其实也是有其作用的。\n [] 表示不捕获任何外部变量 [=] 表示以传值的方式捕获 [\u0026amp;] 表示以引用的方式捕获  当然也可以[\u0026amp;,a]这样，表示a用值传递，而其余的则是使用引用的方式了。其余的一次类推，this指针也是可以用的。\nlambda表达式的有优点就是让代码清晰易懂，同时也避免了和别人所写的一些代码的冲突，防止了误操作等。\n闭包类型 关于lambda，在cplusplus.com有这样一句话。\n Constructs a closure: an unnamed function object capable of capturing variables in scope.\n 所谓闭包类型(ClosureType)，就是lambda表达式执行后由编译器生成自动生成的函数对象有不同的类型名字，并且只有编译器知道这个类型名字，可以认为它是一个未命名类型。\n下面来看几个应用：\n[]{ std::cout \u0026lt;\u0026lt; \u0026#34;Yuuki_Dach\u0026#39;s Blog.(The MADAO)\u0026#34; \u0026lt;\u0026lt; std::endl; }(); //这里直接输出,而且没有参数传入，所以最后是()  std::string lambdaReturn = [](const std::string \u0026amp;str)-\u0026gt;std::string{ return \u0026#34;hello \u0026#34; + str; }(\u0026#34;hahaya\u0026#34;); std::cout \u0026lt;\u0026lt; lambdaReturn \u0026lt;\u0026lt; std::endl; //这里则是用lambdaReturn这个变量储存了其结果  auto addFunc = [](int val){std::cout \u0026lt;\u0026lt; val + 2 \u0026lt;\u0026lt; std::endl; }; std::for_each(a.begin(), a.end(), addFunc); //这里产生了一个匿名对象，保存在func中 std::function 看了前面的auto这个例子的话，就可以讲一讲std::function了\n类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹。\n比如前面的例子中auto部分也能这样写：\nstd::funtion\u0026lt;void(int)\u0026gt; addFunc = [](int val){std::cout \u0026lt;\u0026lt; val + 2 \u0026lt;\u0026lt; std::endl; }; std::for_each(a.begin(), a.end(), addFunc); std::bind std::bind可用于绑定函数、成员函数、函数对象、成员变量，如：\nint testFunc(int a, char c, float f){ cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return a; } auto bindFunc = std::bind(testFunc, std::placeholders::_2, std::placeholders::_1, 100.1); bindFunc(\u0026#39;B\u0026#39;, 10); 后面的bindFunc部分相当于执行了testFunc(10, \u0026lsquo;B\u0026rsquo;, 100.1)。\nstd::placeholders::_1是占位符，表示对应参数的位置和函数的第一个参数相匹配，以此类推。\n关于std::bind，再提两点比较重要的部分\n bind预先绑定的参数需要传具体的变量或值进去，对于预先绑定的参数，是pass-by-value的； 对于不事先绑定的参数，需要传std::placeholders进去，从_1开始，依次递增。placeholder是pass-by-reference的。   基本就是这些内容了，有错误的地方还请指正。大家也可以看看参考文章，还是很有帮助的(^_^)\n参考文章  C++11 新特性：Lambda 表达式 函数对象、lambda、function、bind学习 C++11中的std::function C++ 新特性学习（四） — Bind和Function C++11中的std::bind  ","date":"2016-09-04T00:00:00Z","permalink":"https://yuukidach.github.io/p/c-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambdafunctionbind%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","title":"C++函数对象，Lambda，function，bind相关知识"},{"content":"Problem 这个问题要带图才能方便理解题意，这里为了节省时间，大家自己去网站看题目就好。我真是太懒了 :p\nInput The first line of input is an integer T (T \u0026lt; 1000) that indicates the number of test cases. Each case contains 3 integers K, A and B. The meanings of these variables are mentioned above. K will be in the range [0, 30] and 1 ≤ A ≤ B ≤ 2K.\nOutput For each case, output the case number followed by the total number of red balloons in rows [A, B] after K-th hour.\nSample Input 3 0 1 1 3 1 8 3 3 7 Sample Output Case 1: 1 Case 2: 27 Case 3: 14 Solution 这道题目递归求解即可。\n用solve(k,i)表示i行及其以上的红球数量，然后根据i大于2K-1的一半与否，求出k-1时对应的状态，直到递推边界。\n这里用了一个节省了一点时间的办法，就是用idx数组将需要预先知道的3的倍数储存了起来，方便之后的搜索。（这是我AC之后在网上看到的方法）\n#include \u0026lt;iostream\u0026gt;using namespace std; long long k, a, b, tot; long long idx[31] = {1}; long long solve(long long k, long long i){ if (!i) return 0; if (!k) return 1; if (i \u0026gt; (1LL \u0026lt;\u0026lt; k-1)) return (solve(k-1, i-(1LL \u0026lt;\u0026lt; k-1)) + 2 * idx[k-1]); return 2 * solve(k-1, i); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int cas, n = 0; cin \u0026gt;\u0026gt; cas; for (int i = 1; i \u0026lt; 30; ++i) idx[i] = 3 * idx[i-1]; while (++n \u0026lt;= cas){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; tot = solve(k, b) - solve(k, a-1); cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;: \u0026#34;\u0026lt;\u0026lt; tot \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-04T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-12627-erratic-expansion/","title":"UVa OJ 12627 - Erratic Expansion"},{"content":"Problem 有n（n≤5000）个数的集合S，每次可以从S中删除两个数，然后把它们的和放回集合， 直到剩下一个数。每次操作的开销等于删除的两个数之和，求最小总开销。所有数均小于 105。\nInput Each test case will start with a positive number, N (2 ≤ N ≤ 5000) followed by N positive integers (all are less than 100000). Input is terminated by a case where the value of N is zero. This case should not be processed.\nOutput For each case print the minimum total cost of addition in a single line.\nSample Input 3 1 2 3 4 1 2 3 4 0 Sample Output 9 19 Solution 题目很简单，就是最小的两个数相加，用优先队列只要几行代码就能完成。但是我为什么还要发一篇文章呢？因为通过这道题目，我知道了一个新的头文件 \u0026lt;functional\u0026gt; . 这里面包含了C++11的一些新特性，用于帮助构造“函数对象”（也称为函子）及其绑定程序。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;functional\u0026gt;using namespace std; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, ans, temp, a, b; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; num; while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n){ ans = 0; for (int i = 0; i \u0026lt; n; ++i){ cin \u0026gt;\u0026gt; temp; num.push(temp); } for (int i = 0; i \u0026lt; n - 1; ++i){ a = num.top(); num.pop(); b = num.top(); num.pop(); num.push(a+b); ans += a + b; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; num.pop(); } return 0; } ","date":"2016-09-03T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-10954-add-all/","title":"UVa OJ 10954 - Add All"},{"content":"Problem 把一个包含m个正整数的序列划分成k个（1≤k≤m≤500）非空的连续子序列，使得每个正 整数恰好属于一个序列。设第i个序列的各数之和为S(i)，你的任务是让所有S(i)的最大值尽 量小。例如，序列1 2 3 2 5 4划分成3个序列的最优方案为1 2 3 | 2 5 | 4，其中S(1)、S(2)、S(3) 分别为6、7、4，最大值为7；如果划分成1 2 | 3 2 | 5 4，则最大值为9，不如刚才的好。每个 整数不超过107。如果有多解，S(1)应尽量小。如果仍然有多解，S(2)应尽量小，依此类推\nInput The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers m and k, 1 ≤ k ≤ m ≤ 500. At the second line, there are integers p1, p2, . . . , pm separated by spaces. All these values are positive and less than 10000000.\nOutput For each case, print exactly one line. The line must contain the input succession p1, p2, . . . pm divided into exactly k parts such that the maximum sum of a single part should be as small as possible. Use the slash character (‘/’) to separate the parts. There must be exactly one space character between any two successive numbers and between the number and the slash.\nIf there is more than one solution, print the one that minimizes the work assigned to the first scriber, then to the second scriber etc. But each scriber must be assigned at least one book.\nSample Input 2 9 3 100 200 300 400 500 600 700 800 900 5 4 100 100 100 100 100 Sample Output 100 200 300 400 500 / 600 700 / 800 900 100 / 100 / 100 / 100 100 Solution 这道题目基本就是二分加贪心，先确定二分的最值，然后从右往左一步步贪心求范围。不过要记得题目有限制必须是K个区域。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int maxn = 505; long long num[maxn], sum[maxn]; char idx[maxn],a[maxn]; long long leftt,rightt,mid; int m,k,n; inline bool binSearch(){ long long val = 0; int cnt = 0; memset(idx, 0, sizeof(idx)); for(int i = m; i \u0026gt;= 1; --i){ if(val+num[i] \u0026lt;= mid \u0026amp;\u0026amp; i \u0026gt;= k-cnt) val += num[i]; else{ cnt++; val = num[i]; idx[i] = 1; } } if(cnt == k-1){ memcpy(a, idx ,sizeof(idx)); return true; } return false; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int cas; cin \u0026gt;\u0026gt; cas; while(cas--){ rightt = leftt = 0; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for(int i = 1; i \u0026lt;= m; ++i){ cin \u0026gt;\u0026gt; num[i]; rightt += num[i]; leftt = num[i]\u0026gt;leftt ? num[i]:leftt; } while(rightt \u0026gt;= leftt){ mid = (leftt+rightt) \u0026gt;\u0026gt; 1; if(binSearch()) rightt = mid -1; else leftt = mid+1; } for(int i = 1; i \u0026lt; m; ++i){ cout \u0026lt;\u0026lt; num[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; if (a[i] == 1) cout \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; num[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-09-01T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-714-copying-books/","title":"UVa OJ 714 - Copying Books"},{"content":"Problem 给定一个长度为n的01串，选一个长度至少为L的连续子串，使得子串中数字的平均值最 大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号 为1～n，因此[1,n]就是完整的字符串。1≤n≤100000，1≤L≤1000。\n例如，对于如下长度为17的序列00101011011011010，如果L=7，最大平均值为6/8（子 序列为[7,14]，其长度为8）；如果L=5，子序列[7,11]的平均值最大，为4/5。\nInput Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers n (1 ≤ n ≤ 100, 000) and L (1 ≤ L ≤ 1, 000) which are the length of a binary sequence and a length lower bound, respectively. In the next line, a string, binary sequence, of length n is given.\nOutput Your program is to write to standard output. Print the starting and ending index of the subsequence.\nSample Input 2 17 5 00101011011011010 20 4 11100111100111110000 Sample Output 7 11 6 9 Solution 说来惭愧，这道题目我WA了快一面了。一开始看错题目，提交了好多次都错了，自己还没反应过来，一个劲傻傻地改。后来发现的时候，已经没有做下去的兴致了。\n不过最终还是把题目完成了的。总的来说，这道题目还是让我有些收获的。题目的解题思路是通过将数列转化成坐标轴上的图像，平均值这时候也就变成了斜率了。然后一个个点去维护下凸函数的单调数列，找到最优解。\n一开始我的cntAverage()这个函数只有三个参数，使用的是除法，提交之后花了0.1s，自己感觉慢了。于是把除法改成了现在的乘法，时间缩短一半，变成了0.05s。可见乘法和除法在计算的效率上还是相差很多的。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; const int maxn = 100005; int n, L, start, ending,temp; double maxd; int DNA[maxn],cav[maxn]; string str; inline int cntAverage(int L, int r, int LL, int rr, int DNA[]){ return (DNA[r]-DNA[L])*(rr-LL) - (DNA[rr]-DNA[LL])*(r-L); } inline void changePoint(int pits,int bump){ double temp; temp = cntAverage(pits, bump, start-1, ending, DNA); if (temp \u0026lt; 0) return; if (temp || (bump-pits) \u0026lt; (ending-start+1)){ maxd = temp; start = pits + 1; ending = bump; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); int cas; cin \u0026gt;\u0026gt; cas; while (cas--){ int find = 0, cor = -1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; cin.get(); getline(cin, str); for (int i = 1; i \u0026lt;= n; ++i) DNA[i] = DNA[i-1] + (str[i-1] == \u0026#39;1\u0026#39;); maxd = DNA[L] / L, start = 1, ending = L; for (int i = L; i \u0026lt;= n; ++i){ temp = i - L; while (find \u0026lt; cor \u0026amp;\u0026amp; cntAverage(cav[cor], temp, cav[cor - 1], cav[cor], DNA) \u0026lt;= 0) --cor; cav[++cor] = temp; while (find \u0026lt; cor \u0026amp;\u0026amp; cntAverage(cav[find], i, cav[find + 1], i, DNA) \u0026lt;= 0) ++find; changePoint(cav[find],i); } cout \u0026lt;\u0026lt; start \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ending \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-08-29T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1451-average/","title":"UVa OJ 1451 - Average"},{"content":"Problem After the last war devastated your country, you - as the king of the land of Ardenia - decided it was high time to improve the defense of your capital city. A part of your fortification is a line of mage towers, starting near the city and continuing to the northern woods. Your advisors determined that the quality of the defense depended only on one factor: the length of a longest contiguous tower sequence of increasing heights. (They gave you a lengthy explanation, but the only thing you understood was that it had something to do with firing energy bolts at enemy forces).\nAfter some hard negotiations, it appeared that building new towers is out of question. Mages of Ardenia have agreed to demolish some of their towers, though. You may demolish arbitrary number of towers, but the mages enforced one condition: these towers have to be consecutive.\nFor example, if the heights of towers were, respectively, 5, 3, 4, 9, 2, 8, 6, 7, 1, then by demolishing towers of heights 9, 2, and 8, the longest increasing sequence of consecutive towers is 3, 4, 6, 7.\nInput The input contains several test cases. The first line of the input contains a positive integer Z ≤ 25, denoting the number of test cases. Then Z test cases follow, each conforming to the format described below.\nThe input instance consists of two lines. The first one contains one positive integer n ≤ 2 · 105denoting the number of towers. The second line contains n positive integers not larger than 109separated by single spaces being the heights of the towers.\nOutput For each test case, your program has to write an output conforming to the format described below.\nYou should output one line containing the length of a longest increasing sequence of consecutive towers, achievable by demolishing some consecutive towers or no tower at all.\nSample Input 2 9 5 3 4 9 2 8 6 7 1 7 1 2 3 10 4 5 6 Sample Output 4 6 Solution 这道题目可以用O(n)的时间先遍历一遍，把以数列中各个数字作为起始和截止的小区间长度分别表示出来，然后再取一个数组，使着以每个区间长度为下标，以区间所在的最后一个数字为值，不断的去优化这个数组，即可得出结果。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int maxn = 2*1e5+1; int n,ans; int a[maxn],g[maxn],f[maxn],bin[maxn]; int main(){ ios::sync_with_stdio(false); cin.tie(0); int cas; cin \u0026gt;\u0026gt; cas; while (cas--){ cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i){ cin \u0026gt;\u0026gt; a[i]; if (a[i]\u0026gt;a[i - 1]) g[i] = g[i - 1] + 1; else g[i] = 1; } a[n + 1] = 0; for (int i = n; i \u0026gt; 0; --i){ if (a[i] \u0026lt; a[i + 1]) f[i] = f[i + 1] + 1; else f[i] = 1; } ans = 0; memset(bin, 0x7f, sizeof(bin)); bin[0] = -1; for (int i = 1; i \u0026lt;= n; ++i){ ans = max(ans, int(f[i]+lower_bound(bin, bin+n, a[i])-bin-1)); bin[g[i]] = min(bin[g[i]], a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-08-26T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1471-defense-lines/","title":"UVa OJ 1471 - Defense Lines"},{"content":"Problem 输入一个长度为n（n≤106）的序列A，找到一个尽量长的连续子序列AL～AR，使得该序 列中没有相同的元素。\nInput The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing an integer n, the number of snowflakes processed by the machine. The following n lines each contain an integer (in the range 0 to 109, inclusive) uniquely identifying a snowflake. Two snowflakes are identified by the same integer if and only if they are identical.\nThe input will contain no more than one million total snowflakes.\nOutput For each test case output a line containing single integer, the maximum number of unique snowflakes that can be in a package.\nSample Input 1 5 1 2 3 2 1 Sample Output 3 Solution 这道题目不是很复杂，只要设定一个指向区间末端，一个指向数组首端的变量，然后随着区间的移动而偏移即可。\n值得一说的是，这道题目可以说是题目中自带了一个bug,就是输入的数字最大值的问题。我一开始是使用set容器来完成这道题目，耗时0.27s，看到快的人都只用0.07s左右，我自然是希望能把效率尽量提升上去的。于是乎，我就试着把set直接替换成一个数组，来存储我所指到过的数字。\n一开始看到最大的数字是109，而数组并不能开到这么大，因此我就随便把数组开小了点，抱着肯定不能通过的心态，还是想提交一次试试，结果竟然过了，而且只用了0.05s。这里我就把我用时最少的代码贴出来，不过投机取巧的方式终究还是不可靠的，大家最好还是按部就班的来吧。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; int snowflakes[1000000+1]; int idx[1000000 + 1]; int n; int main(){ ios::sync_with_stdio(false); cin.tie(0); int cas; cin \u0026gt;\u0026gt; cas; while (cas--){ int maxSnow = 0; int l = 0, r = 0; memset(idx, 0, sizeof(idx)); cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ cin \u0026gt;\u0026gt; snowflakes[i]; } while (r \u0026lt; n){ while (r \u0026lt; n \u0026amp;\u0026amp; !idx[snowflakes[r]]) idx[snowflakes[r++]] = 1; maxSnow = max(maxSnow, r - l); idx[snowflakes[l++]] = 0; } cout \u0026lt;\u0026lt; maxSnow \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-08-25T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11572-unique-snowflakes/","title":"UVa OJ 11572 - Unique Snowflakes"},{"content":"先说一点题外话\n最近一段时间临近开学，要处理的事情很多，更新博客的速度也慢了下来，开学以后也大概就是这个速度了吧。\n关于这个博客的建立过程，我还是想稍微再提一下。从一开始的landscape到icarus主题，再回到默认的landscape，中间还是发生了许多事情。主要的一个原因还是landscape给我们展示文章的空间更大一些，方便阅读。而且自己修改起来也比较方便。\n至于主色调。因为自己经常长时间看着屏幕，所以希望能看到比较缓和一点的颜色，没有那么刺眼。因此选中了黑色。在自己改变了几处地方之后，意外的发现和 Morris\u0026rsquo;s Blog 很相似。鉴于自己在网页设计这方面基础近乎为0，后来的一些更新，或多或少都有借鉴他的一些东西，包括这里要提到的文章栏里Read More这个按钮。\n 下面还是快点进入正题吧。\n这个按钮是我学习jQuery的一个开端，或者说，是起因。\n那么什么是jQuery呢？\n jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript.\n 简单的说，jQuery就是一个JavaScript的库，和我们C++中使用\u0026quot;Algorithm\u0026quot;这个头文件是差不多的意思，是方便我们进行开发用的。利用它，我们可以用很短的代码，写出需要的结果。\n我这里的Read More按钮，在写它的js文件之前，先对CSS进行了一定的更改，包括改变了首页文章评论和分享按钮的位置；给文章预览页面添加上文字渐隐的效果。\n其中，文字渐隐的效果是通过图片叠加在文字上的方式，不过这里的图片，是利用 background-image 这个值来完成。比起用链接类型的图片，在效率上好了许多。\n在准备工作都完成之后，就是对按钮进行js文件的编写了。一开始，我使用了一个独立的js文件来完成，完成方式是使用两个类，然后addClass和removeClass来进行。先利用id选中文章，点击按钮后就移除div中的相应类，使得文章的高度不受限制，展开文章。再次单击按钮，则在div部分加上相应的类，文章就被收起来了。\n但是这个方法有一点问题，就是因为是通过id来选择，会使得只有第一篇文章具有这种效果，而之后的文章，单击按钮就没有效果了。\n后来换成了通过选择类的方式，而不是id的方式，解决了这个问题。\n另外，在使用.prev()的时候，要注意一下，不能有JavaScript插在this元素的前面，否则.prev()不能选取到我们需要的元素。\n因为是很多文件关联在一起，可以直接去我的github: Yuuki_Dach\u0026rsquo;s GitHub 上看代码，这里就不一一贴出来了。\n","date":"2016-08-24T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2read-more%E6%8C%89%E9%92%AE%E7%9A%84%E6%94%B9%E8%BF%9B/","title":"关于博客Read More按钮的改进"},{"content":" Don’t Dissect the Frog, Build It.\n 这句话在之前的一篇文章就提到过了。光是看是没有用的，要自己实践之后，才能理解一个东西，从而有所收获。\n最近在一点点完善自己的博客。随着改动地程度不断加大，对于Hexo的理解就显得不够了。因此，在博客开了一个月了才来写这篇文章，也算是一种亡羊补牢吧。\nlayout模板  Every templates apply to layout template by default.\n Hexo的主题布局都在layout文件夹下，每个模板都是用layout.ejs作为布局。以我这里的文件为例。打开layout.ejs，里面的内容如下：\n\u0026lt;%- partial(\u0026#39;_partial/head\u0026#39;) %\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/header\u0026#39;, null, {cache: !config.relative_link}) %\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;section id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;%- body %\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;% if (theme.sidebar \u0026amp;\u0026amp; theme.sidebar !== \u0026#39;bottom\u0026#39;){ %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/sidebar\u0026#39;, null, {cache: !config.relative_link}) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/footer\u0026#39;, null, {cache: !config.relative_link}) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/mobile-nav\u0026#39;, null, {cache: !config.relative_link}) %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/after-footer\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里包含了一个完整的界面，有header, siderbar, footer等。这些都能在layout文件夹下找到对应的文件。\n而其中的\u0026lt;%- body %\u0026gt;部分则是要被对应的index, post, page, archive, category和tag来代替。再打开post.ejs之类的文件，会发现，其实都是利用了partial局部模块。\n现在让我们来详细的看一看这些ejs文件里面的内容吧。以我现在正在更改的archive.ejs为例，贴出部分代码来一起探讨一下。\n\u0026lt;% page.posts.each(function(post){ %\u0026gt; \u0026lt;%- partial(\u0026#39;article\u0026#39;, {post: post, index: true}) %\u0026gt; \u0026lt;% }) %\u0026gt; 这一小段代码是一个循环，作用是将文章全部都列举出来。\npage是Hexo的全局变量，类似的还有site之类的，可以极大的方便我们布置自己的网页。\n至于第二行的partial，则是一个辅助函数。以{post:post}来填充\u0026rsquo;article'。\n关于更加详细的变量以及辅助函数的信息，大家可以去Hexo的官网找文档，里面有介绍，只是个人感觉介绍的不是很好，并不是很好用。\n","date":"2016-08-20T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84hexo%E5%AD%A6%E4%B9%A0/","title":"从零开始的Hexo学习"},{"content":"Problem 平面上有n（n≤1000）个点，每个点为白点或者黑点。现在需放置一条隔板，使得隔板一侧的白点数加上另一侧的黑点数总数最大。隔板上的点可以看作是在任意一侧。\nInput 不超过10个测试情况。每种情况以一个整数N开始，代表点的个数，接着输入N行x,y,r，分别表示坐标点的x坐标，y坐标和点的颜色，其中1是黑色。输入以0结束。\nOutput For each test case, output a line containing a single integer, which is the maximum number of dots we count.\nSample Input 3 0 0 0 0 1 0 2 2 1 4 0 0 0 0 4 0 4 0 0 1 2 1 7 -1 0 0 1 2 1 2 3 0 2 1 1 0 3 1 1 4 0 -1 2 0 0 Sample Output 3 3 6 Solution 扫描问题。只需要以一个点为基准点，然后做线，统计两边的点的数量就行。 在做这道题的时候，只是一个小小等式的区别，导致我TLE了好多次。后来也是测试了好久，才发现了这个问题。究其原因，还是取模太耗费时间，于是我就把取模的部分做了点修改，最终成功通过。 这里我利用先排序的方式，选好基准点之后，对每个点关于基准点的角度进行排序，然后才开始真正的扫描。\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; const int N=1001; class Point{ public: int x,y,color; double rad; bool operator\u0026lt;(const Point \u0026amp;rhs)const{ return rad\u0026lt;rhs.rad; } }dot[N],tempDot[N]; int n, num; bool isInArea(Point A,Point B){ return A.x*B.y-A.y*B.x\u0026gt;=0; } int main(){ ios::sync_with_stdio(false); cin.tie(0); while(cin\u0026gt;\u0026gt;n \u0026amp;\u0026amp; n){ for(int i=0;i\u0026lt;(n);i++) cin \u0026gt;\u0026gt; dot[i].x \u0026gt;\u0026gt; dot[i].y \u0026gt;\u0026gt; dot[i].color; if(n\u0026lt;=2) return 2; int ans=0; for(int i=0;i\u0026lt;n;i++){ num=0; for(int j=0;j\u0026lt;n;j++){ if(j == i) continue; tempDot[num].x=dot[j].x-dot[i].x; tempDot[num].y=dot[j].y-dot[i].y; if(dot[j].color){ tempDot[num].x=-tempDot[num].x; tempDot[num].y=-tempDot[num].y; } tempDot[num].rad=atan2(tempDot[num].y,tempDot[num].x); num++; } sort(tempDot,tempDot+num); int divi=0,scani=0,cnt=2; while(divi\u0026lt;num){ if(scani==divi){ scani=scani+1; if(scani \u0026gt;= num) scani = scani-num; cnt++; } while(scani!=divi \u0026amp;\u0026amp; isInArea(tempDot[divi],tempDot[scani])){ scani=scani+1; if(scani \u0026gt;= num) scani = scani-num; cnt++; } cnt--; divi++; ans=max(ans,cnt); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-08-16T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1606-amphiphilic-carbon-molecules/","title":"UVa OJ 1606 - Amphiphilic Carbon Molecules"},{"content":" 这些天在鼓捣博客，对界面所做的改动，也都是landscape这个主题的框架下所进行的。虽然说自由度相对于别的博客站点的自由度要高很多，但是自己没有一点网页编程知识的话，也是不能够讲网页完全设计成自己所喜欢的样子。因此在这里开一个类似于笔记本性质的文章吧，也方便我以后进行回忆。\nIntroduction  HTML指的是超文本标记语言 (Hyper Text Markup Language) HTML不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML使用标记标签来描述网页  Basic   HTML的链接通过\u0026lt;a\u0026gt;来进行定义\n\u0026lt;a href=\u0026ldquo;url\u0026rdquo;\u0026gt;link text\u0026lt;/a\u0026gt;\n  图像通过\u0026lt;img\u0026gt; \u0026lt;img src=\u0026ldquo;link\u0026rdquo; settings/\u0026gt;\n在src的后面还能加上alt 表示在图片加载不出来时显示的文字信息，如：\u0026lt;img src=\u0026ldquo;link\u0026rdquo; alt=\u0026ldquo;text\u0026rdquo; settings/\u0026gt;\n  Conditional comments defines some HTML tags to be executed by Internet Explorer only.\n  \u0026lt;!--[if IE 8]\u0026gt; .... some HTML here .... \u0026lt;![endif]--\u0026gt; The \u0026lt;title\u0026gt; element defines the title of the document, and is required in all HTML/XHTML documents.   defines a title in the browser tab provides a title for the page when it is added to favorites displays a title for the page in search engine results  页面布局不要用来进行，不然会引起不必要的麻烦，也不便于后续的工作  Elements ——from start tag to end tag\n  HTML元素就是开始标签和结束标签之间的东西,大多数可嵌套，推荐使用小写\n  HTML标签可以拥有属性，属性总是以名称/值对的形式出现，并且在HTML元素的开始标签中规定\n  属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号~~（和汉语写别人说的话一样）~~\n  CSS CSS stands for Cascading Style Sheets.\nCSS describes how HTML elements are to be displayed on screen, paper, or in other media.\nCSS can be added to HTML elements in 3 ways:\n Inline - by using the style attribute in HTML elements Internal - by using a \u0026lt;style\u0026gt; element in the section External - by using an external CSS file  其中最常使用分离的CSS文件\nAn internal CSS is defined in the section of an HTML page, within a \u0026lt;style\u0026gt; element:\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; body {background-color: powderblue;} h1 {color: blue;} p {color: red;} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; JavaScript JavaScript makes HTML pages more dynamic and interactive.\nThe \u0026lt;script\u0026gt; tag is used to define a client-side script (JavaScript).\n 写了这么几十行，其实并没有记录下什么内容，因为感觉和markdown实在是太像了，所以大部分都没有写下来。大家如果也是初学的话可以去w3school看看，有英文版和中文版两种，英文版的界面特别舒服。网址就不贴了，大家Google或者百度一下都能找到的。\n之前看到了一句话，感觉特别好，大概就是说，想要知道一只青蛙的构造，最好的方式不是去解剖青蛙，而是去构造一只青蛙。学习一门新的编程语言也确实是如此。要自己定下一个目标，去实现它，而不是漫无目的地去学。\n另外，右键查看网页源码还是非常有必要的，之前用这个方法把文章封面问题给解决了，还是蛮高兴的。\n","date":"2016-08-14T00:00:00Z","permalink":"https://yuukidach.github.io/p/get-start-with-html/","title":"Get Start With HTML"},{"content":"Problem As you may know from the comic “Asterix and the Chieftain’s Shield”, Gergovia consists of one street, and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simple enough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides how much wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that each inhabitant gets what he wants. There is one problem, however: Transporting wine from one house to another results in work. Since all wines are equally good, the inhabitants of Gergovia don’t care which persons they are doing trade with, they are only interested in selling or buying a specific amount of wine. They are clever enough to figure out a way of trading so that the overall amount of work needed for transports is minimized. In this problem you are asked to reconstruct the trading during one day in Gergovia. For simplicity we will assume that the houses are built along a straight line with equal distance between adjacent houses. Transporting one bottle of wine from one house to an adjacent house results in one unit of work.\nInput The input consists of several test cases. Each test case starts with the number of inhabitants n (2 ≤ n ≤ 100000). The following line contains n integers ai (−1000 ≤ ai ≤ 1000). If ai ≥ 0, it means that the inhabitant living in the i-th house wants to buy ai bottles of wine, otherwise if ai \u0026lt; 0, he wants to sell −ai bottles of wine. You may assume that the numbers ai sum up to 0. The last test case is followed by a line containing ‘0’.\nOutput For each test case print the minimum amount of work units needed so that every inhabitant has his demand fulfilled. You may assume that this number fits into a signed 64-bit integer (in C/C++ you can use the data type “long long”, in JAVA the data type “long”).\nSample Input 5 5 -4 1 -3 1 6 -1000 -1000 -1000 1000 1000 1000 0 Sample Output 9 9000 Solution 这道题目难度并不大，不想去翻译了。但是这道题目却给了我一些意外的收获，相当于大家所说的“奇技淫巧”吧，还有一些其他的感悟。 这道题我先试按照传统的方式，利用scanf和printf进行输入输出，运行时间是0.02s，后来看了下别人的运行时间，不出所料，最短的0.00s，接着就是0.01s了。 那么问题来了，我的程序，可以说，已经十分的简洁了，为什么还会比最快的慢0.02s呢？于是乎，博主回忆起了过去曾经看到的一个C++程序。在那个程序里，编程者利用了sync_with_stdio对stdio进行了解绑，然后直接利用cin和cout输入输出。 接下来，博主就对程序进行了更改和尝试。在不抱太大希望的情况下，提交了程序，最后的看了下运行时间O.OOs！，终于把那0.02s给续出去了。过两天可能开一篇短文章，稍微探讨一下个中原因。 此外，在用notepad++进行编译的时候发现，MinGW对lld这种写法是不支持的，要写成I64d。abs在C++98也只能重载到long int，在C++11下才能重载到long long int，所以大家在提交的时候一定要看仔细了。 下面是我的代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, a; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n){ long long total = 0, temp = 0; while(n--){ cin \u0026gt;\u0026gt; a; total += abs(temp); temp += a; } cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2016-08-14T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11054-wine-trading-in-gergovia/","title":"UVa OJ 11054 - Wine trading in Gergovia"},{"content":"Problem  在n*n的棋盘上放n（n≤5000）个车，使得任意两个车不相互攻击，且第i个 车在一个给定的矩形Ri之内。用4个整数xli, yli, xri, yri（1≤xli≤xri≤n，1≤yli≤yri≤n）描述第i个 矩形，其中(xli,yli)是左上角坐标，(xri,yri)是右下角坐标，则第i个车的位置(x,y)必须满 足xli≤x≤xri，yli≤y≤yri。如果无解，输出IMPOSSIBLE；否则输出n行，依次为第1,2,…,n个车 的坐标。\nInput The input consists of several test cases. The first line of each of them contains one integer number, n, the side of the board. n lines follow giving the rectangles where the rooks can be placed as described above. The i-th line among them gives xli, yli, xri, and yri. The input file is terminated with the integer ‘0’ on a line by itself.\nOutput Your task is to find such a placing of rooks that the above conditions are satisfied and then output n lines each giving the position of a rook in order in which their rectangles appeared in the input. If there are multiple solutions, any one will do. Output ‘IMPOSSIBLE’ if there is no such placing of the rooks.\nSample Input 8 1 1 2 2 5 7 8 8 2 2 5 5 2 2 5 5 6 3 8 6 6 3 8 5 6 3 8 8 3 6 7 8 Sample Output 1 1 5 8 2 4 4 2 7 3 8 5 6 6 3 7 Solution  这道题用贪心法就能够完成了，可以从整体去考虑，也可以从X和Y轴两个部分去考虑，分别使用贪心法来找到点的坐标。\n 我两个方法都尝试了一下，一开始是自己整块的去考虑，成功AC，然后看了看别人解题的方式，也试着讲X和Y分开来试了下，速度都差不多。但是在用X和Y分开来的时候，出了点状况。就是在希望代码不重复，而对贪心这个步骤进行函数封装的时候，本地测试，使用函数和不实用函数封装，得到的结果都是一样的。但是提交到OJ上的时候，没有函数封装的代码能AC，而封装过的会WA，不管怎么改都是WA。个人比较倾向于可能是在不懂的环境下，传指针的影响会有差别。 不过真正是什么原因，还是有待考究。\n 下面我把AC的代码贴出来。原来利用整块操作的代码不小心被覆盖了，这里就只放出对X和Y分别贪心的做法。\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;set\u0026gt;using namespace std; const int maxn = 5100; int n, possi; set\u0026lt;int\u0026gt; setX, setY; int idxX[maxn], idxY[maxn]; class rect{ public: int l, r, id; bool operator\u0026lt;(rect \u0026amp;); } rectX[maxn],rectY[maxn]; bool rect::operator\u0026lt; (rect \u0026amp;rectB){ return r \u0026lt; rectB.r; } inline void inputRect(){ setX.clear(); setY.clear(); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;rectX[i].l, \u0026amp;rectY[i].l, \u0026amp;rectX[i].r, \u0026amp;rectY[i].r); rectX[i].id = rectY[i].id = i; setX.insert(i); setY.insert(i); } setX.insert(maxn); setY.insert(maxn); } int main(){ while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1 \u0026amp;\u0026amp; n){ inputRect(); sort(rectX+1, rectX+n+1); sort(rectY+1, rectY+n+1); possi = true; for (int i = 1; i \u0026lt;= n \u0026amp;\u0026amp; possi; ++i) { int tempX = *setX.lower_bound(rectX[i].l); if (tempX \u0026gt; rectX[i].r) { possi = false; } idxX[rectX[i].id] = tempX; setX.erase(tempX); int tempY = *setY.lower_bound(rectY[i].l); if (tempY \u0026gt; rectY[i].r) { possi = false; } idxY[rectY[i].id] = tempY; setY.erase(tempY); } if (possi) for (int i = 1; i \u0026lt;= n; ++i) printf(\u0026#34;%d %d\\n\u0026#34;, idxX[i], idxY[i]); else printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); } return 0; } ","date":"2016-08-10T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11134-fabled-rooks/","title":"UVa OJ 11134 - Fabled Rooks"},{"content":"——Code, without tests, is not clean. No matter how elegant it is, no matter how readable and accessible, if it hath not tests, it be unclean.\n——没有测试的代码不干净。不管它有多优雅，不管有多可读、多易理解，微乎测试，其不洁亦可知也。\n 这两天看了下Clean Code这本书，感觉还是有一些收获。同时也对之前自己在学习STM32所使用的库函数，有了一个更加深入的了解。嘛，下面就把看到的一些东西做个笔记吧，时不时可能会加上一点。\nBasic Principles\n  Runs all the tests\n  Contains no duplication\n  Expresses all the design ideas that are in the system\n  Minimizes the number of entities such as classes, methods, functions, and the like\n   Use Meaningful Names\n  Use intention-revealing names\n  Avoid disinformation\n  Make meaningful distinctions\n  Use pronounceable names\n  Use searchable names\n  Avoid encodings\n  做有意义的命名\n  用揭示目的的名称\n  避免误导\n  做有意义的区分\n  使用可以读出来的名称\n  使用可搜索的名称\n  避免使用编码\n   这个“避免使用编码”还是让我感觉有点意外啊。一直感觉前缀什么的是挺好的一个习惯。之前在看51单片机的一本书的时候，也有推荐加上前缀的，看来以后的代码习惯还是要好好改改啊。包括在调用STM32库函数的时候，现在都形成了不同单词间加上下划线的习惯了。嘛，不过感觉加下划线还不是什么不可取的事情，毕竟不同公司会有不同的规定吧。ST公司给的库函数加上下划线也让函数变得更易读了。\n","date":"2016-08-10T00:00:00Z","permalink":"https://yuukidach.github.io/p/way-to-clean-code/","title":"Way to Clean Code"},{"content":"Problem 给定4个n（1≤n≤4000）元素集合A, B, C, D，要求分别从中选取一个元素a, b, c, d，使得 a+b+c+d=0。问：有多少种选法？\nInput The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.\n The first line of the input file contains the size of the lists n (this value can be as large as 4000). We then have n lines containing four integer values (with absolute value as large as 2^{28}) that belong respectively to A, B, C and D.\nOutput For each test case, your program has to write the number quadruplets whose sum is zero. The outputs of two consecutive cases will be separated by a blank line.\nSample Input 1 6 -45 22 42 -16 -41 -27 56 30 -36 53 -37 77 -36 30 -75 -46 26 -38 -10 62 -32 -54 -6 45 Sample Output 5 Sample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46), (-32, 30, -75, 77), (-32, -54, 56, 30).\nSolution  这道题目思路大家都有，做倒是都能做得出来。但是写代码，不能光考虑答案，还要考虑代码的效率。高效的代码不仅让我们更有成就感，更多的，是对我们能力的锻炼和提升。\n 做这道题目的时候，我第一反应使用哈希表来做，应为哈希表能将搜寻的时间复杂程度降到O(1)。但是真实写起来，倒是遇到了一些麻烦。为了能够尽量的压缩时间，我把测试了一些数据，也和二分查找法进行了比较。RE, CE, TLE的情况都遇到了。下面就稍微具体的说下测试过程吧\n 因为对于哈希表，选择了不同的哈希函数，哈希表的效率也不一样。我最开始是使用斐波那契散列，但是出现了TLE的情况，限于能力有限，没能有效改善代码效率。于是我换成了除法散列。除法散列不同的除数能带来不同的效果，也有会TLE的，但是好好选取的话时间能压缩到很短。我给出的代码里，是我随便选取的一个数字，不是最优的情况，感兴趣的话，可以在这基础上自己改善。\n 测试完了哈希表，我也用了简单直接的二分法来解决这个问题，虽然编写简单，但是效率还是没有哈希表来的要高。\n 额外补充一下，对于abs这个函数，大家在用的时候记得强制装换一下，不然会出现Compilation Error的情况 T^T\n 说了这么多，我还是上代码吧。网上基本没看到用哈希表做这个题目的，希望能给大家一点帮助吧。\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; class hashTab{ public: int v, next = 0, num = 0; } hashNode[16000001]; int menu[33554433], d; void creatHash(int x){ int idx = (int)(abs(x)) % 33554432; int cur, pre = 0; cur = menu[idx]; while (cur != 0){ if (hashNode[cur].v == x){ hashNode[cur].num++; return; } else { pre = cur; cur = hashNode[cur].next; } } ++d; if (!pre) menu[idx] = d; else hashNode[pre].next = d; hashNode[d].v = x; hashNode[d].num = 1; hashNode[d].next = 0; } int getCnt(int x){ int idx = (int)(abs(x)) % 33554432; int cur, pre = 0; cur = menu[idx]; while (cur != 0){ if (hashNode[cur].v == x) return hashNode[cur].num; else{ pre = cur; cur = hashNode[cur].next; } } return 0; } int main(){ int cas,n,ans; int A[4000], B[4000], C[4000], D[4000]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;cas); while (cas--){ ans = d = 0; memset(menu, 0, sizeof(menu)); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;A[i], \u0026amp;B[i], \u0026amp;C[i], \u0026amp;D[i]); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) creatHash(A[i] + B[j]); for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) ans += getCnt(- C[i] - D[j]); printf(\u0026#34;%d\\n\u0026#34;, ans); if (cas) putchar(\u0026#39;\\n\u0026#39;); } return 0; } ","date":"2016-08-08T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1152-4-values-whose-sum-is-0/","title":"UVa OJ 1152 - 4 Values whose Sum is 0"},{"content":"Problem  你的任务是设计一个包含若干层的联合国大楼，其中每层都是一个等大的网格。有若干 国家需要在联合国大楼里办公，你需要把每个格子分配给一个国家，使得任意两个不同的国 家都有一对相邻的格子（要么是同层中有公共边的格子，要么是相邻层的同一个格子）。你设计的大厦最多不能超过1000000个格子。\nInput  输入国家的个数n（n≤50）。\nOutput  输出大楼的层数H、每层楼的行数W和列数L，然后是每层 楼的平面图.不同的国家用不同的大小写字母表示。\nSample Input 4 Sample Output 2 2 2 AB CC zz zz Solution  这个题目没有给定楼层限制，也没有给定国家占地的限制，那么就显得很简单了。因为只需要保证每一个国家和另外一个国家的办公室都有邻边。那么我们可以直接把第一层的每个行分给不同的国家，然后第二层的每个列也分给不同的国家，问题就解决了。下面是简单而粗糙的代码\n#include \u0026lt;cstdio\u0026gt;using namespace std; int main(){ int n,contry[55]; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1){ printf(\u0026#34;%d %d %d\\n\u0026#34;, 2, n, n); for (int i = 0; i \u0026lt; n; ++i){ for (int j = 0; j \u0026lt; n; ++j) printf(\u0026#34;%c\u0026#34;, i \u0026lt; 26 ? \u0026#39;a\u0026#39; + i : \u0026#39;A\u0026#39; + i - 26); putchar(\u0026#39;\\n\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); for (int i = 0; i \u0026lt; n; ++i){ for (int j = 0; j \u0026lt; n; ++j) printf(\u0026#34;%c\u0026#34;, j \u0026lt; 26 ? \u0026#39;a\u0026#39; + j : \u0026#39;A\u0026#39; + j - 26); putchar(\u0026#39;\\n\u0026#39;); } } return 0; } ","date":"2016-08-07T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1605-building-for-un/","title":"UVa OJ 1605 - Building for UN"},{"content":"Problem  有一叠煎饼正在锅里。煎饼共有n（n≤30）张，每张都有一个数字，代表它的大小，如 图8-11所示。厨师每次可以选择一个数k，把从锅底开始数第k张上面的煎饼全部翻过来，即 原来在上面的煎饼现在到了下面。\n 设计一种方法使得所有煎饼按照从小到大排序（最上面的煎饼最小）。输入时，各个煎 饼按照从上到下的顺序给出。\nInput The input consists of a sequence of stacks of pancakes. Each stack will consist of between 1 and 30 pancakes and each pancake will have an integer diameter between 1 and 100. The input is terminated by end-of-file. Each stack is given as a single line of input with the top pancake on a stack appearing first on a line, the bottom pancake appearing last, and all pancakes separated by a space.\n输入是一串薄饼的数据。每一串数据能有2到29个薄饼，并且每个薄饼的直径在1到100之间。输入以EOF结束。每串数据中，第一个数据时在最上面的饼，最后一个数据则是最下面的饼，所有的数据用空格间隔开来。\nOutput For each stack of pancakes, the output should echo the original stack on one line, followed by some sequence of flips that results in the stack of pancakes being sorted so that the largest diameter pancake is on the bottom and the smallest on top. For each stack the sequence of flips should be terminated by a 0 (indicating no more flips necessary). Once a stack is sorted, no more flips should be made.\n把你每一次翻薄饼的层数输出来，最后补充一个0，每个数据中间还是用空格隔开。\nSample Input 1 2 3 4 5 5 4 3 2 1 5 1 2 3 4 Sample Output 1 2 3 4 5 0 5 4 3 2 1 1 0 5 1 2 3 4 1 2 0 Solution 这道题目基本需要多加考虑，按照题目意思翻薄饼就行了。不过我从这题中还是有点收获，就是自己的代码格式太不好看了，而且不够简洁。还是花点时间看Clean Code吧\n下面是我的丑陋代码\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; int pancake[105], n, cnt; int flip[105], temp[105]; int main(){ string getcake; while (getline(cin, getcake)){ stringstream pan(getcake); memset(pancake, 0, sizeof(pancake)); memset(flip, 0, sizeof(flip)); n = cnt = 0; while (pan \u0026gt;\u0026gt; pancake[n++]); --n; for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%d \u0026#34;, pancake[i]); putchar(\u0026#39;\\n\u0026#39;); for (int i = n-1; i \u0026gt;= 0; --i){ int maxn = i - 1, idx = 0; for (int j = 0; j \u0026lt;= i; ++j){ if (maxn \u0026lt; pancake[j]){ maxn = pancake[j]; idx = j; } } if (idx == i) continue; if (idx == 0){ flip[cnt++] = n-i; memcpy(temp, pancake, sizeof(int)*(i + 1)); for (int k = i; k \u0026gt;= 0; --k) pancake[i - k] = temp[k]; continue; } flip[cnt++] = n - idx; memcpy(temp, pancake, sizeof(int)*(idx + 1)); for (int k = idx; k \u0026gt;= 0; --k) pancake[idx - k] = temp[k]; flip[cnt++] = n - i; memcpy(temp, pancake, sizeof(int)*(i + 1)); for (int k = i; k \u0026gt;= 0; --k) pancake[i - k] = temp[k]; } for (int i = 0; i \u0026lt; cnt; ++i) printf(\u0026#34;%d \u0026#34;, flip[i]); printf(\u0026#34;0\\n\u0026#34;); } return 0; } ","date":"2016-08-06T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-120-stacks-of-flapjacks/","title":"UVa OJ 120 - Stacks of Flapjacks"},{"content":"Problem  你有一篇由n（2≤n≤9）个自然段组成的文章，希望将它们排列成1, 2,…, n。可以用 Ctrl+X（剪切）和Ctrl+V（粘贴）快捷键来完成任务。每次可以剪切一段连续的自然段，粘贴时按照顺序粘贴。注意，剪贴板只有一个，所以不能连续剪切两次，只能剪切和粘贴交替。\n 例如，为了将{2,4,1,5,3,6}变为升序，可以剪切1将其放到2前，然后剪切3将其放到4 前。再如，对于排列{3,4,5,1,2}，只需一次剪切和一次粘贴即可——将{3,4,5}放在{1,2}后， 或者将{1,2}放在{3,4,5}前。\nInput The input consists of at most 20 test cases. Each case begins with a line containing a single integer n (1 \u0026lt; n \u0026lt; 10), thenumber of paragraphs. The next line contains a permutation of 1, 2, 3, . . . , n. The last case is followed by a single zero, which should not be processed.\n 输入的数据最多有二十种情况。每一种情况以一个整数n开头（1\u0026lt;n\u0026lt;10），代表了段落的数量。下一行则包含了从1到n的无序数列。最后一种情况以0结尾，表示输入结束，不用被执行。\nOutput For each test case, print the case number and the minimal number of cut/paste operations.\n输出每一种情况所需要移动的最少步骤。\nSample Input 6 2 4 1 5 3 6 5 3 4 5 1 2 0 Sample Output Case 1: 2 Case 2: 1 Solution 入门级的迭代加深搜索，题目不复杂，代码也不是很长。主要还是注意当前深度和乐观估计函数到底是什么。\n不过虽然是这样说，自己debug的时候也是出了点状况的，比如在进行数据前后的交换时，一开始没注意n的范围，直接把交换的范围取到了9，导致出现莫名其妙的数据错误。orz\n嘛，自己毕竟也是刚起步吧，一点点努力吧。下面就把代码贴出来，效率不高，见笑了。\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; int n,maxd; int para[10]; int geth(int a[]){ int num = 0; for (int i = 1; i \u0026lt; n; ++i) if (a[i] + 1 != a[i + 1]) num++; return num; } void change_para(int i, int j, int k, int a[]) { int temp1[10], temp2[10]; memcpy(temp1, a + i, sizeof(int)*j); memcpy(temp2, a + i + j, sizeof(int)*k); memcpy(a + i, temp2, sizeof(int)*k); memcpy(a + i + k, temp1, sizeof(int)*j); } bool isok(int a[]){ for (int i = 1; i \u0026lt;= n; ++i) if (i != a[i]) return false; return true; } bool dfs(int d, int paras[]){ if (d == maxd) if (isok(paras)) return true; int h = geth(paras); if (3 * d + h \u0026lt;= 3 * maxd) for (int i = 1; i \u0026lt; n; ++i) for (int j = 1; j \u0026lt;= n - i; ++j) for (int k = 1; k \u0026lt;= n + 1 - i - j; ++k){ int new_para[10]; memcpy(new_para, paras, sizeof(int)* 10); change_para(i, j, k, new_para); if (dfs(d + 1, new_para)) return true; } return false; } int main(){ int cas = 0; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1 \u0026amp;\u0026amp; n){ for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;para[i]); for (maxd = 0; maxd \u0026lt; n; ++maxd) if (dfs(0, para)) break; printf(\u0026#34;Case %d: %d\\n\u0026#34;, ++cas, maxd); } return 0; } ","date":"2016-08-05T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-11212-editing-a-book/","title":"UVa OJ 11212 - Editing a Book"},{"content":"Problem You are working for an amusement park as an operator of an obakeyashiki, or a haunted house, in which guests walk through narrow and dark corridors. The house is proud of their lively ghosts, which are actually robots remotely controlled by the operator, hiding here and there in the corridors. One morning, you found that the ghosts are not in the positions where they are supposed to be. Ah, yesterday was Halloween. Believe or not, paranormal spirits have moved them around the corridors in the night. You have to move them into their right positions before guests come. Your manager is eager to know how long it takes to restore the ghosts.\n In this problem, you are asked to write a program that, given a floor map of a house, finds the smallest number of steps to move all ghosts to the positions where they are supposed to be.\n A floor consists of a matrix of square cells. A cell is either a wall cell where ghosts cannot move into or a corridor cell where they can.\n At each step, you can move any number of ghosts simultaneously. Every ghost can either stay in the current cell, or move to one of the corridor cells in its 4-neighborhood (i.e. immediately left, right, up or down), if the ghosts satisfy the following conditions:\n1. No more than one ghost occupies one position at the end of the step.\n 2. No pair of ghosts exchange their positions one another in the step.\nInput The input consists of at most 10 datasets, each of which represents a floor map of a house. w, h and n in the first line are integers, separated by a space. w and h are the floor width and height of the house, respectively. n is the number of ghosts. They satisfy the following constraints.\n Subsequent h lines of w characters are the floor map. Each of cij is either: • a ‘#’ representing a wall cell, • a lowercase letter representing a corridor cell which is the initial position of a ghost, • an uppercase letter representing a corridor cell which is the position where the ghost corresponding to its lowercase letter is supposed to be, or • a space representing a corridor cell that is none of the above.\n In each map, each of the first n letters from a and the first n letters from A appears once and only once. Outermost cells of a map are walls; i.e. all characters of the first and last lines are sharps; and the first and last characters on each line are also sharps. All corridor cells in a map are connected; i.e. given a corridor cell, you can reach any other corridor cell by following corridor cells in the 4-neighborhoods. Similarly, all wall cells are connected. Any 2 × 2 area on any map has at least one sharp. You can assume that every map has a sequence of moves of ghosts that restores all ghosts to the positions where they are supposed to be. The last dataset is followed by a line containing three zeros separated by a space.\nOutput For each dataset in the input, one line containing the smallest number of steps to restore ghosts intothe positions where they are supposed to be should be output. An output line should not contain extra characters such as spaces.\nSample Input 5 5 2 ##### #A#B# # # #b#a# ##### 16 4 3 ################ ## ########## ## # ABCcba # ################ 16 16 3 ################ ### ## # ## ## # ## # c# # ## ########b# # ## # # # # # # ## # # ## ## a# # # # # ### ## #### ## # ## # # # # # ##### # ## ## #### #B# # # ## C# # ### # # # ####### # # ###### A## # # # ## ################ Sample Output 7 36 77 Solution  依旧是一道最短路径的题目。题目本身并不复杂，也没有太多的技巧性。和以往做过的最短路径题目的区别，无非是多了几个点，无形之中增加了程序的运行时间，但总体上的思路还是一样的。这里为了提高运行效率，利用了双向BFS。\n 题目给的时间上限是12s，这里所贴出的我的代码，运行时间是0.72s，还是比较可观的。在运用双向BFS的基础上，主要是利用了数组和建立空格图块的方法，来减少代码的运行时间。由于一开始看错题目，不想大改，所以代码显得略为冗长，但是便于理解。感兴趣的话，可以试着把代码段压缩一下，效率也会有所提升。\n 需要注意的地方是，用来存储队列的数组，尽量开大一些，避免还没找到重点，BFS就结束了。这道题我提交了三次，前两次都是queue_fro和queue_back开的太小，导致了WA。其余的无非就是注意一下在变量太多且名字相近的情况下，不要打错变量名字就行了。\n P.S:最近在处理很多别的东西，昨晚又捣鼓了半天系统，更新可能会慢一点吧。不过我知道，其实并没有什么人来看我博客啊！ T^T\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; #define pos_now link[i][j] #define pos_next link[i+next[0][k]][j+next[1][k]] #define pos_a conn[queue_fro[fro_fro].a][i] #define pos_b conn[queue_fro[fro_fro].b][j] #define pos_c conn[queue_fro[fro_fro].c][k] #define pos_A conn[queue_back[back_fro].a][i] #define pos_B conn[queue_back[back_fro].b][j] #define pos_C conn[queue_back[back_fro].c][k]  class Node{ public: int a; int b; int c; }; const int next[2][4] = { { 0, 1, 0, -1 }, { 1, 0, -1, 0 } }; int w, h, n, num; int link[20][20], conn[305][7], vis[305][305][305]; int beg[3], end[3]; int step_fro, step_back, back_fro, back_rear, fro_fro, fro_rear; Node queue_fro[4000000], queue_back[4000000]; char map[20][20]; void bfs(){ int fro_cnt = 1, back_cnt = 1; vis[beg[0]][beg[1]][beg[2]] = ++step_fro; vis[end[0]][end[1]][end[2]] = ++step_back; fro_fro = back_fro = 0; fro_rear = back_rear = 1; queue_fro[0].a = beg[0],queue_fro[0].b = beg[1],queue_fro[0].c = beg[2]; queue_back[0].a = end[0],queue_back[0].b = end[1],queue_back[0].c = end[2]; while (fro_fro \u0026lt; fro_rear){ ++step_fro; while (fro_cnt--){ for (int i = 0; pos_a != 0; ++i) for (int j = 0; pos_b != 0; ++j) for (int k = 0; pos_c != 0; ++k){ if (beg[2] != 303){ if (pos_a == queue_fro[fro_fro].b \u0026amp;\u0026amp; pos_b == queue_fro[fro_fro].a) continue; if (pos_a == queue_fro[fro_fro].c \u0026amp;\u0026amp; pos_c == queue_fro[fro_fro].a) continue; if (pos_b == queue_fro[fro_fro].c \u0026amp;\u0026amp; pos_c == queue_fro[fro_fro].b) continue; if (pos_a == pos_b || pos_a == pos_c || pos_b == pos_c) continue; } else if (beg[1] != 303){ if (pos_a == queue_fro[fro_fro].b \u0026amp;\u0026amp; pos_b == queue_fro[fro_fro].a) continue; if (pos_a == pos_b) continue; } if (vis[pos_a][pos_b][pos_c] \u0026gt; 1000) return; if (vis[pos_a][pos_b][pos_c] \u0026gt; 0) continue; vis[pos_a][pos_b][pos_c] = step_fro; queue_fro[fro_rear].a = pos_a; queue_fro[fro_rear].b = pos_b; queue_fro[fro_rear].c = pos_c; ++fro_rear; } ++fro_fro; } fro_cnt = fro_rear - fro_fro; ++step_back; while (back_cnt--){ for (int i = 0; pos_A != 0; ++i) for (int j = 0; pos_B != 0; ++j) for (int k = 0; pos_C != 0; ++k){ if (beg[2] != 303){ if (pos_A == queue_back[back_fro].b \u0026amp;\u0026amp; pos_B == queue_back[back_fro].a) continue; if (pos_A == queue_back[back_fro].c \u0026amp;\u0026amp; pos_C == queue_back[back_fro].a) continue; if (pos_B == queue_back[back_fro].c \u0026amp;\u0026amp; pos_C == queue_back[back_fro].b) continue; if (pos_A == pos_B || pos_A == pos_C || pos_B == pos_C) continue; } else if (beg[1] != 303){ if (pos_A == queue_back[back_fro].b \u0026amp;\u0026amp; pos_B == queue_back[back_fro].a) continue; if (pos_A == pos_B) continue; } if (vis[pos_A][pos_B][pos_C] \u0026gt; 1000) continue; if (vis[pos_A][pos_B][pos_C] \u0026gt; 0) return; vis[pos_A][pos_B][pos_C] = step_back; queue_back[back_rear].a = pos_A; queue_back[back_rear].b = pos_B; queue_back[back_rear].c = pos_C; ++back_rear; } ++back_fro; } back_cnt = back_rear - back_fro; } } int main(){ while (scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;w, \u0026amp;h, \u0026amp;n)==3 \u0026amp;\u0026amp; n){ getchar(); //初始化  memset(map, 0, sizeof(map)); memset(vis, 0, sizeof(vis)); memset(link, 0, sizeof(link)); memset(conn, 0, sizeof(conn)); num = step_fro = 0; step_back = 1000; //对图进行输入并处理，建立可移动区域的图  for (int i = 0; i \u0026lt; h; ++i) gets(map[i]); for (int i = 0; i \u0026lt; h; ++i) for (int j = 0; j \u0026lt; w; ++j) if (map[i][j] != \u0026#39;#\u0026#39;) link[i][j] = ++num; for (int i =0; i \u0026lt; h;++i) for (int j = 0; j \u0026lt; w; ++j){ if (link[i][j]){ for (int k = 0; k \u0026lt; 4; ++k){ if (pos_next) conn[pos_now][++conn[pos_now][0]] = pos_next; } conn[pos_now][0] = pos_now; } } beg[0] = beg[1] = beg[2] = end[0] = end[1] = end[2] = 303; conn[303][0] = 303; for (int i = 0; i \u0026lt; h; ++i) for (int j = 0; j \u0026lt; w; ++j){ if (islower(map[i][j])) beg[map[i][j] - \u0026#39;a\u0026#39;] = pos_now; else if (isupper(map[i][j])) end[map[i][j] - \u0026#39;A\u0026#39;] = pos_now; } bfs(); printf(\u0026#34;%d\\n\u0026#34;, step_fro + step_back - 1002); } return 0; } ","date":"2016-08-04T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-1601-the-morning-after-halloween/","title":"UVa OJ 1601 - The Morning after Halloween"},{"content":" 自从博客搭建以来，已经陆续续地将页面更新几次了。总一开始的默认的landscape主题，到hueman，再到icarus，都有过尝试，最终还是选定了landscape作为主题。主要还是这个主题的自主性更大一些，而且有一个很大的banner，看起来比较舒服。\n 在调整各种颜色的时候，只是觉得黑色的比较舒服，没有那么刺眼，现在再看我的博客，居然和我在第二篇文章里提到的Morris\u0026rsquo;s Blog十分的相似(摊手)。\n 之前在各个板块，包括图标什么的，调整过很多次了，但是没有及时的记载下来，现在才想起来要有个记录什么的。不过话说回来，在知乎上看到别人更新的时候，都会用“某年某月某日”更新了XXX\u0026hellip;早就也想着要这样试一次了，借此机会，也算满足我的一个小愿望吧\n2016-08-04 1.更新了主页右上角图标 美化了GitHub的标志，同时增加了Facebook的图标，搜索栏也能使用Google搜索了。话说回来，我的Facebook基本没加什么好友哇，求勾搭(笑)。\n2.提交了Google和百度的抓取 一开始提交了好几次都不成功，后来才发现，在利用html文件进行验证的时候，需要把文件放在theme的source目录下，而不是根目录的source目录下。\n 不得不说还是Google的操作方便，效率也高啊。\n2016-08-06 3.解决了字符缩进问题 贴上去的代码再也不会出现莫名其妙的缩进问题了，高亮问题也得到了解决。其实更多的是编辑器的问题 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄\n4.返回顶部按钮优化 调用本地上传的jQuery文件，不会出现国内网络点击“返回顶部”按钮没有反应的问题\n5.新增文章目录 再也不用担心鼠标滚轮滚坏了还找不到需要的内容啦！\n6.更换了网页图标 没有烦人的四方形白边框了。这应该不是强迫症吧┑(￣Д ￣)┍\n7.右上角新加微博图标 大家一起愉快地刷微博啊。\n2016-08-07 8.更换了主页标题的字体样式 终于感觉看自己的博客首页没有那么别扭了！\n2016-08-11 9.修改了底部导航栏颜色 一片白色根本什么都看不清啊。还是黑色的舒服。\n2016-08-12 10.增加了文章封面 终于不用担心目录和文章开头的图片相冲突了。\n11.增加了二级目录 啊，缠绕在心头的心病终于解决了。\n2016-08-14 12.修改了水平线格式 果然还是1.3px，solid 叫人放心啊。\n2016-08-16 13.修复了最底部出现双斜杠的情况 找了好久的原因，最后发现是一个注释给写错了 (:зゝ∠)\n2016-08-17 14.更改了主页文章footer的位置 将主页文章的footer提到了标题下，为后续的界面更改做准备。\n15.修改了分享框内字体颜色 一开始大意了，没有调整，导致看不清框内文字，现已修正为黑色。\n2016-08-18 16.Recent Posts栏目更改 文章名称前增加了字符画，美化界面\n2016-08-21 17.修改文章预览效果 给文章预览的底部加上了文字渐隐效果。Read More按钮也将进行后续改进，以提升文章的打开速度，方便阅读\n2016-08-23 18.完善了Read More按钮 借鉴了Morris博客里的展开按钮。可以在主页进行展开和收缩，阅读更加快速和方便。但是焦点问题还是需要一点点修复\n2016-08-24 19.更改了引用的样式 进行了一定的美化，缩小了字样，添加了左边界，一定程度上有助于阅读\n20.进一步美化Recent Post栏目 令过长文章名称可以以省略号的形式隐藏，并将文章数量扩增到10个，文章名称前的字符画也改为用fontawesome中的图标\n21.更换主页banner 之前比较匆忙，没有太多的考虑banner，就用了一张秒五的图片。刚刚看番时无意中截下一张图，正式将其更换为新的banner。如果有人能认出来是哪部番的banner，直接给跪啊\n2016-08-28 22.修改了Archive界面 Archive界面更加简洁美观。由原来的多篇文章共用一行的无序状态，变为一片文章一行。增加了指示箭头，看起来更加轻松舒适\n23.更换了文章tag前的标志 由原来的#变为tag字符画\n2016-09-04 24.更换了侧边栏和archive页面字体 侧边栏变为Tahoma，避免了中英文同时显示时，中文过细的问题。 archive页面则变更为Verdana，更加易于阅读\n25.更换了二级标题颜色 二级标题终于能够一眼认出来了。（其实是我以前二级标题基本没用过啦╮(╯▽╰)╭）\n2016-09-05 26.更改了顶栏和底栏 顶栏的github和facebook图标已经移至底栏（可惜了没有微博的方块图标/(ㄒoㄒ)/~~）。同时在底栏添加了一句自己想说的话。\n27.更改了顶栏标题字体 这次是二更标题字体了，之前的字体还是没有好斟酌，这次重新选定了一个，CSS中的顺序是Calligraph421 BT排在第一。\n2016-09-16 27.小幅修改最近文章栏目 将图标和文字链接分开，同时更改了图标颜色\n28.更改上翻图标并增加下翻按钮 将利用上翻按钮的图片改为font-awesome中的图片文字。同时增加了下翻按钮\n29. 提供数学公式的支持 \u0026ndash; 2020.11.19\n替换hexo-renderer-marked为hexo-renderer-kramed，以提供更好的markdown支持，并使用hexo-renderer-mathjax增加对 MathJax 的支持。\nnpm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save npm install hexo-renderer-mathjax --save ","date":"2016-08-04T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/","title":"关于博客的二三事"},{"content":" 博客已经开起来了，后续还会继续地完善。\n不过我本身水平有限，开这样一个博客，或许更多的，是一种的自娱自乐吧。能给大家带来一点帮助的话，自然是不胜荣幸的。\n嘛，既然自己现在还处在一个入门的阶段，对编程的理解也是很浅显，那就还有很多的东西需要去学，需要去尝试。有时候会感觉，写代码不光是数学层面的计算，还融合了语言的表达能力在里面。\n来一个突兀的中断吧。先暂时写这么多。\n","date":"2016-08-04T00:00:00Z","permalink":"https://yuukidach.github.io/p/%E6%97%A0%E6%89%80%E4%BA%8B%E4%BA%8B%E7%9A%84%E9%97%B2%E6%9A%87%E6%97%B6%E5%85%89/","title":"无所事事的闲暇时光"},{"content":"Problem There are three jugs with a volume of a, b and c liters. (a, b, and c are positive integers not greater than 200). The first and the second jug are initially empty, while the third is completely filled with water. It is allowed to pour water from one jug into another until either the first one is empty or the second one is full. This operation can be performed zero, one or more times.\nYou are to write a program that computes the least total amount of water that needs to be poured; so that at least one of the jugs contains exactly d liters of water (d is a positive integer not greater than 200). If it is not possible to measure d liters this way your program should find a smaller amount of water d′ \u0026lt; d which is closest to d and for which d′ liters could be produced. When d′ is found, your program should compute the least total amount of poured water needed to produce d′ liters in at least one of the jugs.\nInput The first line of input contains the number of test cases. In the next T lines, T test cases follow. Each test case is given in one line of input containing four space separated integers — a, b, c and d.\nOutput The output consists of two integers separated by a single space. The first integer equals the least total amount (the sum of all waters you pour from one jug to another) of poured water. The second integer equals d, if d liters of water could be produced by such transformations, or equals the closest smaller value d′ that your program has found.\nSample Input 2 2 3 4 2 96 97 199 62 Sample Output 2 2 9859 62 Solution 这是一个最短路径问题，利用BFS即可以得到答案。\n主要还是需要注意运行时间问题，尽量将循环的范围缩小。同时，使用memset对字节进行操作也能起到提升速度的作用。\n这里在做完题目以后恰好看到了Morris\u0026rsquo;s Blog，感觉他的代码格式看起来很舒服，也便于大家理解，因此将代码格式改得和他基本一样了，只做了一点微小的改动。大家可以也去他的Blog逛一逛，还是有很大收获的。\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; #define sf 0x7f const int maxn = 201; queue\u0026lt;int\u0026gt; qa,qb,qc,qd; int vis[maxn][maxn][maxn],water[maxn]; int A, B, C, D; void Push_Node(int a, int b, int c, int d){ qa.push(a), qb.push(b), qc.push(c), qd.push(d); } void bfs(int a,int b,int c, int d){ Push_Node(a, b, c, d); while (!qa.empty()){ a = qa.front(), qa.pop(); b = qb.front(), qb.pop(); c = qc.front(), qc.pop(); d = qd.front(), qd.pop(); if (d \u0026gt;= water[D]) continue; if (d \u0026gt;= vis[a][b][c]) continue; vis[a][b][c] = d;\twater[a] = min(water[a], d); water[b] = min(water[b], d); water[c] = min(water[c], d); if (a \u0026lt; B-b) Push_Node(0, b+a, c, d+a); else\tPush_Node(a-(B-b), B, c, d+(B-b)); if (a \u0026lt; C-c) Push_Node(0, b, c+a, d+a); else Push_Node(a-(C-c), b, C, d+(C-c)); if (b \u0026lt; A-a) Push_Node(a + b, 0, c, d + b); else Push_Node(A, b-(A-a), c, d+(A-a)); if (b \u0026lt; C-c) Push_Node(a, 0, c+b, d+b); else Push_Node(a, b-(C-c), C, d+(C-c)); if (c \u0026lt; A-a) Push_Node(a+c, b, 0, d+c); else Push_Node(A, b, c-(A-a), d+(A-a)); if (c \u0026lt; B-b) Push_Node(a, b+c, 0, d+c); else Push_Node(a, B, c-(B-b), d+(B-b)); } } int main(){ int cas,a,b,c,d; scanf(\u0026#34;%d\u0026#34;,\u0026amp;cas); while (cas--){ scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;A, \u0026amp;B, \u0026amp;C, \u0026amp;D); memset(water, sf, sizeof(water)); for (int i = 0; i \u0026lt;= A; i++) for (int j = 0; j \u0026lt;= B; j++) for (int k = 0; k \u0026lt;= C; k++) vis[i][j][k] = 0x7ffffff; bfs(0, 0, C, 0); while (water[D] == 0x7f7f7f7f)\tD--; printf(\u0026#34;%d %d\\n\u0026#34;, water[D], D); } return 0; } ","date":"2016-08-01T00:00:00Z","permalink":"https://yuukidach.github.io/p/uva-oj-10603-fill/","title":"UVa OJ 10603 - Fill"},{"content":"Welcome to Yuuki_Dach\u0026rsquo;s Blog! :D\nThis is my very first post. I will upload some of my learning progress in this blog. If you are interested in my projects, you can also find them in My GitHub.\n","date":"2016-07-23T00:00:00Z","permalink":"https://yuukidach.github.io/p/hello-world/","title":"Hello World"}]